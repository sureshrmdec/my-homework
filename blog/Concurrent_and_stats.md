# 并发与状态
并发也许计算机中最难处理的部分，而且它又无处不在。比如你多个连接同时操作一个数据库；多个进程修改和读取一个文件时；抢火车票时，票不会凭空多出来；同时进行多个取钱操作时，银行保证你不会凭空多取出钱来。(这里也许需要更多、更好的使用发生场景)。If you want your computer run faster, you need paralisment.
所以我想就想着这里谈谈到底什么是并发，毕竟搞清楚了问题的本质，才能应变问题以及相关问题。

## 基础例子
我们就拿上面的抢火车票来说举例吧！这个例子只要是中国人都应该有经历，所以有共鸣。

```
张三（看看还有多少票）--------------->    -----------
李四（看看还有多少票）--------------->    |北京-上海 |
。                                     |余票：2	  |
。                                    	|         |
。                                     |         |
Alice（看看还有多少票）------------->	   -----------
```

```
张三（有票，赶紧买）--------------->   -----------
李四（怎么只剩2张）--------------->    |北京-上海 |
。                                  |余票：2   |
。                                  |         |
。                                  |         |
Alice（我也要买）------------->	    -----------
```

从上面看来，买票就的动作可以分成2个阶段，而我们用m来表是此时剩余的票数:

1. 读取当前余票：m ---> read
2. 如果有，就买票：m-1  ----> write

翻译成程序：

```
void bug_ticket(){
	m=get_ticket_count(); //read 操作
	if(m>0){
		buy();
		rewrite_ticket_count(m-1); //write 操作,票减一张
	}
}
```


为了简单期间，我们假设只有两个人抢票：A和B。那么所以的动作就有4个：

**{A1，A2，B1，B2}**（注意这是集合，是无序。当然我们发现A2在A1前面发生其实是无意义，因为买票肯定会先读取一下现在还有没有余票。同理B1和B2的顺序）

我们理想的买票状况是排队：
A 操作完A1，然后操作A2。然后B 在操作B1，然后再操作B2。但是现实中你不可能要求A做读取操作，不允许B不能读取吧。抢票关键还是看第二步操作谁快，才公平。所以就会出现这种序列：

**[A1，B1，A2，B2]**

但是这种我们仔细想想就会出问题：
A1：A执行get_ticket_count()，发现有m=1张
B1：B同时执行get_ticket_count()，发现有m=1张
A2：A抢先执行了buy()并且rewrite_ticket_count(0)
B2：B已经在B1的时候拿到了余票数，虽然期间被A修改了，但是B并不知道，让然执行buy()并且rewrite_ticket_count(0)

Ops！！发现一张票卖给了两个人。

其实用另一个更简单的例子：计数
A读取计数器发现现在到了100，同时B也读取计数器发现是100
A现在对计数器操作，计数器现在是100，加上我自己应该是101，所以重写101到计数器中
B可能就是慢了1纳秒，但是B还认为计数器才累积到100，所以加上自己应该是101，写入101到计数器中。
可是计数机本应该是102的，少了1。

发现并发控制不好，数要么莫名的多，要么莫名的少。

## 锁
有了问题，就应该想办法解决问题。**并发问题解决本质就是限制其子原子操作的排列组合顺序,让不该发生的顺序排列不要发生**。例如上面子原子操作的集合是**{A1，A2，B1，B2}**，其中有read操作必须先与write操作的限制条件，即A1先与A2,B1先与B2，其排列有：

- [A1，A2，B1，B2]
- [A1，B1，A2，B2]
- [B1，A1，A2，B2]
- [B1，B2，A2，A2]
- [B1，A1，B2，A2]

加上读锁，即A或者B执行read的时候不允许其他人read和write直到本人write操作完成。这样做的结果就是:

- [A1，A2，B1，B2]
- [A1，B1，A2，B2] --- 被排除
- [B1，A1，A2，B2] --- 被排除
- [B1，B2，A2，A2] 
- [B1，A1，B2，A2] --- 被排除

加read lock也许是最直接的方法，但是也是最暴力的。比如你在查看余票，就不允许别人同时查看余票，这个估计其他人是要砸桌子了。


通过上面的子原子操作，我们看到并发的同时其实是个概念化的时间，和现实中的同时不是完全的一致。它其实是根据共享数据的状态划分的，状态改变一次算是一个时刻。这种比如你打开一个wikipedia的页面放置了一天没关，而期间也没人更改内容，那么一天后你再去查看内容，前后还是处于同一时刻。但是如果有人期间更改了内容，那么共享的内容的时刻已经前进了，而你一天后的内容就是过时的。

第二种稍好办法就是，加上读取时间，来标识读取的哪个时刻（状态版本）。
