<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.2 Unix Domain Socket Address Structure"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch15lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch15lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec2"></A>
<H3 class="docSection1Title" id="162666-993">15.2 Unix Domain Socket Address Structure</H3>
<P class="docText"><A class="docLink" HREF="#ch15fig01">Figure 15.1</A> shows the Unix domain socket address structure, which is defined by including the <TT>&lt;sys/un.h&gt;</TT> header.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig01"></A>Figure 15.1 Unix domain socket address structure: <TT>sockaddr_un</TT>.</H5>

<PRE>
struct sockaddr_un {
  sa_family_t sun_family;     /* AF_LOCAL */
  char        sun_path[104];  /* null-terminated pathname */
};
</PRE>

<BLOCKQUOTE><P><P class="docList">The POSIX specification does not define the length of the <TT>sun_path</TT> array and it specifically warns that applications should not assume a particular length. Use the <TT>sizeof</TT> operator to find the length at run-time and to verify that a pathname fits into the array. The length is likely to be between 92 and 108 rather than a larger value big enough to hold any pathname. The reason for these limits is an implementation artifact dating back to 4.2BSD requiring that this structure fit in a 128-byte mbuf (a kernel memory buffer).</P></P></BLOCKQUOTE>
<P class="docText">The pathname stored in the <TT>sun_path</TT> array must be null-terminated. The macro <TT>SUN_LEN</TT> is provided and it takes a pointer to a <TT>sockaddr_un</TT> structure and returns the length of the structure, including the number of non-null bytes in the pathname. The unspecified address is indicated by a null string as the pathname, that is, a structure with <TT>sun_path[0]</TT> equal to 0. This is the Unix domain equivalent of the IPv4 <TT>INADDR_ANY</TT> constant and the IPv6 <TT>IN6ADDR_ANY_INIT</TT> constant.</P>
<BLOCKQUOTE><P><P class="docList">POSIX renames the Unix domain protocols as "local IPC," to remove the dependence on the Unix OS. The historical constant <TT>AF_UNIX</TT> becomes <TT>AF_LOCAL</TT>. Nevertheless, we still use the term "Unix domain" as that has become its <span class="docEmphasis">de facto</span> name, regardless of the underlying OS. Also, even with POSIX attempting to make these OS-independent, the socket address structure still retains the <TT>_un</TT> suffix!</P></P></BLOCKQUOTE>
<A NAME="ch15lev2sec1"></A>
<H4 class="docSection2Title"> Example: <TT>bind</TT> of Unix Domain Socket</H4>
<P class="docText">The program in <A class="docLink" HREF="#ch15fig02">Figure 15.2</A> creates a Unix domain socket, <TT>binds</TT> a pathname to it, and then calls <TT>getsockname</TT> and prints the bound pathname.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig02"></A>Figure 15.2 <TT>bind</TT> of a pathname to a Unix domain socket.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/unixbind.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;
 6     socklen_t len;
 7     struct sockaddr_un addr1, addr2;

 8     if (argc != 2)
 9         err_quit("usage: unixbind &lt;pathname&gt;");

10     sockfd = Socket(AF_LOCAL, SOCK_STREAM, 0);

11     unlink(argv[1]);            /* OK if this fails */

12     bzero(&amp;addr1, sizeof(addr1));
13     addr1.sun_family = AF_LOCAL;
14     strncpy(addr1.sun_path, argv[1], sizeof(addr1.sun_path) - 1);
15     Bind(sockfd, (SA *) &amp;addr1, SUN_LEN(&amp;addr1));

16     len = sizeof(addr2);
17     Getsockname(sockfd, (SA *) &amp;addr2, &amp;len);
18     printf("bound name = %s, returned len = %d\n", addr2.sun_path, len);

19     exit(0);
20 }
</PRE>

<A NAME="ch15lev3sec1"></A>
<H5 class="docSection3Title"> Remove pathname first</H5>
<p class="docText"><span class="docEmphasis"><TT>11</TT></span> The pathname that we <TT>bind</TT> to the socket is the command-line argument. But the <TT>bind</TT> will fail if the pathname already exists in the filesystem. Therefore, we call <TT>unlink</TT> to delete the pathname, in case it already exists. If it does not exist, <TT>unlink</TT> returns an error, which we ignore.</p>

<A NAME="ch15lev3sec2"></A>
<H5 class="docSection3Title"> <TT>bind</TT> and then <TT>getsockname</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>12–18</TT></span> We copy the command-line argument using <TT>strncpy</TT>, to avoid overflowing the structure if the pathname is too long. Since we initialize the structure to zero and then subtract one from the size of the <TT>sun_path</TT> array, we know the pathname is null-terminated. <TT>bind</TT> is called and we use the macro <TT>SUN_LEN</TT> to calculate the length argument for the function. We then call <TT>getsockname</TT> to fetch the name that was just bound and print the result.</p>
<P class="docText">If we run this program under Solaris, we obtain the following results:</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">umask</span>                           <span class="docEmphRoman"><span class="docEmphasis">first print our umask value</span></span>
022                                         <span class="docEmphasis">shells print this value in octal</span>
solaris % <span class="docEmphStrong">unixbind /tmp/moose</span>
bound name = /tmp/moose, returned len = 13
solaris % <span class="docEmphStrong">unixbind /tmp/moose</span>              <span class="docEmphRoman"><span class="docEmphasis">run it again</span></span>
bound name = /tmp/moose, returned len = 13
solaris % <span class="docEmphStrong">ls -l /tmp/moose</span>
srwxr-xr-x 1 andy     staff       0 Aug 10 13:13 /tmp/moose
solaris %<span class="docEmphStrong">unixbind /tmp/moose</span>
srwxr-xr-x 1 andy     staff       0 Aug 10 13:13 /tmp/moose
</pre><pre>
</pre>
<P class="docText">We first print our <TT>umask</TT> value because POSIX specifies that the file access permissions of the resulting pathname should be modified by this value. Our value of 22 turns off the group-write and other-write bits. We then run the program and see that the length returned by <TT>getsockname</TT> is 13: 2 bytes for the <TT>sun_family</TT> member and 11 bytes for the actual pathname (excluding the terminating null byte). This is an example of a value-result argument whose result when the function returns differs from its value when the function was called. We can output the pathname using the <TT>%s</TT> format of <TT>printf</TT> because the pathname is null-terminated in the <TT>sun_path</TT> member. We then run the program again, to verify that calling <TT>unlink</TT> removes the pathname.</P>
<P class="docText">We run <TT>ls -l</TT> to see the file permissions and file type. Under Solaris (and most Unix variants), the file type is a socket, which is printed as <TT>s</TT>. We also notice that the permission bits were modified as appropriate by the <TT>umask</TT> value. Finally, we run <TT>ls</TT> again, with the <TT>-F</TT> option, which causes Solaris to append an equals sign to the pathname.</P>
<BLOCKQUOTE><P><P class="docList">Historically, the <TT>umask</TT> value did not apply to the creation of Unix domain sockets, but over time, most Unix vendors have fixed this so the permissions fit expectations. Systems still exist where the file permission bits may show either all permissions or no permissions (regardless of the <TT>umask</TT> setting). In addition, some systems show the file as a FIFO, which is printed as <TT>p</TT>, and not all systems show the equals sign with <TT>ls -F</TT>. The behavior we show above is the most common.</P></P></BLOCKQUOTE>



<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch15lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch15lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
