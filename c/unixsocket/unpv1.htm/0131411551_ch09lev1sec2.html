<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="9.2 Interface Models"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch09lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch09lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch09lev1sec2"></A>
<H3 class="docSection1Title">9.2 Interface Models</H3>
<P class="docText">There are two types of SCTP sockets: a <span class="docEmphasis">one-to-one</span> socket and a <span class="docEmphasis">one-to-many</span> socket. A one-to-one socket corresponds to exactly one SCTP association. (Recall from <A class="docLink" HREF="0131411551_ch02lev1sec5.html#ch02lev1sec5">Section 2.5</A> that an SCTP association is a connection between two systems, but may involve more than two IP addresses due to multihoming.) This mapping is similar to the relationship between a TCP socket and a TCP connection. With a one-to-many socket, several SCTP associations can be active on a given socket simultaneously. This mapping is similar to the manner in which a UDP socket bound to a particular port can receive interleaved datagrams from several remote UDP endpoints that are all simultaneously sending data.</P>
<P class="docText">When deciding which style of interface to use, the application needs to consider several factors, including:</P>
<UL><LI><P class="docList">What type of server is being written, <span class="docEmphasis">iterative</span> or <span class="docEmphasis">concurrent</span>?</P></LI><LI><P class="docList">How many socket descriptors does the server wish to manage?</P></LI><LI><P class="docList">Is it important to optimize the association setup to enable data on the third (and possibly fourth) packet of the four-way handshake?</P></LI><LI><P class="docList">How much connection state does the application wish to maintain?</P><BLOCKQUOTE><P><P class="docList">When the sockets API for SCTP was under development, different terminology was used for the two styles of sockets, and readers may sometimes encounter these older terms in documentation or source code. The original term for the one-to-one socket was a "TCP-style" socket, and the original term for a one-to-many socket was a "UDP-style" socket.</P></P><P><P class="docList">These style terms were later dropped because they tended to cause confusion by creating expectations that SCTP would behave more like TCP or UDP, depending on which style of socket was used. In fact, these terms referred to only one aspect of the differences between TCP and UDP sockets (i.e., whether a socket supports multiple concurrent transport-layer associations). The current terminology ("one-to-one" versus "one-to-many") focuses our attention on the key difference between the two socket styles. Finally, note that some writers use the term "many-to-one" instead of "one-to-many"; the terms are interchangeable.</P></P></BLOCKQUOTE></LI></UL>
<A NAME="ch09lev2sec1"></A>
<H4 class="docSection2Title"> The One-to-One Style</H4>
<P class="docText">The one-to-one style was developed to ease the porting of existing TCP applications to SCTP. It provides nearly an identical model to that described in <A class="docLink" HREF="0131411551_ch04.html#ch04">Chapter 4</A>. There are some differences one should be aware of, especially when porting existing TCP applications to SCTP using this style.</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Any socket options must be converted to the SCTP equivalent. Two commonly found options are <TT>TCP_NODELAY</TT> and <TT>TCP_MAXSEG</TT>. These can be easily mapped to <TT>SCTP_NODELAY</TT> and <TT>SCTP_MAXSEG</TT>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">SCTP preserves message boundaries; thus, application-layer message boundaries are not required. For example, an application protocol based on TCP might do a <TT>write()</TT> system call to write a two-byte message length field, <span class="docEmphasis">x</span>, followed by a <TT>write()</TT> system call that writes <span class="docEmphasis">x</span> bytes of data. However, if this is done with SCTP, the receiving SCTP will receive two separate messages (i.e., the read call will return twice: once with a two-byte message, and then again with an <span class="docEmphasis">x</span> byte message).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Some TCP applications use a half-close to signal the end of input to the other side. To port such applications to SCTP, the application-layer protocol will need to be rewritten so that the application signals the end of input in the application data stream.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The <TT>send</TT> function can be used in the normal fashion. For the <TT>sendto</TT> and <TT>sendmsg</TT> functions, any address information included is treated as an override of the primary destination address (see <A class="docLink" HREF="0131411551_ch02lev1sec8.html#ch02lev1sec8">Section 2.8</A>).</P></span></LI></OL></span>
<P class="docText">A typical user of the one-to-one style will follow the timeline shown in <A class="docLink" HREF="#ch09fig01">Figure 9.1</A>. When the server is started, it opens a socket, binds to an address, and waits for a client connection with the <TT>accept</TT> system call. Sometime later, the client is started, it opens a socket, and initiates an association with the server. We assume the client sends a request to the server, the server processes the request, and the server sends back a reply to the client. This cycle continues until the client initiates a shutdown of the association. This action closes the association, whereupon the server either exits or waits for a new association. As can be seen by comparison to a typical TCP exchange, an SCTP one-to-one socket exchange proceeds in a fashion similar to that shown in <A class="docLink" HREF="0131411551_ch04lev1sec1.html#ch04fig01">Figure 4.1</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch09fig01"></A>Figure 9.1. Socket functions for SCTP one-to-one style.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="611" src="FILES/09fig01.gif" ALT="graphics/09fig01.gif"></p>

</CENTER>
<P class="docText">A one-to-one-style SCTP socket is an IP socket (family <TT>AF_INET</TT> or <TT>AF_INET6</TT>), with type <TT>SOCK_STREAM</TT> and protocol <TT>IPPROTO_SCTP</TT>.</P>

<A NAME="ch09lev2sec2"></A>
<H4 class="docSection2Title"> The One-to-Many Style</H4>
<P class="docText">The one-to-many style provides an application writer the ability to write a server without managing a large number of socket descriptors. A single socket descriptor will represent multiple associations, much the same way that a UDP socket can receive messages from multiple clients. An association identifier is used to identify a single association on a one-to-many-style socket. This association identifier is a value of type <TT>sctp_assoc_t</TT>; it is normally an integer. It is an opaque value; an application should not use an association identifier that it has not previously been given by the kernel. Users of the one-to-many style should keep the following issues in mind:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">When the client closes the association, the server side will automatically close as well, thus removing any state for the association inside the kernel.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Using the one-to-many style is the only method that can be used to cause data to be piggybacked on the third or fourth packet of the four-way handshake (see <A class="docLink" HREF="0131411551_ch09lev1sec16.html#ch09lev1sec16">Exercise 9.3</A>).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Any <TT>sendto</TT>, <TT>sendmsg</TT>, or <TT>sctp_sendmsg</TT> to an address for which an association does not yet exist will cause an active open to be attempted, thus creating (if successful) a new association with that address. This behavior occurs even if the application doing the send has called the <TT>listen</TT> function to request a passive open.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The user must use the <TT>sendto</TT>, <TT>sendmsg</TT>, or <TT>sctp_sendmsg</TT> functions, and may not use the <TT>send</TT> or <TT>write</TT> function. (If the <TT>sctp_peeloff</TT> function is used to create a one-to-one-style socket, <TT>send</TT> or <TT>write</TT> may be used on it.)</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Anytime one of the send functions is called, the primary destination address that was chosen by the system at association initiation time (<A class="docLink" HREF="0131411551_ch02lev1sec8.html#ch02lev1sec8">Section 2.8</A>) will be used unless the <TT>MSG_ADDR_OVER</TT> flag is set by the caller in a supplied <TT>sctp_sndrcvinfo</TT> structure. To supply this, the caller needs to use the <TT>sendmsg</TT> function with ancillary data, or the <TT>sctp_sendmsg</TT> function.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Association events (one of a number of SCTP notifications discussed in <A class="docLink" HREF="0131411551_ch09lev1sec14.html#ch09lev1sec14">Section 9.14</A>) may be enabled, so if an application does not wish to receive these events, it should disable them explicitly using the <TT>SCTP_EVENTS</TT> socket option. By default, the only event that is enabled is the <TT>sctp_data_io_event</TT>, which provides ancillary data to the <TT>recvmsg</TT> and <TT>sctp_recvmsg</TT> call. This default setting applies to both the one-to-one and one-to-many style.</P><BLOCKQUOTE><P><P class="docList">When the SCTP sockets API was first developed, the one-to-many-style interface was defined to have the association notification turned on by default as well. Later versions of the API document have since disabled all notifications except the <TT>sctp_data_io_event</TT> for both the one-to-one- and one-to-many-style interface. However not all implementations may have this behavior. It is always good practice for an application writer to explicitly disable (or enable) the notifications that are unwanted (or desired). This explicit approach assures the developer that the expected behavior will result no matter which OS the code is ported to.</P></P></BLOCKQUOTE></span></LI></OL></span>
<P class="docText">A typical one-to-many style timeline is depicted in <A class="docLink" HREF="#ch09fig02">Figure 9.2</A>. First, the server is started, creates a socket, binds to an address, calls <TT>listen</TT> to enable client associations, and calls <TT>sctp_recvmsg</TT>, which blocks waiting for the first message to arrive. A client opens a socket and calls <TT>sctp_sendto</TT>, which implicitly sets up the association and piggybacks the data request to the server on the third packet of the four-way handshake. The server receives the request, and processes and sends back a reply. The client receives the reply and closes the socket, thus closing the association. The server loops back to receive the next message.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch09fig02"></A>Figure 9.2. Socket functions for SCTP one-to-many style.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="513" src="FILES/09fig02.gif" ALT="graphics/09fig02.gif"></p>

</CENTER>
<P class="docText">This example shows an iterative server, where (possibly interleaved) messages from many associations (i.e., many clients) can be processed by a single thread of control. With SCTP, a one-to-many socket can also be used in conjunction with the <TT>sctp_peeloff</TT> function (see <A class="docLink" HREF="0131411551_ch09lev1sec12.html#ch09lev1sec12">Section 9.12</A>) to allow the iterative and concurrent server models to be combined as follows:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">The <TT>sctp_peeloff</TT> function can be used to peel off a particular association (for example, a long-running session) from a one-to-many socket into its own one-to-one socket.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The one-to-one socket of the extracted association can then be dispatched to its own thread or forked process (as in the concurrent model).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Meanwhile, the main thread continues to handle messages from any remaining associations in an iterative fashion on the original socket.</P></span></LI></OL></span>
<P class="docText">A one-to-many-style SCTP socket is an IP socket (family <TT>AF_INET</TT> or <TT>AF_INET6</TT>) with type <TT>SOCK_SEQPACKET</TT> and protocol <TT>IPPROTO_SCTP</TT>.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch09lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch09lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
