<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="23.3 Partial Delivery"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch23lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch23lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch23lev1sec3"></A>
<H3 class="docSection1Title">23.3 Partial Delivery</H3>
<P class="docText">Partial delivery will be used by the SCTP implementation any time a "large" message is being received, where "large" means the SCTP stack deems that it does not have the resources to dedicate to the message. The following considerations will be made by the receiving SCTP implementation before starting this API:</P>
<UL><LI><P class="docList">The amount of buffer space being consumed by the message must meet or exceed some threshold.</P></LI><LI><P class="docList">The stack can only deliver from the beginning of the message sequentially up to the first missing piece.</P></LI><LI><P class="docList">Once invoked, no other messages may be made available for the user until the current message has been completely received and passed to the user. This means that the large message blocks all other messages that would normally be deliverable, including those in other streams.</P></LI></UL>
<P class="docText">The KAME implementation of SCTP uses a threshold of one-half the socket receive buffer. At this writing, the default receive buffer for the stack is 131,072 bytes. So, without changing the <TT>SO_RCVBUF</TT>, a single message must be larger than 65,536 bytes before the partial delivery API will be invoked. To further extend the new version of the server from <A class="docLink" HREF="0131411551_ch10lev1sec2.html#ch10lev1sec2">Section 10.2</A>, we write a utility function that wraps the <TT>sctp_recvmsg</TT> function call. We then create a modified server to use our new function. <A class="docLink" HREF="#ch23fig02">Figure 23.2</A> shows our wrapper function to handle the partial delivery API.</P>
<A NAME="ch23lev3sec2"></A>
<H4 class="docSection2Title"> Prepare static buffer</H4>
<p class="docText"><span class="docEmphasis"><TT>12–15</TT></span> If the function's static buffer has not been allocated, allocate it and set up the state associated with it.</p>

<A NAME="ch23lev3sec3"></A>
<H4 class="docSection2Title"> Read message</H4>
<p class="docText"><span class="docEmphasis"><TT>16–18</TT></span> Read in the first message using the <TT>sctp_recvmsg</TT> function.</p>

<A NAME="ch23lev3sec4"></A>
<H4 class="docSection2Title"> Handle initial read error</H4>
<p class="docText"><span class="docEmphasis"><TT>19–22</TT></span> If <TT>sctp_recvmsg</TT> returns an error or an EOF, we pass it directly back to the caller.</p>

<A NAME="ch23lev3sec5"></A>
<H4 class="docSection2Title"> While there is more data for this message</H4>
<p class="docText"><span class="docEmphasis"><TT>23–24</TT></span> While the message flags show that the function has not received a complete message, collect more data. The function starts by calculating how much is left in the static buffer.</p>

<A NAME="ch23lev3sec6"></A>
<H4 class="docSection2Title"> See if we need to grow static buffer</H4>
<p class="docText"><span class="docEmphasis"><TT>25–34</TT></span> Whenever the function no longer has a minimum amount of room left in its receive buffer, it must grow the buffer. We do this using the <TT>realloc</TT> function to allocate a new buffer of the current size, plus an increment amount, and copy the old data. If for some reason the function cannot grow its buffer any more, it exits with an error.</p>

<A NAME="ch23lev3sec7"></A>
<H4 class="docSection2Title"> Receive more data</H4>
<p class="docText"><span class="docEmphasis"><TT>35–36</TT></span> Gather more data with the <TT>sctp_recvmsg</TT> function.</p>

<A NAME="ch23lev3sec8"></A>
<H4 class="docSection2Title"> Move forward</H4>
<p class="docText"><span class="docEmphasis"><TT>37–38</TT></span> The function increments the buffer index and goes back to test if it has read all of the message.</p>

<A NAME="ch23lev3sec9"></A>
<H4 class="docSection2Title"> At loop end</H4>
<p class="docText"><span class="docEmphasis"><TT>39–40</TT></span> When the loop terminates, the function copies the number of bytes read into the pointer provided by the caller and returns a pointer to the allocated buffer.</p>

<H5 class="docExampleTitle"><A NAME="ch23fig02"></A>Figure 23.2 Handling the partial delivery API.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctp_pdapircv.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 static uint8_t *sctp_pdapi_readbuf = NULL;
 3 static int sctp_pdapi_rdbuf_sz = 0;

 4 uint8_t *
 5 pdapi_recvmsg(int sock_fd,
 6               int *rdlen,
 7               SA *from,
 8               int *from_len, struct sctp_sndrcvinfo *sri, int *msg_flags)
 9 {
10     int     rdsz, left, at_in_buf;
11     int     frmlen = 0;

12     if (sctp_pdapi_readbuf == NULL) {
13         sctp_pdapi_readbuf = (uint8_t *) Malloc(SCTP_PDAPI_INCR_SZ);
14         sctp_pdapi_rdbuf_sz = SCTP_PDAPI_INCR_SZ;
15     }
16     at_in_buf =
17         Sctp_recvmsg(sock_fd, sctp_pdapi_readbuf, sctp_pdapi_rdbuf_sz, from,
18                      from_len, sri, msg_flags);
19     if (at_in_buf &lt; 1) {
20         *rdlen = at_in_buf;
21         return (NULL);
22     }
23     while ((*msg_flags &amp; MSG_EOR) == 0) {
24         left = sctp_pdapi_rdbuf_sz - at_in_buf;
25         if (left &lt; SCTP_PDAPI_NEED_MORE_THRESHOLD) {
26             sctp_pdapi_readbuf =
27                 realloc(sctp_pdapi_readbuf,
28                         sctp_pdapi_rdbuf_sz + SCTP_PDAPI_INCR_SZ);
29             if (sctp_pdapi_readbuf == NULL) {
30                 err_quit("sctp_pdapi ran out of memory");
31             }
32             sctp_pdapi_rdbuf_sz += SCTP_PDAPI_INCR_SZ;
33             left = sctp_pdapi_rdbuf_sz - at_in_buf;
34         }
35         rdsz = Sctp_recvmsg(sock_fd, &amp;sctp_pdapi_readbuf[at_in_buf],
36                             left, NULL, &amp;frmlen, NULL, msg_flags);
37         at_in_buf += rdsz;
38      }
39      *rdlen = at_in_buf;
40      return (sctp_pdapi_readbuf);
41  }
</PRE>

<P class="docText">We next modify our server in <A class="docLink" HREF="#ch23fig03">Figure 23.3</A> so that it uses the new function.</P>

<A NAME="ch23lev3sec10"></A>
<H4 class="docSection2Title"> Read message</H4>
<p class="docText"><span class="docEmphasis"><TT>29–30</TT></span> Here the server calls the new partial delivery utility function. The server calls this after nulling out any old data that may have been hanging around in the <TT>sri</TT> variable.</p>

<H5 class="docExampleTitle"><A NAME="ch23fig03"></A>Figure 23.3 Our server using the partial delivery API.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctpserv05.c</span></P>

<PRE>
26     for ( ; ; ) {
27         len = sizeof(struct sockaddr_in);
28         bzero(&amp;sri, sizeof(sri));
29         readbuf = pdapi_recvmsg(sock_fd, &amp;rd_sz,
30                                 (SA *) &amp;cliaddr, &amp;len, &amp;sri, &amp;msg_flags);
31         if (readbuf == NULL)
32             continue;
</PRE>


<A NAME="ch23lev3sec11"></A>
<H4 class="docSection2Title"> Verify we read something</H4>
<p class="docText"><span class="docEmphasis"><TT>31–32</TT></span> Note that now the server must test for NULL to see if the read was successful. If not, the server just continues.</p>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch23lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch23lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
