<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="25.3 UDP Echo Server Using 'SIGIO'"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch25lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch25lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch25lev1sec3"></A>
<H3 class="docSection1Title">25.3 UDP Echo Server Using <TT>SIGIO</TT></H3>
<P class="docText">We now provide an example similar to the right side of <A class="docLink" HREF="0131411551_ch25lev1sec2.html#ch25fig01">Figure 25.1</A>: a UDP server that uses the <TT>SIGIO</TT> signal to receive arriving datagrams. This example also illustrates the use of POSIX reliable signals.</P>
<P class="docText">We do not change the client at all from <A class="docLink" HREF="0131411551_ch08lev1sec5.html#ch08fig07">Figure 8.7</A> and <A class="docLink" HREF="0131411551_ch08lev1sec6.html#ch08fig08">8.8</A>, and the server <TT>main</TT> function does not change from <A class="docLink" HREF="0131411551_ch08lev1sec3.html#ch08fig03">Figure 8.3</A>. The only changes that we make are to the <TT>dg_echo</TT> function, which we show in the next four figures. <A class="docLink" HREF="#ch25fig02">Figure 25.2</A> shows the global declarations.</P>

<H5 class="docExampleTitle"><A NAME="ch25fig02"></A>Figure 25.2 Global declarations.</H5>
<P class="docText"><span class="docEmphasis">sigio/dgecho01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 static int sockfd;

 3 #define QSIZE     8             /* size of input queue */
 4 #define MAXDG  4096             /* max datagram size */

 5 typedef struct {
 6     void   *dg_data;            /* ptr to actual datagram */
 7     size_t  dg_len;             /* length of datagram */
 8     struct sockaddr *dg_sa;     /* ptr to sockaddr{} w/client's address */
 9     socklen_t dg_salen;         /* length of sockaddr{} */
10 } DG;
11 static DG dg[QSIZE];            /* queue of datagrams to process */
12 static long cntread[QSIZE + 1]; /* diagnostic counter */

13 static int iget;                /* next one for main loop to process */
14 static int iput;                /* next one for signal handler to read into */
15 static int nqueue;              /* # on queue for main loop to process */
16 static socklen_t clilen;        /* max length of sockaddr{} */

17 static void sig_io(int);
18 static void sig_hup(int);
</PRE>

<A NAME="ch25lev3sec1"></A>
<H4 class="docSection2Title"> Queue of received datagrams</H4>
<p class="docText"><span class="docEmphasis"><TT>3–12</TT></span> The <TT>SIGIO</TT> signal handler places arriving datagrams onto a queue. This queue is an array of <TT>DG</TT> structures that we treat as a circular buffer. Each structure contains a pointer to the received datagram, its length, a pointer to a socket address structure containing the protocol address of the client, and the size of the protocol address. <TT>QSIZE</TT> of these structures are allocated, and we will see in <A class="docLink" HREF="#ch25fig04">Figure 25.4</A> that the <TT>dg_echo</TT> function calls <TT>malloc</TT> to allocate memory for all the datagrams and socket address structures. We also allocate a diagnostic counter, <TT>cntread</TT>, that we will examine shortly. <A class="docLink" HREF="#ch25fig03">Figure 25.3</A> shows the array of structures, assuming the first entry points to a 150-byte datagram and the length of its associated socket address structure is 16.</p>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch25fig03"></A>Figure 25.3. Data structures used to hold received datagrams and their socket address structures.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="260" src="FILES/25fig03.gif" ALT="graphics/25fig03.gif"></p>

</CENTER>

<A NAME="ch25lev3sec2"></A>
<H4 class="docSection2Title"> Array indexes</H4>
<p class="docText"><span class="docEmphasis"><TT>13–15</TT></span> <TT>iget</TT> is the index of the next array entry for the main loop to process, and <TT>iput</TT> is the index of the next array entry for the signal handler to store into. <TT>nqueue</TT> is the total number of datagrams on the queue for the main loop to process.</p>
<P class="docText"><A class="docLink" HREF="#ch25fig04">Figure 25.4</A> shows the main server loop, the <TT>dg_echo</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch25fig04"></A>Figure 25.4 <TT>dg_echo function</TT>: server main processing loop.</H5>
<P class="docText"><span class="docEmphasis">sigio/dgecho01.c</span></P>

<PRE>
19 void
20 dg_echo(int sockfd_arg, SA *pcliaddr, socklen_t clilen_arg)
21 {
22     int     i;
23     const int on = 1;
24     sigset_t zeromask, newmask, oldmask;

25     sockfd = sockfd_arg;
26     clilen = clilen_arg;

27     for (i = 0; i &lt; QSIZE; i++) {    /* init queue of buffers */
28         dg[i].dg_data = Malloc(MAXDG);
29         dg[i].dg_sa = Malloc(clilen);
30         dg[i].dg_salen = clilen;
31     }
32     iget = iput = nqueue = 0;

33     Signal(SIGHUP, sig_hup);
34     Signal(SIGIO, sig_io);
35     Fcntl(sockfd, F_SETOWN, getpid());
36     Ioctl(sockfd, FIOASYNC, &amp;on);
37     Ioctl(sockfd, FIONBIO, &amp;on);

38     Sigemptyset(&amp;zeromask);     /* init three signal sets */
39     Sigemptyset(&amp;oldmask);
40     Sigemptyset(&amp;newmask);
41     Sigaddset(&amp;newmask, SIGIO); /* signal we want to block */

42     Sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);
43     for ( ; ; ) {
44         while (nqueue == 0)
45             sigsuspend(&amp;zeromask); /* wait for datagram to process */

46             /* unblock SIGIO */
47         Sigprocmask(SIG_SETMASK, &amp;oldmask, NULL);

48         Sendto(sockfd, dg[iget].dg_data, dg[iget].dg_len, 0,
49                dg[iget].dg_sa, dg[iget].dg_salen);

50         if (++iget &gt;= QSIZE)
51             iget = 0;

52             /* block SIGIO */
53         Sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);
54         nqueue--;
55     }
56 }
</PRE>


<A NAME="ch25lev3sec3"></A>
<H4 class="docSection2Title"> Initialize queue of received datagrams</H4>
<p class="docText"><span class="docEmphasis"><TT>27–32</TT></span> The socket descriptor is saved in a global variable since the signal handler needs it. The queue of received datagrams is initialized.</p>

<A NAME="ch25lev3sec4"></A>
<H4 class="docSection2Title"> Establish signal handlers and set socket flags</H4>
<p class="docText"><span class="docEmphasis"><TT>33–37</TT></span> Signal handlers are established for <TT>SIGHUP</TT> (which we use for diagnostic purposes) and <TT>SIGIO</TT>. The socket owner is set using <TT>fcntl</TT> and the signal-driven and non-blocking I/O flags are set using <TT>ioctl</TT>.</p>
<BLOCKQUOTE><P><P class="docList">We mentioned earlier that the <TT>O_ASYNC</TT> flag with <TT>fcntl</TT> is the POSIX way to specify signal-driven I/O, but since most systems do not yet support it, we use <TT>ioctl</TT> instead. While most systems do support the <TT>O_NONBLOCK</TT> flag to set nonblocking, we show the <TT>ioctl</TT> method here.</P></P></BLOCKQUOTE>

<A NAME="ch25lev3sec5"></A>
<H4 class="docSection2Title"> Initialize signal sets</H4>
<p class="docText"><span class="docEmphasis"><TT>38–41</TT></span> Three signal sets are initialized: <TT>zeromask</TT> (which never changes), <TT>oldmask</TT> (which contains the old signal mask when we block <TT>SIGIO</TT>), and <TT>newmask. sigaddset</TT> turns on the bit corresponding to <TT>SIGIO</TT> in <TT>newmask</TT>.</p>

<A NAME="ch25lev3sec6"></A>
<H4 class="docSection2Title"> Block <TT>SIGIO</TT> and wait for something to do</H4>
<p class="docText"><span class="docEmphasis"><TT>42–45</TT></span> <TT>sigprocmask</TT> stores the current signal mask of the process in <TT>oldmask</TT> and then logically ORs <TT>newmask</TT> into the current signal mask. This blocks <TT>SIGIO</TT> and returns the current signal mask. We then enter the <TT>for</TT> loop and test the <TT>nqueue</TT> counter. As long as this counter is 0, there is nothing to do and we can call <TT>sigsuspend</TT>. This POSIX function saves the current signal mask internally and then sets the current signal mask to the argument (<TT>zeromask</TT>). Since <TT>zeromask</TT> is an empty signal set, this enables all signals. <TT>sigsuspend</TT> returns after a signal has been caught and the signal handler returns. (It is an unusual function because it <span class="docEmphasis">always</span> returns an error, <TT>EINTR</TT>.) Before returning, <TT>sigsuspend</TT> always sets the signal mask to its value when the function was called, which in this case is the value of <TT>newmask</TT>, so we are guaranteed that when <TT>sigsuspend</TT> returns, <TT>SIGIO</TT> is blocked. That is why we can test the counter <TT>nqueue</TT>, knowing that while we are testing it, a <TT>SIGIO</TT> signal cannot be delivered.</p>
<BLOCKQUOTE><P><P class="docList">Consider what would happen if <TT>SIGIO</TT> was not blocked while we tested the variable <TT>nqueue</TT>, which is shared between the main loop and the signal handler. We could test <TT>nqueue</TT> and find it 0, but immediately after this test, the signal is delivered and <TT>nqueue</TT> gets set to 1. We then call <TT>sigsuspend</TT> and go to sleep, effectively missing the signal. We are never awakened from the call to <TT>sigsuspend</TT> unless another signal occurs. This is similar to the race condition we described in <A class="docLink" HREF="0131411551_ch20lev1sec5.html#ch20lev1sec5">Section 20.5</A>.</P></P></BLOCKQUOTE>

<A NAME="ch25lev3sec7"></A>
<H4 class="docSection2Title"> Unblock <TT>SIGIO</TT> and send reply</H4>
<p class="docText"><span class="docEmphasis"><TT>46–51</TT></span> We unblock <TT>SIGIO</TT> by calling <TT>sigprocmask</TT> to set the signal mask of the process to the value that was saved earlier (<TT>oldmask</TT>). The reply is then sent by <TT>sendto</TT>. The <TT>iget</TT> index is incremented, and if its value is the number of elements in the array, its value is set back to 0. We treat the array as a circular buffer. Notice that we do not need <TT>SIGIO</TT> blocked while modifying <TT>iget</TT>, because this index is used only by the main loop; it is never modified by the signal handler.</p>

<A NAME="ch25lev3sec8"></A>
<H4 class="docSection2Title"> Block <TT>SIGIO</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>52–54</TT></span> <TT>SIGIO</TT> is blocked and the value of <TT>nqueue</TT> is decremented. We must block the signal while modifying this variable since it is shared between the main loop and the signal handler. Also, we need <TT>SIGIO</TT> blocked when we test <TT>nqueue</TT> at the top of the loop.</p>
<P class="docText">An alternate technique is to remove both calls to <TT>sigprocmask</TT> that are within the <TT>for</TT> loop, which avoids unblocking the signal and then blocking it later. The problem, however, is that this executes the entire loop with the signal blocked, which decreases the responsiveness of the signal handler. Datagrams should not get lost because of this change (assuming the socket receive buffer is large enough), but the delivery of the signal to the process will be delayed the entire time that the signal is blocked. One goal when coding applications that perform signal handling should be to block the signal for the minimum amount of time.</P>
<P class="docText"><A class="docLink" HREF="#ch25fig05">Figure 25.5</A> shows the <TT>SIGIO</TT> signal handler.</P>

<H5 class="docExampleTitle"><A NAME="ch25fig05"></A>Figure 25.5 <TT>SIGIO</TT> handler.</H5>
<P class="docText"><span class="docEmphasis">sigio/dgecho01.c</span></P>

<PRE>
57 static void
58 sig_io(int signo)
59 {
60     ssize_t len;
61     int     nread;
62     DG     *ptr;

63     for (nread = 0;;) {
64         if (nqueue &gt;= QSIZE)
65             err_quit("receive overflow");

66         ptr = &amp;dg[iput];
67         ptr-&gt;dg_salen = clilen;
68         len = recvfrom(sockfd, ptr-&gt;dg_data, MAXDG, 0,
69                        ptr-&gt;dg_sa, &amp;ptr-&gt;dg_salen);
70         if (len &lt; 0) {
71             if (errno == EWOULDBLOCK)
72                 break;          /* all done; no more queued to read */
73             else
74                 err_sys("recvfrom error");
75          }
76          ptr-&gt;dg_len = len;

77          nread++;
78          nqueue++;
79          if (++iput &gt;= QSIZE)
80              iput = 0;

81     }
82     cntread[nread]++;            /* histogram of # datagrams read per signal */
83 }
</PRE>

<P class="docText">The problem that we encounter when coding this signal handler is that POSIX signals are normally <span class="docEmphasis">not</span> queued. This means that, if we are in the signal handler, which guarantees that the signal is blocked, and the signal occurs two more times, the signal is delivered only one more time.</P>
<BLOCKQUOTE><P><P class="docList">POSIX provides some real-time signals that <span class="docEmphasis">are</span> queued, but other signals such as <TT>SIGIO</TT> are normally not queued.</P></P></BLOCKQUOTE>
<P class="docText">Consider the following scenario: A datagram arrives and the signal is delivered. The signal handler reads the datagram and places it onto the queue for the main loop. But while the signal handler is executing, two more datagrams arrive, causing the signal to be generated two more times. Since the signal is blocked, when the signal handler returns, it is called only one more time. The second time the signal handler executes, it reads the second datagram, but the third datagram is left on the socket receive queue. This third datagram will be read only if and when a fourth datagram arrives. When a fourth datagram arrives, it is the third datagram that is read and placed on the queue for the main loop, not the fourth one.</P>
<P class="docText">Because signals are not queued, the descriptor that is set for signal-driven I/O is normally set to nonblocking also. We then code our <TT>SIGIO</TT> handler to read in a loop, terminating only when the read returns <TT>EWOULDBLOCK</TT>.</P>

<A NAME="ch25lev3sec9"></A>
<H4 class="docSection2Title"> Check for queue overflow</H4>
<p class="docText"><span class="docEmphasis"><TT>64–65</TT></span> If the queue is full, we terminate. There are other ways to handle this (e.g., additional buffers could be allocated), but for our simple example, we just terminate.</p>

<A NAME="ch25lev3sec10"></A>
<H4 class="docSection2Title"> Read datagram</H4>
<p class="docText"><span class="docEmphasis"><TT>66–76</TT></span> <TT>recvfrom</TT> is called on the nonblocking socket. The array entry indexed by <TT>iput</TT> is where the datagram is stored. If there are no datagrams to read, <TT>break</TT> jumps out of the <TT>for</TT> loop.</p>

<A NAME="ch25lev3sec11"></A>
<H4 class="docSection2Title"> Increment counters and index</H4>
<p class="docText"><span class="docEmphasis"><TT>77–80</TT></span> <TT>nread</TT> is a diagnostic counter of the number of datagrams read per signal. <TT>nqueue</TT> is the number of datagrams for the main loop to process.</p>
<p class="docText"><span class="docEmphasis"><TT>82</TT></span> Before the signal handler returns, it increments the counter corresponding to the number of datagrams read per signal. We print this array in <A class="docLink" HREF="#ch25fig06">Figure 25.6</A> when the <TT>SIGHUP</TT> signal is delivered as diagnostic information.</p>
<P class="docText">The final function (<A class="docLink" HREF="#ch25fig06">Figure 25.6</A>) is the <TT>SIGHUP</TT> signal handler, which prints the <TT>cntread</TT> array. This counts the number of datagrams read per signal.</P>

<H5 class="docExampleTitle"><A NAME="ch25fig06"></A>Figure 25.6 <TT>SIGHUP</TT> handler.</H5>
<P class="docText"><span class="docEmphasis">sigio/dgecho01.c</span></P>

<PRE>
84 static void
85 sig_hup(int signo)
86 {
87     int     i;

88     for (i = 0; i &lt;= QSIZE; i++)
89         printf("cntread[%d] = %ld\n", i, cntread[i]);
90 }
</PRE>

<P class="docText">To illustrate that signals are not queued and that we must set the socket to nonblocking in addition to setting the signal-driven I/O flag, we will run this server with six clients simultaneously. Each client sends 3,645 lines for the server to echo, and each client is started from a shell script in the background so that all clients are started at about the same time. When all the clients have terminated, we send the <TT>SIGHUP</TT> signal to the server, causing it to print its <TT>cntread</TT> array.</P>
<pre>

</pre><pre>
     linux % <span class="docEmphStrong">udpserv01</span>
     cntread[0] = 0
     cntread[1] = 15899
     cntread[2] = 2099
     cntread[3] = 515
     cntread[4] = 57
     cntread[5] = 0
     cntread[6] = 0
     cntread[7] = 0
     cntread[8] = 0
</pre><pre>
</pre>
<P class="docText">Most of the time, the signal handler reads only one datagram, but there are times when more than one is ready. The nonzero counter for <TT>cntread[0]</TT> is when the signal is generated while the signal handler is executing, but before the signal handler returns, it reads all pending datagrams. When the signal handler is called again, there are no datagrams left to read. Finally, we can verify that the weighted sum of the array elements (15899 x 1 + 2099 x 2 + 515 x 3 + 57 x 4 = 21870) equals 6 (the number of clients) times 3,645 lines per client.</P>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch25lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch25lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
