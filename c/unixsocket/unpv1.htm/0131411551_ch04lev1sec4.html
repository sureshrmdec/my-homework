<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.4 'bind' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch04lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch04lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch04lev1sec4"></A>
<H3 class="docSection1Title">4.4 <TT>bind</TT> Function</H3>
<P class="docText">The <TT>bind</TT> function assigns a local protocol address to a socket. With the Internet protocols, the protocol address is the combination of either a 32-bit IPv4 address or a 128-bit IPv6 address, along with a 16-bit TCP or UDP port number.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/socket.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int bind (int</TT> <span class="docEmphasis">sockfd</span>, <TT>const struct sockaddr *</TT><span class="docEmphasis">myaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK,-1 on error</P></TD></TR></COLGROUP></TABLE></P>
<BLOCKQUOTE><P><P class="docList">Historically, the man page description of <TT>bind</TT> has said "<TT>bind</TT> assigns a name to an unnamed socket." The use of the term "name" is confusing and gives the connotation of domain names (<A class="docLink" HREF="0131411551_ch11.html#ch11">Chapter 11</A>) such as <TT>foo.bar.com</TT>. The <TT>bind</TT> function has nothing to do with names. <TT>bind</TT> assigns a protocol address to a socket, and what that protocol address means depends on the protocol.</P></P></BLOCKQUOTE>
<P class="docText">The second argument is a pointer to a protocol-specific address, and the third argument is the size of this address structure. With TCP, calling <TT>bind</TT> lets us specify a port number, an IP address, both, or neither.</P>
<UL><LI><P class="docList">Servers bind their well-known port when they start. We saw this in <A class="docLink" HREF="0131411551_ch01lev1sec5.html#ch01fig09">Figure 1.9</A>. If a TCP client or server does not do this, the kernel chooses an ephemeral port for the socket when either <TT>connect</TT> or <TT>listen</TT> is called. It is normal for a TCP client to let the kernel choose an ephemeral port, unless the application requires a reserved port (<A class="docLink" HREF="0131411551_ch02lev1sec9.html#ch02fig10">Figure 2.10</A>), but it is rare for a TCP server to let the kernel choose an ephemeral port, since servers are known by their well-known port.</P><BLOCKQUOTE><P><P class="docList">Exceptions to this rule are Remote Procedure Call (RPC) servers. They normally let the kernel choose an ephemeral port for their listening socket since this port is then registered with the RPC port mapper. Clients have to contact the port mapper to obtain the ephemeral port before they can <TT>connect</TT> to the server. This also applies to RPC servers using UDP.</P></P></BLOCKQUOTE></LI><LI><P class="docList">A process can <TT>bind</TT> a specific IP address to its socket. The IP address must belong to an interface on the host. For a TCP client, this assigns the source IP address that will be used for IP datagrams sent on the socket. For a TCP server, this restricts the socket to receive incoming client connections destined only to that IP address.</P><P class="docList">Normally, a TCP client does not <TT>bind</TT> an IP address to its socket. The kernel chooses the source IP address when the socket is connected, based on the outgoing interface that is used, which in turn is based on the route required to reach the server (p. 737 of TCPv2).</P><P class="docList">If a TCP server does not bind an IP address to its socket, the kernel uses the destination IP address of the client's SYN as the server's source IP address (p. 943 of TCPv2).</P></LI></UL>
<P class="docText">As we said, calling <TT>bind</TT> lets us specify the IP address, the port, both, or neither. <A class="docLink" HREF="#ch04fig06">Figure 4.6</A> summarizes the values to which we set <TT>sin_addr</TT> and <TT>sin_port</TT>, or <TT>sin6_addr</TT> and <TT>sin6_port</TT>, depending on the desired result.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig06"></A>Figure 4.6. Result when specifying IP address and/or port number to <TT>bind</TT>.</H5>

<p class="docText">
<IMG BORDER="0" id="129022115118" WIDTH="452" HEIGHT="113" src="FILES/04fig06.gif" ALT="graphics/04fig06.gif"></p>

</CENTER>
<P class="docText">If we specify a port number of 0, the kernel chooses an ephemeral port when <TT>bind</TT> is called. But if we specify a wildcard IP address, the kernel does not choose the local IP address until either the socket is connected (TCP) or a datagram is sent on the socket (UDP).</P>
<P class="docText">With IPv4, the <span class="docEmphasis">wildcard</span> address is specified by the constant <TT>INADDR_ANY</TT>, whose value is normally 0. This tells the kernel to choose the IP address. We saw the use of this in <A class="docLink" HREF="0131411551_ch01lev1sec5.html#ch01fig09">Figure 1.9</A> with the assignment</P>
<pre>

</pre><pre>
        struct sockaddr_in   servaddr;
        servaddr.sin_addr.s_addr = htonl (INADDR_ANY);     /* wildcard */
</pre><pre>
</pre>
<P class="docText">While this works with IPv4, where an IP address is a 32-bit value that can be represented as a simple numeric constant (0 in this case), we cannot use this technique with IPv6, since the 128-bit IPv6 address is stored in a structure. (In C we cannot represent a constant structure on the right-hand side of an assignment.) To solve this problem, we write</P>
<pre>

</pre><pre>
        struct sockaddr_in6    serv;

        serv.sin6_addr = in6addr_any;     /* wildcard */
</pre><pre>
</pre>
<P class="docText">The system allocates and initializes the <TT>in6addr_any</TT> variable to the constant <TT>IN6ADDR_ANY_INIT</TT>. The <TT>&lt;netinet/in.h&gt;</TT> header contains the <TT>extern</TT> declaration for <TT>in6addr_any</TT>.</P>
<P class="docText">The value of <TT>INADDR_ANY</TT> (0) is the same in either network or host byte order, so the use of <TT>htonl</TT> is not really required. But, since all the <TT>INADDR</TT>_constants defined by the <TT>&lt;netinet/in.h&gt;</TT> header are defined in host byte order, we should use <TT>htonl</TT> with any of these constants.</P>
<P class="docText">If we tell the kernel to choose an ephemeral port number for our socket, notice that <TT>bind</TT> does not return the chosen value. Indeed, it cannot return this value since the second argument to <TT>bind</TT> has the <TT>const</TT> qualifier. To obtain the value of the ephemeral port assigned by the kernel, we must call <TT>getsockname</TT> to return the protocol address.</P>
<P class="docText">A common example of a process binding a non-wildcard IP address to a socket is a host that provides Web servers to multiple organizations (Section 14.2 of TCPv3). First, each organization has its own domain name, such as <TT>www.</TT><span class="docEmphasis">organization</span><TT>.com</TT>. Next, each organization's domain name maps into a different IP address, but typically on the same subnet. For example, if the subnet is 198.69.10, the first organization's IP address could be 198.69.10.128, the next 198.69.10.129, and so on. All these IP addresses are then <span class="docEmphasis">aliased</span> onto a single network interface (using the <TT>alias</TT> option of the <TT>ifconfig</TT> command on 4.4BSD, for example) so that the IP layer will accept incoming datagrams destined for any of the aliased addresses. Finally, one copy of the HTTP server is started for each organization and each copy <TT>binds</TT> only the IP address for that organization.</P>
<BLOCKQUOTE><P><P class="docList">An alternative technique is to run a single server that binds the wildcard address. When a connection arrives, the server calls <TT>getsockname</TT> to obtain the destination IP address from the client, which in our discussion above could be 198.69.10.128, 198.69.10.129, and so on. The server then handles the client request based on the IP address to which the connection was issued.</P></P><P><P class="docList">One advantage in binding a non-wildcard IP address is that the demultiplexing of a given destination IP address to a given server process is then done by the kernel.</P></P><P><P class="docList">We must be careful to distinguish between the interface on which a packet arrives versus the destination IP address of that packet. In <A class="docLink" HREF="0131411551_ch08lev1sec8.html#ch08lev1sec8">Section 8.8</A>, we will talk about the weak end system model and the strong end system model. Most implementations employ the former, meaning it is okay for a packet to arrive with a destination IP address that identifies an interface other than the interface on which the packet arrives. (This assumes a multihomed host.) Binding a non-wildcard IP address restricts the datagrams that will be delivered to the socket based only on the destination IP address. It says nothing about the arriving interface, unless the host employs the strong end system model.</P></P></BLOCKQUOTE>
<P class="docText">A common error from <TT>bind</TT> is <TT>EADDRINUSE</TT> ("Address already in use"). We will say more about this in <A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A> when we talk about the <TT>SO_REUSEADDR</TT> and <TT>SO_REUSEPORT</TT> socket options.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch04lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch04lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
