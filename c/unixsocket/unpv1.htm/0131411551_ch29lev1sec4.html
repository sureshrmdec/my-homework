<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="29.4 Linux: 'SOCK_PACKET' and 'PF_PACKET'"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch29lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch29lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch29lev1sec4"></A>
<H3 class="docSection1Title">29.4 Linux: <TT>SOCK_PACKET</TT> and <TT>PF_PACKET</TT></H3>
<P class="docText">There are two methods of receiving packets from the datalink layer under Linux. The original method, which is more widely available but less flexible, is to create a socket of type <TT>SOCK_PACKET</TT>. The newer method, which introduces more filtering and performance features, is to create a socket of family <TT>PF_PACKET</TT>. To do either, we must have sufficient privileges (similar to creating a raw socket), and the third argument to <TT>socket</TT> must be a nonzero value specifying the Ethernet frame type. When using <TT>PF_PACKET</TT> sockets, the second argument to <TT>socket</TT> can be <TT>SOCK_DGRAM</TT>, for "cooked" packets with the link-layer header removed, or <TT>SOCK_RAW</TT>, for the complete link-layer packet. <TT>SOCK_PACKET</TT> sockets only return the complete link layer packet. For example, to receive all frames from the datalink, we write</P>
<pre>

</pre><pre>
fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));        /* newer systems*/
</pre><pre>
</pre>
<P class="docText">or</P>
<pre>

</pre><pre>
fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL));      /* older systems*/
</pre><pre>
</pre>
<P class="docText">This would return frames for all protocols that the datalink receives.</P>
<P class="docText">If we wanted only IPv4 frames, the call would be</P>
<pre>

</pre><pre>
fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));          /* newer systems */
</pre><pre>
</pre>
<P class="docText">or</P>
<pre>

</pre><pre>
fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_IP));         /* older systems */
</pre><pre>
</pre>
<P class="docText">Other constants for the final argument are <TT>ETH_P_ARP</TT> and <TT>ETH_P_IPV6</TT>, for example.</P>
<P class="docText">Specifying a protocol of <TT>ETH_P_</TT><span class="docEmphasis">xxx</span> tells the datalink which frame types to pass to the socket for the frames the datalink receives. If the datalink supports a promiscuous mode (e.g., an Ethernet), then the device must also be put into a promiscuous mode, if desired. This is done with a <TT>PACKET_ADD_MEMBERSHIP</TT> socket option, using a <TT>packet_mreq</TT> structure specifying an interface and an action of <TT>PACKET_MR_PROMISC</TT>. On older systems, this is done instead by an <TT>ioctl</TT> of <TT>SIOCGIFFLAGS</TT> to fetch the flags, setting the <TT>IFF_PROMISC</TT> flag, and then storing the flags with <TT>SIOCSIFFLAGS</TT>. Unfortunately, with this method, multiple promiscuous listeners can interfere with each other and a buggy program can leave promiscuous mode on even after it exits.</P>
<P class="docText">Some differences are evident when comparing this Linux feature to BPF and DLPI:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">The Linux feature provides no kernel buffering and kernel filtering is only available on newer systems (via the <TT>SO_ATTACH_FILTER</TT> socket option). There is a normal socket receive buffer, but multiple frames cannot be buffered together and passed to the application with a single <TT>read</TT>. This increases the overhead involved in copying the potentially voluminous amounts of data from the kernel to the application.</P></span></LI><LI><span style="font-weight:normal"><P class="docList"><TT>SOCK_PACKET</TT> provides no filtering by device. (<TT>PF_PACKET</TT> sockets can be linked to a device by calling <TT>bind</TT>.) If <TT>ETH_P_IP</TT> is specified in the call to <TT>socket</TT>, then all IPv4 packets from all devices (Ethernets, PPP links, SLIP links, and the loopback device, for example) are passed to the socket. A generic socket address structure is returned by <TT>recvfrom</TT>, and the <TT>sa_data</TT> member contains the device name (e.g., <TT>eth0</TT>). The application must then discard data from any device in which it is not interested. The problem again is too much data can be returned to the application, which can get in the way when monitoring a high-speed network.</P></span></LI></OL></span>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch29lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch29lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
