<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.10 'getsockname' and 'getpeername' Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch04lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch04lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch04lev1sec10"></A>
<H3 class="docSection1Title">4.10 <TT>getsockname</TT> and <TT>getpeername</TT> Functions</H3>
<P class="docText">These two functions return either the local protocol address associated with a socket (<TT>getsockname</TT>) or the foreign protocol address associated with a socket (<TT>getpeername</TT>).</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/socket.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int getsockname(int</TT> <span class="docEmphasis">sockfd</span>, <TT>struct sockaddr *</TT><span class="docEmphasis">localaddr</span>, <TT>socklen_t *</TT><span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int getpeername(int</TT> <span class="docEmphasis">sockfd</span>, <TT>struct sockaddr *</TT><span class="docEmphasis">peeraddr</span>, <TT>socklen_t *</TT><span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Both return: 0 if OK, -1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">Notice that the final argument for both functions is a value-result argument. That is, both functions fill in the socket address structure pointed to by <span class="docEmphasis">localaddr</span> or <span class="docEmphasis">peeraddr</span>.</P>
<BLOCKQUOTE><P><P class="docList">We mentioned in our discussion of <TT>bind</TT> that the term "name" is misleading. These two functions return the protocol address associated with one of the two ends of a network connection, which for IPV4 and IPV6 is the combination of an IP address and port number. These functions have nothing to do with domain names (<A class="docLink" HREF="0131411551_ch11.html#ch11">Chapter 11</A>).</P></P></BLOCKQUOTE>
<P class="docText">These two functions are required for the following reasons:</P>
<UL><LI><P class="docList">After <TT>connect</TT> successfully returns in a TCP client that does not call <TT>bind</TT>, <TT>getsockname</TT> returns the local IP address and local port number assigned to the connection by the kernel.</P></LI><LI><P class="docList">After calling <TT>bind</TT> with a port number of 0 (telling the kernel to choose the local port number), <TT>getsockname</TT> returns the local port number that was assigned.</P></LI><LI><P class="docList"><TT>getsockname</TT> can be called to obtain the address family of a socket, as we show in <A class="docLink" HREF="#ch04fig19">Figure 4.19</A>.</P></LI><LI><P class="docList">In a TCP server that <TT>binds</TT> the wildcard IP address (<A class="docLink" HREF="0131411551_ch01lev1sec5.html#ch01fig09">Figure 1.9</A>), once a connection is established with a client (<TT>accept</TT> returns successfully), the server can call <TT>getsockname</TT> to obtain the local IP address assigned to the connection. The socket descriptor argument in this call must be that of the connected socket, and not the listening socket.</P></LI><LI><P class="docList">When a server is <TT>exec</TT>ed by the process that calls <TT>accept</TT>, the only way the server can obtain the identity of the client is to call <TT>getpeername</TT>. This is what happens whenever <TT>inetd</TT> (<A class="docLink" HREF="0131411551_ch13lev1sec5.html#ch13lev1sec5">Section 13.5</A>) <TT>forks</TT> and <TT>execs</TT> a TCP server. <A class="docLink" HREF="#ch04fig18">Figure 4.18</A> shows this scenario. <TT>inetd</TT> calls <TT>accept</TT> (top left box) and two values are returned: the connected socket descriptor, <TT>connfd</TT>, is the return value of the function, and the small box we label "peer's address" (an Internet socket address structure) contains the IP address and port number of the client. <TT>fork</TT> is called and a child of <TT>inetd</TT> is created. Since the child starts with a copy of the parent's memory image, the socket address structure is available to the child, as is the connected socket descriptor (since the descriptors are shared between the parent and child). But when the child <TT>execs</TT> the real server (say the Telnet server that we show), the memory image of the child is replaced with the new program file for the Telnet server (i.e., the socket address structure containing the peer's address is lost), and the connected socket descriptor remains open across the <TT>exec</TT>. One of the first function calls performed by the Telnet server is <TT>getpeername</TT> to obtain the IP address and port number of the client.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig18"></A>Figure 4.18. Example of <TT>inetd</TT> spawning a server.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="313" src="FILES/04fig18.gif" ALT="graphics/04fig18.gif"></p>

</CENTER></LI></UL>
<P class="docText">Obviously the Telnet server in this final example must know the value of <TT>connfd</TT> when it starts. There are two common ways to do this. First, the process calling <TT>exec</TT> can format the descriptor number as a character string and pass it as a command-line argument to the newly <TT>exec</TT>ed program. Alternately, a convention can be established that a certain descriptor is always set to the connected socket before calling <TT>exec</TT>. The latter is what <TT>inetd</TT> does, always setting descriptors 0, 1, and 2 to be the connected socket.</P>
<A NAME="ch04lev2sec4"></A>
<H4 class="docSection2Title"> Example: Obtaining the Address Family of a Socket</H4>
<P class="docText">The <TT>sockfd_to_family</TT> function shown in <A class="docLink" HREF="#ch04fig19">Figure 4.19</A> returns the address family of a socket.</P>

<H5 class="docExampleTitle"><A NAME="ch04fig19"></A>Figure 4.19 Return the address family of a socket.</H5>
<P class="docText"><span class="docEmphasis">lib/sockfd_to_family.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 int
 3 sockfd_to_family(int sockfd)
 4 {
 5     struct sockaddr_storage ss;
 6     socklen_t len;

 7     len = sizeof(ss);
 8     if (getsockname(sockfd, (SA *) &amp;ss, &amp;len) &lt; 0)
 9         return (-1);
10     return (ss.ss_family);
11 }
</PRE>

<A NAME="ch04lev3sec3"></A>
<H5 class="docSection3Title"> Allocate room for largest socket address structure</H5>
<p class="docText"><span class="docEmphasis"><TT>5</TT></span> Since we do not know what type of socket address structure to allocate, we use a <TT>sockaddr_storage</TT> value, since it can hold any socket address structure supported by the system.</p>

<A NAME="ch04lev3sec4"></A>
<H5 class="docSection3Title"> Call <TT>getsockname</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>7–10</TT></span> We call <TT>getsockname</TT> and return the address family.</p>
<P class="docText">Since the POSIX specification allows a call to <TT>getsockname</TT> on an unbound socket, this function should work for any open socket descriptor.</P>



<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch04lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch04lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
