<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="28.7 An ICMP Message Daemon"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch28lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch28lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch28lev1sec7"></A>
<H3 class="docSection1Title">28.7 An ICMP Message Daemon</H3>
<P class="docText">Receiving asynchronous ICMP errors on a UDP socket has been, and continues to be, a problem. ICMP errors are received by the kernel, but are rarely delivered to the application that needs to know about them. In the sockets API, we have seen that it requires connecting the UDP socket to one IP address to receive these errors (<A class="docLink" HREF="0131411551_ch08lev1sec11.html#ch08lev1sec11">Section 8.11</A>). The reason for this limitation is that the only error returned from <TT>recvfrom</TT> is an integer <TT>errno</TT> code, and if the application sends datagrams to multiple destinations and then calls <TT>recvfrom</TT>, this function cannot tell the application which datagram encountered an error.</P>
<P class="docText">In this section, we will provide a solution that does not require any kernel changes. We will provide an ICMP message daemon, <TT>icmpd</TT>, that creates a raw ICMPv4 socket and a raw ICMPv6 socket and receives all ICMP messages the kernel passes to these two raw sockets. It also creates a Unix domain stream socket, <TT>binds</TT> it to the pathname <TT>/tmp/icmpd</TT>, and listens for incoming client <TT>connects</TT> to this pathname. We will show this in <A class="docLink" HREF="#ch28fig26">Figure 28.26</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch28fig26"></A>Figure 28.26. <TT>icmpd</TT> daemon: initial sockets created.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="299" HEIGHT="255" src="FILES/28fig26.gif" ALT="graphics/28fig26.gif"></p>

</CENTER>
<P class="docText">A UDP application (which is a client to the daemon) first creates its UDP socket, the socket for which it wants to receive asynchronous errors. The application must <TT>bind</TT> an ephemeral port to this socket, for reasons we will discuss later. It then creates a Unix domain socket and <TT>connects</TT> to this daemon's well-known pathname. We will show this in <A class="docLink" HREF="#ch28fig27">Figure 28.27</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch28fig27"></A>Figure 28.27. Application creates its UDP socket and a Unix domain connection to the daemon.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="464" HEIGHT="198" src="FILES/28fig27.gif" ALT="graphics/28fig27.gif"></p>

</CENTER>
<P class="docText">The application next "passes" its UDP socket to the daemon across the Unix domain connection using <span class="docEmphasis">descriptor passing</span>, as we described in <A class="docLink" HREF="0131411551_ch15lev1sec7.html#ch15lev1sec7">Section 15.7</A>. This gives the daemon a copy of the socket so that it can call <TT>getsockname</TT> and obtain the port number bound to the socket. We will show this passing of the socket in <A class="docLink" HREF="#ch28fig28">Figure 28.28</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch28fig28"></A>Figure 28.28. Passing UDP socket to daemon across Unix domain connection.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="224" src="FILES/28fig28.gif" ALT="graphics/28fig28.gif"></p>

</CENTER>
<P class="docText">After the daemon obtains the port number bound to the UDP socket, it closes its copy of the socket, taking us back to the arrangement shown in <A class="docLink" HREF="#ch28fig27">Figure 28.27</A>.</P>
<BLOCKQUOTE><P><P class="docList">If the host supports credential passing (<A class="docLink" HREF="0131411551_ch15lev1sec8.html#ch15lev1sec8">Section 15.8</A>), the application could also send its credentials to the daemon. The daemon could then check whether this user should be allowed access to this facility.</P></P></BLOCKQUOTE>
<P class="docText">From this point on, any ICMP errors the daemon receives in response to UDP datagrams sent from the port bound to the application's UDP socket cause the daemon to send a message (which we will describe shortly) across the Unix domain socket to the application. The application must therefore use <TT>select</TT> or <TT>poll</TT>, awaiting data on either the UDP socket or the Unix domain socket.</P>
<P class="docText">We now look at the source code for an application using this daemon, and then the daemon itself. We start with <A class="docLink" HREF="#ch28fig29">Figure 28.29</A>, our header that is included by both the application and the daemon.</P>

<H5 class="docExampleTitle"><A NAME="ch28fig29"></A>Figure 28.29 <TT>unpicmpd.h</TT> header.</H5>
<P class="docText"><span class="docEmphasis">icmpd/unpicmpd.h</span></P>

<PRE>
 1 #ifndef__unpicmp_h
 2 #define__unpicmp_h

 3 #include   "unp.h"

 4 #define ICMPD_PATH     "/tmp/icmpd"     /* server's well-known pathname */

 5 struct icmpd_err {
 6     int      icmpd_errno;      /* EHOSTUNREACH, EMSGSIZE, ECONNREFUSED */
 7     char     icmpd_type;       /* actual ICMPv[46] type */
 8     char     icmpd_code;       /* actual ICMPv[46] code */
 9     socklen_t icmpd_len;       /* length of sockaddr{} that follows */
10     struct sockaddr_storage icmpd_dest;  /* sockaddr_storage handles any size */
11 };
12 #endif  /* __unpicmp_h */
</PRE>

<p class="docText"><span class="docEmphasis"><TT>4–11</TT></span> We define the server's well-known pathname and the <TT>icmpd_err</TT> structure that is passed from the server to the application whenever an ICMP message is received that should be passed to this application.</p>
<p class="docText"><span class="docEmphasis"><TT>6–8</TT></span> A problem is that the ICMPv4 message types differ numerically (and sometimes conceptually) from the ICMPv6 message types (<A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig15">Figures A.15</A> and <A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig16">A.16</A>). The actual ICMP <span class="docEmphasis">type</span> and <span class="docEmphasis">code</span> values are returned, but we also map these into an <TT>errno</TT> value (<TT>icmpd_errno</TT>), similar to the final columns in <A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig15">Figures A.15</A> and <A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig16">A.16</A>. The application can deal with this value instead of the protocol-dependent ICMPv4 or ICMPv6 values. <A class="docLink" HREF="#ch28fig30">Figure 28.30</A> shows the ICMP messages that are handled, plus their mapping into an <TT>errno</TT> value.</p>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch28fig30"></A>Figure 28.30. <TT>icmpd_errno</TT> mapping from ICMPv4 and ICMPv6 errors.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="104" src="FILES/28fig30.gif" ALT="graphics/28fig30.gif"></p>

</CENTER>
<P class="docText">The daemon returns five types of ICMP errors.</P>
<UL><LI><P class="docList">"port unreachable," indicating that no socket is bound to the destination port at the destination IP address.</P></LI><LI><P class="docList">"packet too big," which is used with path MTU discovery. Currently, there is no API defined to allow a UDP application to perform path MTU discovery. What often happens on kernels that support path MTU discovery for UDP is that the receipt of this ICMP error causes the kernel to record the new path MTU value in the kernel's routing table, but the UDP application that sent the datagram that got discarded is not notified. Instead, the application must time out and retransmit the datagram, in which case, the kernel will find the new (and smaller) MTU in its routing table, and the kernel will then fragment the datagram. Passing this error back to the application lets the application retransmit sooner, and perhaps lets the application reduce the size of the datagrams it sends.</P></LI><LI><P class="docList">The "time exceeded" error is normally seen with a code of 0, indicating that either the IPv4 TTL or IPv6 hop limit reached 0. This often indicates a routing loop, which might be a transient error.</P></LI><LI><P class="docList">ICMPv4 "source quenches," while deprecated by RFC 1812 [Baker 1995], may be sent by routers (or by misconfigured hosts acting as routers). They indicate that a packet has been discarded, and we therefore treat them like a "destination unreachable" message. Note that IPv6 does not have a "source quench" error.</P></LI><LI><P class="docList">All other destination unreachable messages indicate that a packet has been discarded.</P></LI></UL>
<p class="docText"><span class="docEmphasis"><TT>10</TT></span> The <TT>icmpd_dest</TT> member is a socket address structure containing the destination IP address and port of the datagram that generated the ICMP error. This member will be either a <TT>sockaddr_in</TT> structure for IPv4 or a <TT>sockaddr_in6</TT> structure for IPv6. If the application is sending datagrams to multiple destinations, it probably has one socket address structure per destination. By returning this information in a socket address structure, the application can compare it against its own structures to find the one that caused the error. It is a <TT>sockaddr_storage</TT> to allow storage of any <TT>sockaddr</TT> type the system supports.</p>
<A NAME="ch28lev2sec5"></A>
<H4 class="docSection2Title"> UDP Echo Client That Uses Our <TT>icmpd</TT> Daemon</H4>
<P class="docText">We now modify our UDP echo client, the <TT>dg_cli</TT> function, to use our <TT>icmpd</TT> daemon. <A class="docLink" HREF="#ch28fig31">Figure 28.31</A> shows the first half of the function.</P>
<p class="docText"><span class="docEmphasis"><TT>2–3</TT></span> The function arguments are the same as all previous versions of this function.</p>
<A NAME="ch28lev3sec45"></A>
<H5 class="docSection3Title"> <TT>bind</TT> wildcard address and ephemeral port</H5>
<p class="docText"><span class="docEmphasis"><TT>12</TT></span> We call our <TT>sock_bind_wild</TT> function to <TT>bind</TT> the wildcard IP address and an ephemeral port to the UDP socket. We do this so that the copy of this socket that we pass to the daemon has bound a port, as the daemon needs to know this port.</p>
<BLOCKQUOTE><P><P class="docList">The daemon could also do this <TT>bind</TT> if a local port has not already been bound to the socket that it receives, but this does not work in all environments. Certain SVR4 implementations, such as Solaris 2.5, in which sockets are not part of the kernel, have a bug when one process <TT>binds</TT> a port to a shared socket; the other process with a copy of that socket gets strange errors when it tries to use the socket. The easiest solution is to require the application to <TT>bind</TT> the local port before passing the socket to the daemon.</P></P></BLOCKQUOTE>

<A NAME="ch28lev3sec46"></A>
<H5 class="docSection3Title"> Establish Unix domain connection to daemon</H5>
<p class="docText"><span class="docEmphasis"><TT>13–16</TT></span> We create an <TT>AF_LOCAL</TT> socket and <TT>connect</TT> to the daemon's well-known pathname.</p>

<H5 class="docExampleTitle"><A NAME="ch28fig31"></A>Figure 28.31 First half of <TT>dg_cli</TT> application.</H5>
<P class="docText"><span class="docEmphasis">icmpd/dgcli01.c</span></P>

<PRE>
 1 #include     "unpicmpd.h"

 2 void
 3 dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
 4 {
 5     int     icmpfd, maxfdpl;
 6     char    sendline[MAXLINE], recvline[MAXLINE + 1];
 7     fd_set  rset;
 8     ssize_t n;
 9     struct timeval tv;
10     struct icmpd_err icmpd_err;
11     struct sockaddr_un sun;

12     Sock_bind_wild(sockfd, pservaddr-&gt;sa_family);

13     icmpfd = Socket(AF_LOCAL, SOCK_STREAM, 0);
14     sun.sun_family = AF_LOCAL;
15     strcpy(sun.sun_path, ICMPD_PATH);
16     Connect(icmpfd, (SA *) &amp;sun, sizeof(sun));
17     Write_fd(icmpfd, "1", 1, sockfd);
18     n = Read(icmpfd, recvline, 1);
19     if (n != 1 | | recvline[0] != '1')
20         err_quit("error creating icmp socket, n = %d, char = %c",
21                   n, recvline[0]);

22     FD_ZERO(&amp;rset);
23     maxfdpl = max(sockfd, icmpfd) + 1;
</PRE>


<A NAME="ch28lev3sec47"></A>
<H5 class="docSection3Title"> Send UDP socket to daemon, await daemon's reply</H5>
<p class="docText"><span class="docEmphasis"><TT>17–21</TT></span> We call our <TT>write_fd</TT> function from <A class="docLink" HREF="0131411551_ch15lev1sec7.html#ch15fig13">Figure 15.13</A> to send a copy of our UDP socket to the daemon. We also send a single byte of data, the character "1", because some implementations do not like passing a descriptor without any data. The daemon sends back a single byte of data, consisting of the character "1" to indicate success. Any other reply indicates an error.</p>
<p class="docText"><span class="docEmphasis"><TT>22–23</TT></span> We initialize a descriptor set and calculate the first argument for <TT>select</TT> (the maximum of the two descriptors, plus one).</p>
<P class="docText">The last half of our client is shown in <A class="docLink" HREF="#ch28fig32">Figure 28.32</A>. This is the loop that reads a line from standard input, sends the line to the server, reads back the server's reply, and writes the reply to standard output.</P>

<H5 class="docExampleTitle"><A NAME="ch28fig32"></A>Figure 28.32 Last half of <TT>dg_cli</TT> application.</H5>
<P class="docText"><span class="docEmphasis">icmpd/dgcli01.c</span></P>

<PRE>
24     while (Fgets(sendline, MAXLINE, fp) ! = NULL) {
25         Sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen);

26          tv.tv_sec = 5;
27          tv.tv_usec = 0;
28          FD_SET(sockfd, &amp;rset);
29          FD_SET(icmpfd, &amp;rset);
30          if ( (n = Select(maxfdpl, &amp;rset,  NULL, NULL, &amp;tv)) == 0) {
31              fprintf(stderr,   socket timeout\n);
32              continue;
33          }

34          if (FD_ISSET(sockfd,  &amp;rset)) {
35              n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);
36              recvline[n] = 0;     /* null terminate */
37              Fputs(recvline, stdout);
38          }

39          if (FD_ISSET(icmpfd, &amp;rset)) {
40              if ( (n = Read(icmpfd, &amp;icmpd_err, sizeof(icmpd_err))) == 0)
41                   err_quit ("ICMP daemon terminated");
42              else if (n ! = sizeof(icmpd_err))
43                   err_quit("n = %d, expected %d", n, sizeof(icmpd_err));
44              printf("ICMP error: dest = %s, %s, type = %d, code = %d\n",
45                     Sock_ntop(&amp;icmpd_err.icmpd_dest, icmpd_err.icmpd_len),
46                     strerror(icmpd_err.icmpd_errno),
47                     icmpd_err.icmpd_type, icmpd_err.icmpd_code);
48          }
49     }
50 }
</PRE>


<A NAME="ch28lev3sec48"></A>
<H5 class="docSection3Title"> Call <TT>select</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>26–33</TT></span> Since we are calling <TT>select</TT>, we can easily place a timeout on our wait for the echo server's reply. We set this to five seconds, enable both descriptors for readability, and call <TT>select</TT>. If a timeout occurs, we print a message and go back to the top of the loop.</p>

<A NAME="ch28lev3sec49"></A>
<H5 class="docSection3Title"> Print server's reply</H5>
<p class="docText"><span class="docEmphasis"><TT>34–38</TT></span> If a datagram is returned by the server, we print it to standard output.</p>

<A NAME="ch28lev3sec50"></A>
<H5 class="docSection3Title"> Handle ICMP error</H5>
<p class="docText"><span class="docEmphasis"><TT>39–48</TT></span> If our Unix domain connection to the <TT>icmpd</TT> daemon is readable, we try to read an <TT>icmpd_err</TT> structure. If this succeeds, we print the relevant information the daemon returns.</p>
<BLOCKQUOTE><P><P class="docList"><TT>strerror</TT> is an example of a simple, almost trivial, function that should be more portable than it is. First, ANSI C says nothing about an error return from the function. The Solaris man page says that the function returns a null pointer if the argument is out of range. But this means code like</P><pre>

</pre><pre>
printf("%s", strerror(arg));
</pre><pre>
</pre><P class="docList">is incorrect because <TT>strerror</TT> can return a null pointer. But the FreeBSD implementation, along with all the source code implementations the authors could find, handle an invalid argument by returning a pointer to a string such as "Unknown error." This makes sense and means the code above is fine. But POSIX changes this and says that because no return value is reserved to indicate an error, if the argument is out of range, the function sets <TT>errno</TT> to <TT>EINVAL</TT>. (POSIX does not say anything about the returned pointer in the case of an error.) This means that completely conforming code must set <TT>errno</TT> to 0, call <TT>strerror</TT>, test whether <TT>errno</TT> equals <TT>EINVAL</TT>, and print some other message in case of an error.</P></P></BLOCKQUOTE>


<A NAME="ch28lev2sec6"></A>
<H4 class="docSection2Title"> UDP Echo Client Examples</H4>
<P class="docText">We now show some examples of this client before looking at the daemon source code. We first send datagrams to an IP address that is not connected to the Internet.</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">udpcli01 192.0.2.5 echo</span>
<span class="docEmphStrong">hi there</span>
socket timeout
<span class="docEmphStrong">and hello</span>
socket timeout
</pre><pre>
</pre>
<P class="docText">We assume <TT>icmpd</TT> is running and expect ICMP "host unreachable" errors to be returned by some router, but none are received. Instead, our application times out. We show this to reiterate that a timeout is still required and the generation of ICMP messages such as "host unreachable" may not occur.</P>
<P class="docText">Our next example sends a datagram to the standard echo server on a host that is not running the server. We receive an ICMPv4 "port unreachable" as expected.</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">udpcli01 aix-4 echo</span>
<span class="docEmphStrong">hello, world</span>
ICMP error: dest = 192.168.42.2:7, Connection refused, type = 3, code = 3
</pre><pre>
</pre>
<P class="docText">We try again with IPv6 and receive an ICMPv6 "port unreachable" as expected.</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">udpcli01 aix-6 echo</span>
<span class="docEmphStrong">hello, world</span>
ICMP error: dest = [3ffe:b80:1f8d:2:204:acff:fe17:bf38] :7,
                                   Connection refused, type = 1, code = 4
</pre><pre>
</pre>
<P class="docText">We have wrapped the long line for readability.</P>

<A NAME="ch28lev2sec7"></A>
<H4 class="docSection2Title"> <TT>icmpd</TT> Daemon</H4>
<P class="docText">We start the description of our <TT>icmpd</TT> daemon with the <TT>icmpd.h</TT> header, shown in <A class="docLink" HREF="#ch28fig33">Figure 28.33</A>.</P>
<A NAME="ch28lev3sec51"></A>
<H5 class="docSection3Title"> <TT>client</TT> array</H5>
<p class="docText"><span class="docEmphasis"><TT>2–17</TT></span> Since the daemon can handle any number of clients, we use an array of <TT>client</TT> structures to keep the information about each client. This is similar to the data structures we used in <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06lev1sec8">Section 6.8</A>. In addition to the descriptor for the Unix domain connection to the client, we also store the address family of the client's UDP socket <TT>AF_INET</TT> or <TT>AF_INET6</TT>) and the port number bound to this socket. We also declare the function prototypes and the globals shared by these functions.</p>

<H5 class="docExampleTitle"><A NAME="ch28fig33"></A>Figure 28.33 <TT>icmpd.h</TT> header for <TT>icmpd</TT> daemon.</H5>
<P class="docText"><span class="docEmphasis">icmpd/icmpd.h</span></P>

<PRE>
 1 #include     "unpicmpd.h"

 2 struct client {
 3     int     connfd;             /* Unix domain stream socket to client */
 4     int     family;             /* AF_INET or AF_INET6 */
 5     int     lport;              /* local port bound to client's UDP socket */
 6     /* network byte ordered */
 7 } client [FD_SETSIZE];

 8                          /* globals */
 9 int    fd4, fd6, listenfd, maxi, maxfd, nready;
10 fd_set rset, allset;
11 struct sockaddr_un cliaddr;

12                 /* function prototypes */
13 int     readable_conn (int);
14 int     readable_listen (void);
15 int     readable_v4 (void);
16 int     readable_v6 (void);
</PRE>


<H5 class="docExampleTitle"><A NAME="ch28fig34"></A>Figure 28.34 First half of <TT>main</TT> function: creates sockets.</H5>
<P class="docText"><span class="docEmphasis">icmpd/icmpd.c</span></P>

<PRE>
 1 #include     "icmpd.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     i, sockfd;
 6     struct sockaddr_un sun;

 7     if (argc != 1)
 8         err_quit ("usage: icmpd");

 9     maxi = -1;                   /* index into client [] array */
10     for (i = 0; i &lt; FD_SETSIZE; i++)
11         client [i] .connfd = -1;   /* -1 indicates available entry */
12     FD_ZERO (&amp;allset);

13     fd4 = Socket (AF_INET, SOCK_RAW, IPPROTO_ICMP);
14     FD_SET (fd4, &amp;allset);
15     maxfd = fd4;

16 #ifdef IPV6
17     fd6 = Socket (AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
18     FD_SET (fd6, &amp;allset);
19     maxfd = max (maxfd, fd6);
20 #endif

21     listenfd = Socket (AF_UNIX, SOCK_STREAM, 0);
22     sun.sun_family = AF_LOCAL;
23     strcpy (sun.sun_path, ICMPD_PATH);
24     unlink (ICMPD_PATH);
25     Bind (listenfd, (SA *) &amp;sun, sizeof (sun));
26     Listen (listenfd, LISTENQ);
27     FD_SET (listenfd, &amp;allset);
28     maxfd = max (maxfd, listenfd);
</PRE>

<P class="docText"><A class="docLink" HREF="#ch28fig34">Figure 28.34</A> shows the first half of the <TT>main</TT> function.</P>

<A NAME="ch28lev3sec52"></A>
<H5 class="docSection3Title"> Initialize <TT>client</TT> array</H5>
<p class="docText"><span class="docEmphasis"><TT>9–10</TT></span> The <TT>client</TT> array is initialized by setting the connected socket member to –1.</p>

<A NAME="ch28lev3sec53"></A>
<H5 class="docSection3Title"> Create sockets</H5>
<p class="docText"><span class="docEmphasis"><TT>12–28</TT></span> Three sockets are created: a raw ICMPv4 socket, a raw ICMPv6 socket, and a Unix domain stream socket. We <TT>unlink</TT> any previously existing instance of the Unix domain socket, <TT>bind</TT> its well-known pathname to the socket, and call <TT>listen</TT>. This is the socket to which clients <TT>connect</TT>. The maximum descriptor is also calculated for <TT>select</TT> and a socket address structure is allocated for calls to <TT>accept</TT>.</p>
<P class="docText"><A class="docLink" HREF="#ch28fig35">Figure 28.35</A> shows the second half of the <TT>main</TT> function, which is an infinite loop that calls <TT>select</TT>, waiting for any of the daemon's descriptors to be readable.</P>

<H5 class="docExampleTitle"><A NAME="ch28fig35"></A>Figure 28.35 Second half of <TT>main</TT> function: handles readable descriptor.</H5>
<P class="docText"><span class="docEmphasis">icmpd/icmpd.c</span></P>

<PRE>
29      for ( ; ; ) {
30          rset = allset;
31          nready = Select (maxfd + 1, &amp;rset, NULL, NULL, NULL);

32          if (FD_ISSET (listenfd, &amp;rset))
33              if (readable_listen () &lt;= 0)
34                  continue;

35          if (FD_ISSET (fd4, &amp;rset))
36              if (readable_v4 () &lt;= 0)
37                  continue;

38 #ifdef IPV6
39        if (FD_ISSET (fd6, &amp;rset))
40              if (readable_v6 () &lt;= 0)
41                  continue;
42 #endif

43          for (i = 0; i &lt;= maxi; i++) { /* check all clients for data */
44              if ( (sockfd = client [i] .connfd) &lt; 0)
45                  continue;
46          if (FD_ISSET (sockfd, &amp;rset))
47              if (readable_conn (i) &lt;= 0)
48                  break;     /* no more readable descriptors */
49          }
50     }
51     exit (0);
52 }
</PRE>


<A NAME="ch28lev3sec54"></A>
<H5 class="docSection3Title"> Check listening Unix domain socket</H5>
<p class="docText"><span class="docEmphasis"><TT>32–34</TT></span> The listening Unix domain socket is tested first and if ready, <TT>readable_listen</TT> is called. The variable <TT>nready</TT>, the number of descriptors that <TT>select</TT> returns as readable, is a global variable. Each of our <TT>readable</TT>_<span class="docEmphasis">XXX</span> function decrements this variable and returns its new value as the return value of the function. When this value reaches 0, all the readable descriptors have been processed and <TT>select</TT> is called again.</p>

<A NAME="ch28lev3sec55"></A>
<H5 class="docSection3Title"> Check raw ICMP sockets</H5>
<p class="docText"><span class="docEmphasis"><TT>35–42</TT></span> The raw ICMPv4 socket is tested, and then the raw ICMPv6 socket.</p>

<A NAME="ch28lev3sec56"></A>
<H5 class="docSection3Title"> Check connected Unix domain sockets</H5>
<p class="docText"><span class="docEmphasis"><TT>43–49</TT></span> We next check whether any of the connected Unix domain sockets are readable. Readability on any of these sockets means that the client has sent a descriptor, or that the client has terminated.</p>
<P class="docText"><A class="docLink" HREF="#ch28fig36">Figure 28.36</A> shows the <TT>readable_listen</TT> function, called when the daemon's listening socket is readable. This indicates a new client connection.</P>

<H5 class="docExampleTitle"><A NAME="ch28fig36"></A>Figure 28.36 Handle new client connections.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_listen.c</span></P>

<PRE>
 1 #include   "icmpd.h"

 2 int
 3 readable_listen (void)
 4 {
 5     int     i, connfd;
 6     socklen_t clilen;

 7     clilen = sizeof (cliaddr);
 8     connfd = Accept (listenfd, (SA *) &amp;cliaddr, &amp;clilen);

 9         /* find first available client [] structure */
10     for (i = 0; i &lt; FD_SETSIZE; i++)
11         if (client [i] .connfd &lt; 0) {
12             client [i] .connfd = connfd; /* save descriptor */
13             break;
14          }
15     if (i == FD_SETSIZE) {
16         close (connfd);            /* can't handle new client, */
17         return (--nready);         /* rudely close the new connection */
18     }
19     printf ("new connection, i = %d, connfd = %d\n", i, connfd);

20     FD_SET (connfd, &amp;allset);  /* add new descriptor to set */
21     if (connfd &gt; maxfd)
22         maxfd = connfd;            /* for select () */
23     if (i &gt; maxi)
24         maxi = i;                  /* max index in client [] array */

25     return (--nready);
26 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>7–25</TT></span> The connection is accepted and the first available entry in the <TT>client</TT> array is used. The code in this function was copied from the beginning of <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig22">Figure 6.22</A>. If an entry couldn't be found in the client array, we simply closed the new client connection and remained to serve our current clients.</p>
<P class="docText">When a connected socket is readable, our <TT>readable_conn</TT> function is called (<A class="docLink" HREF="#ch28fig37">Figure 28.37</A>). Its argument is the index of this client in the <TT>client</TT> array.</P>

<A NAME="ch28lev3sec57"></A>
<H5 class="docSection3Title"> Read client data and possibly a descriptor</H5>
<p class="docText"><span class="docEmphasis"><TT>13–18</TT></span> We call our <TT>read_fd</TT> function from <A class="docLink" HREF="0131411551_ch15lev1sec7.html#ch15fig11">Figure 15.11</A> to read the data and possibly a descriptor. If the return value is 0, the client has closed its end of the connection, possibly by terminating.</p>

<H5 class="docExampleTitle"><A NAME="ch28fig37"></A>Figure 28.37 Read data and possible descriptor from client.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_conn.c</span></P>

<PRE>
 1 #include     "icmpd.h"

 2 int
 3 readable_conn(int i)
 4 {
 5     int     unixfd, recvfd;
 6     char    c;
 7     ssize_t n;
 8     socklen_t len;
 9     struct sockaddr_storage ss;

10     unixfd = client [i] .connfd;
11     recvfd = -1;
12     if ( (n = Read_fd (unixfd, &amp;c, 1, &amp;recvfd)) == 0) {
13         err_msg ("client %d terminated, recvfd = %d", i, recvfd);
14         goto clientdone;         /* client probably terminated */
15     }

16         /* data from client; should be descriptor */
17     if (recvfd &lt; 0) {
18         err_msg ("read_fd did not return descriptor");
19         goto clienterr;
20     }
</PRE>

<BLOCKQUOTE><P><P class="docList">One design decision was whether to use a Unix domain stream socket between the application and the daemon, or a Unix domain datagram socket. The application's UDP socket can be passed over either type of Unix domain socket. The reason why we used a stream socket was to detect when a client terminated. When a client terminates, all its descriptors are automatically closed, including its Unix domain connection to the daemon, which tells the daemon to remove this client from the <TT>client</TT> array. Had we used a datagram socket, we would not know when the client terminated.</P></P></BLOCKQUOTE>
<p class="docText"><span class="docEmphasis"><TT>16–20</TT></span> If the client has not closed the connection, then we expect a descriptor.</p>
<P class="docText">The second half of our <TT>readable_conn</TT> function is shown in <A class="docLink" HREF="#ch28fig38">Figure 28.38</A>.</P>

<A NAME="ch28lev3sec58"></A>
<H5 class="docSection3Title"> Get port number bound to UDP socket</H5>
<p class="docText"><span class="docEmphasis"><TT>21–25</TT></span> <TT>getsockname</TT> is called so the daemon can obtain the port number bound to the socket. Since we do not know what size buffer to allocate for the socket address structure, we use a <TT>sockaddr_storage</TT> structure, which is large enough and appropriately aligned to store any socket address structure the system supports.</p>
<p class="docText"><span class="docEmphasis"><TT>26–33</TT></span> The address family of the socket is stored in the <TT>client</TT> structure, along with the port number. If the port number is 0, we call our <TT>sock_bind_wild</TT> function to <TT>bind</TT> the wildcard address and an ephemeral port to the socket, but as we mentioned earlier, this does not work on some SVR4 implementations.</p>

<H5 class="docExampleTitle"><A NAME="ch28fig38"></A>Figure 28.38 Get port number that client has bound to its UDP socket.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_conn.c</span></P>

<PRE>
21     len = sizeof (ss);
22     if (getsockname (recvfd, (SA *) &amp;ss, &amp;len) &lt; 0) {
23          err_ret ("getsockname error");
24          goto clienterr;
25     }

26     client[i].family = ss.ss_family;
27     if ((client[i].lport = sock_get_port ((SA *) &amp;ss, len)) == 0) {
28         client[i].lport = sock_bind_wild (recvfd, client[i].family);
29          if (client[i].lport &lt;= 0) {
30             err_ret ("error binding ephemeral port");
31             goto clienterr;
32          }
33     }
34     Write (unixfd, "1", 1);        /* tell client all OK */
35     Close (recvfd);                /* all done with client's UDP socket */
36     return  (--nready);

37   clienterr:
38     Write (unixfd, "0", 1);        /* tell client error occurred */
39     clientdone:
40       Close (unixfd);
41       if (recvfd &gt;= 0)
42           Close (recvfd);
43       FD_CLR (unixfd, &amp;allset);
44       client[i].connfd = -1;
45       return (--nready);
46 }
</PRE>


<A NAME="ch28lev3sec59"></A>
<H5 class="docSection3Title"> Indicate success to client</H5>
<p class="docText"><span class="docEmphasis"><TT>34</TT></span> One byte consisting of the character "1" is sent back to the client.</p>

<A NAME="ch28lev3sec60"></A>
<H5 class="docSection3Title"> <TT>close</TT> client's UDP socket</H5>
<p class="docText"><span class="docEmphasis"><TT>35</TT></span> We are finished with the client's UDP socket and <TT>close</TT> it. This descriptor was passed to us by the client and is therefore a copy; hence, the UDP socket is still open in the client.</p>

<A NAME="ch28lev3sec61"></A>
<H5 class="docSection3Title"> Handle errors and termination of client</H5>
<p class="docText"><span class="docEmphasis"><TT>37–45</TT></span> If an error occurs, a byte of "0" is written back to the client. When the client terminates, our end of the Unix domain connection is closed, and the descriptor is removed from the set of descriptors for <TT>select</TT>. The <TT>connfd</TT> member of the <TT>client</TT> structure is set to –1, indicating it is available.</p>
<P class="docText">Our <TT>readable_v4</TT> function is called when the raw ICMPv4 socket is readable. We show the first half in <A class="docLink" HREF="#ch28fig39">Figure 28.39</A>. This code is similar to the ICMPv4 code shown earlier in <A class="docLink" HREF="0131411551_ch28lev1sec5.html#ch28fig08">Figures 28.8</A> and <A class="docLink" HREF="0131411551_ch28lev1sec6.html#ch28fig20">28.20</A></P>

<H5 class="docExampleTitle"><A NAME="ch28fig39"></A>Figure 28.39 Handle received ICMPv4 datagram, first half.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_v4.c</span></P>

<PRE>
 1 #include     "icmpd.h"
 2 #include     &lt;netinet/in_systm.h&gt;
 3 #include     &lt;netinet/ip.h&gt;
 4 #include     &lt;netinet/ip_icmp.h&gt;
 5 #include     &lt;netinet/udp.h&gt;

 6 int
 7 readable_v4 (void)
 8 {
 9     int      i, hlen1, hlen2, icmplen, sport;
10     char     buf[MAXLINE];
11     char     srcstr [INET_ADDRSTRLEN], dststr[INET_ADDRSTRLEN];
12     ssize_t  n;
13     socklen _ t len;
14     struct  ip *ip, *hip;
15     struct  icmp *icmp;
16     struct  udphdr *udp;
17     struct  sockaddr_in from, dest;
18     struct  icmpd_err icmpd_err;

19     len =  sizeof (from);
20     n =  Recvfrom(fd4, buf, MAXLINE, 0, (SA *) &amp;from, &amp;len);

21     printf("%d bytes ICMPv4 from %s:", n, Sock_ntop_host ((SA *) &amp;from, len));

22     ip = (struct ip *) buf;     /* start of IP header */
23     hlen1 = ip-&gt;ip_hl &lt;&lt; 2;     /* length of IP header */

24     icmp = (struct icmp *) (buf + hlen1);     /* start of ICMP header */
25     if ( (icmplen = n - hlen1) &lt; 8)
26          err_quit("icmplen (%d) &lt; 8", icmplen);

27     printf(" type = %d, code = %d\n", icmp-&gt;icmp_type, icmp-&gt;icmp_code);
</PRE>

<P class="docText">This function prints some information about every received ICMPv4 message. This was done for debugging when developing this daemon and could be output based on a command-line argument.</P>
<P class="docText"><A class="docLink" HREF="#ch28fig40">Figure 28.40</A> shows the last half of our <TT>readable_v4</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch28fig40"></A>Figure 28.40 Handle received ICMPv4 datagram, second half.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_v4.c</span></P>

<PRE>
28     if (icmp-&gt;icmp_type == ICMP_UNREACH ||
29         icmp-&gt;icmp_type == ICMP_TIMXCEED ||
30         icmp-&gt;icmp_type == ICMP_SOURCEQUENCH) {
31         if (icmplen &lt; 8 + 20 + 8)
32             err_quit("icmplen (%d) &lt; 8 + 20 + 8", icmplen);

33         hip = (struct ip *) (buf + hlen1 + 8);
34         hlen2 = hip-&gt;ip_hl &lt;&lt; 2;
35         printf("\tsrcip = %s, dstip = %s, proto = %d\n",
36                Inet_ntop(AF_INET, &amp;hip-&gt;ip_src, srcstr, sizeof(srcstr)),
37                Inet_ntop(AF_INET, &amp;hip-&gt;ip_dst, dststr, sizeof(dststr)),
38                hip-&gt;ip_p);
39         if (hip-&gt;ip_p == IPPROTO_UDP) {
40             udp = (struct udphdr *) (buf + hlen1 + 8 + hlen2);
41             sport = udp-&gt;uh_sport;

42                 /* find client's Unix domain socket, send headers */
43             for (i = 0; i &lt;= maxi; i++) {
44                 if (client[i].connfd &gt;= 0 &amp;&amp;
45                     client[i].family == AF_INET &amp;&amp;
46                     client[i].lport == sport) {

47                     bzero(&amp;dest, sizeof(dest));
48                     dest.sin_family = AF_INET;
49 #ifdef  HAVE_SOCKADDR_SA_LEN
50                     dest.sin_len = sizeof(dest);
51 #endif
52                     memcpy(&amp;dest.sin_addr, &amp;hip-&gt;ip_dst,
53                              sizeof(struct in_addr));
54                     dest.sin_port = udp-&gt;uh_dport;

55                     icmpd_err.icmpd_type = icmp-&gt;icmp_type;
56                     icmpd_err.icmpd_code = icmp-&gt;icmp_code;
57                     icmpd_err.icmpd_len = sizeof(struct sockaddr_in);
58                     memcpy(&amp;icmpd_err.icmpd_dest, &amp;dest, sizeof(dest));

59                         /* convert type &amp; code to reasonable errno value */
60                    icmpd_err.icmpd_errno = EHOSTUNREACH;     /* default */
61                    if (icmp-&gt;icmp_type == ICMP_UNREACH) {
62                        if (icmp-&gt;icmp_code == ICMP_UNREACH_PORT)
63                            icmpd_err.icmpd_errno = ECONNREFUSED;
64                        else if (icmp-&gt;icmp_code == ICMP_UNREACH_NEEDFRAG)
65                            icmpd_err.icmpd_errno = EMSGSIZE;
66                    }
67                    Write(client[i].connfd, &amp;icmpd_err, sizeof(icmpd_err));
68                }
69             }
70         }
71     }
72     return (--nready);
73 }
</PRE>


<A NAME="ch28lev3sec62"></A>
<H5 class="docSection3Title"> Check message type, notify application</H5>
<p class="docText"><span class="docEmphasis"><TT>29–31</TT></span> The only ICMPv4 messages that we pass to the application are "destination unreachable," "time exceeded," and "source quench" (<A class="docLink" HREF="#ch28fig30">Figure 28.30</A>).</p>

<A NAME="ch28lev3sec63"></A>
<H5 class="docSection3Title"> Check for UDP error, find client</H5>
<p class="docText"><span class="docEmphasis"><TT>34–42</TT></span> <TT>hip</TT> points to the IP header that is returned following the ICMP header. This is the IP header of the datagram that elicited the ICMP error. We verify that this IP datagram is a UDP datagram and then fetch the source UDP port number from the UDP header following the IP header.</p>
<p class="docText"><span class="docEmphasis"><TT>43–55</TT></span> A search is made of all the <TT>client</TT> structures for a matching address family and port. If a match is found, an IPv4 socket address structure is built containing the destination IP address and port from the UDP datagram that caused the error.</p>

<A NAME="ch28lev3sec64"></A>
<H5 class="docSection3Title"> Build <TT>icmpd_err</TT> structure</H5>
<p class="docText"><span class="docEmphasis"><TT>56–70</TT></span> An <TT>icmpd_err</TT> structure is built that is sent to the client across the Unix domain connection to this client. The ICMPv4 message type and code are first mapped into an <TT>errno</TT> value, as described with <A class="docLink" HREF="#ch28fig30">Figure 28.30</A>.</p>

<H5 class="docExampleTitle"><A NAME="ch28fig41"></A>Figure 28.41 Handle received ICMPv6 datagram, first half.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_v6.c</span></P>

<PRE>
 1 #include     "icmpd.h"
 2 #include     &lt;netinet/in_systm.h&gt;
 3 #include     &lt;netinet/ip.h&gt;
 4 #include     &lt;netinet/ip_icmp.h&gt;
 5 #include     &lt;netinet/udp.h&gt;

 6 #ifdef     IPV6
 7 #include     &lt;netinet/ip6.h&gt;
 8 #include     &lt;netinet/icmp6.h&gt;
 9 #endif

10 int
11 readable_v6 (void)
12 {
13 #ifdef       IPV6
14     int      i, hlen2, icmp6len, sport;
15     char     buf [MAXLINE];
16     char     srcstr [INET6_ADDRSTRLEN], dststr [INET6_ADDRSTRLEN];
17     ssize_t n;
18     socklen_t len;
19     struct ip6_hdr *ip6, *hip6;
20     struct icmp6_hdr *icmp6;
21     struct udphdr *udp;
22     struct sockaddr_in6 from, dest;
23     struct icmpd_err icmp_err;

24     len = sizeof (from);
25     n = Recvfrom (fd6, buf, MAXLINE, 0, (SA *) &amp;from, &amp;len);

26     printf ("%d bytes ICMPv6 from %s:", n, Sock_ntop_host ((SA *) &amp;from, len));

27     icmp6 = (struct icmp6_hdr *) buf;     /* start of ICMPv6 header */
28     if ( (icmp6len = n) &lt; 8)
29         err_quit ("icmp6len (%d) &lt; 8", icmp6len);

30     printf ("type = %d, code = %d\n", icmp6-&gt;icmp6_type, icmp6-&gt;icmp6_code);
</PRE>

<P class="docText">ICMPv6 errors are handled by our <TT>readable_v6</TT> function, the first half of which is shown in <A class="docLink" HREF="#ch28fig41">Figure 28.41</A>. The ICMPv6 handling is similar to the code in <A class="docLink" HREF="0131411551_ch28lev1sec5.html#ch28fig12">Figures 28.12</A> and <A class="docLink" HREF="0131411551_ch28lev1sec6.html#ch28fig24">28.24</A>.</P>
<P class="docText">The second half of our <TT>readable_v6</TT> function is shown in <A class="docLink" HREF="#ch28fig42">Figure 28.42</A> (p. 785). This code is similar to <A class="docLink" HREF="#ch28fig40">Figure 28.40</A>: It checks the type of ICMP error, checks that the datagram that caused the error was a UDP datagram, and then builds the <TT>icmpd_err</TT> structure, which is sent to the client.</P>

<H5 class="docExampleTitle"><A NAME="ch28fig42"></A>Figure 28.42 Handle received ICMPv6 datagram, second half.</H5>
<P class="docText"><span class="docEmphasis">icmpd/readable_v6.c</span></P>

<PRE>
31     if (icmp6-&gt;icmp6_type == ICMP6_DST_UNREACH ||
32         icmp6-&gt;icmp6_type == ICMP6_PACKET_TOO_BIG ||
33         icmp6-&gt;icmp6_type == ICMP6_TIME_EXCEEDED) {
34         if (icmp6len &lt; 8 + 8)
35             err_quit (" icmp6len (%d) &lt; 8 + 8", icmp6len);

36         hip6 = (struct ip_hdr *) (buf + 8);
37         hlen2 = sizeof (struct ip6_hdr);
38         printf ("\tsrcip = %s, dstip = %s, next hdr = %d\n",
39                 Inet_ntop (AF_INET6, &amp;hip6-&gt;ip6_src,  srcstr, sizeof (srcstr)),
40                 Inet_ntop (AF_INET6, &amp;hip6-&gt;ip6_dst, dststr, sizeof (dststr)),
41                 hip6-&gt;ip6_nxt);
42         if (hip6-&gt;ip6_nxt == IPPROTO_UDP) {
43             udp = (struct udphdr *) (buf + 8 + hlen2);
44             sport = udp-&gt;uh_sport;

45                 /* find client's Unix domain socket, send headers */
46             for (i = 0; i &lt;= maxi; i++) {
47                 if (client [i].connfd &gt;= 0 &amp;&amp;
48                     client [i].family == AF_INET6 &amp;&amp;
49                     client [i].lport == sport) {

50                     bzero (&amp;dest, sizeof (dest));
51                     dest.sin6_family = AF_INET6;
52 #ifdef HAVE_SOCKADDR_SA_LEN
53                     dest.sin6_len = sizeof (dest);
54 #endif
55                     memcpy (&amp;dest.sin6_addr, &amp;hip6-&gt;ip6_dst,
56                             sizeof (struct in6_addr));
57                     dest.sin6_port = udp-&gt;uh_dport;

58                     icmpd_err.icmp_type = icmp6-&gt;icmp6_type;
59                     icmpd_err.icmpd_code = icmp6-&gt;icmp6_code;
60                     icmpd_err.icmpd_len = sizeof (struct sockaddr_in6);
61                     memcpy (&amp;icmpd_err.icmpd_dest, &amp;dest, sizeof (dest));

62                         /* convert type &amp; code to reasonable errno value */
63                     icmpd_err.icmpd_errno = EHOSTUNREACH; /* default */
64                     if (icmp6-&gt;icmp6_type == ICMP6_DST_UNREACH &amp;&amp;
65                         icmp6-&gt;icmp6_code == ICMP6_DST_UNREACH_NOPORT)
66                         icmpd_err.icmpd_errno = ECONNREFUSED;
67                     if (icmp6-&gt;icmp6_type == ICMP6_PACKET_TOO_BIG)
68                         icmpd_err.icmpd_errno = EMSGSIZE;
69                     Write (client [i].connfd, &amp;icmpd_err, sizeof (icmpd_err));
70                }
71            }
72        }
73    }
74    return (--nready);
75 #endif
76 }
</PRE>




<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch28lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch28lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
