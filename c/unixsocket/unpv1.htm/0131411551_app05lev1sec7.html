<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Chapter 7"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_app05lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_app05lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app05lev1sec7"></A>
<H3 class="docSection1Title"> Chapter 7</H3>
<P><TABLE BORDER="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a02"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q02">7.2</A></B></TD><TD><P class="docText"><A class="docLink" HREF="#app05fig05">Figure E.5</A> shows one solution to this exercise. We have removed the printing of the data string returned by the server as that value is not needed.</P>
<H5 class="docExampleTitle"><A NAME="app05fig05"></A>Figure E.5 Print socket receive buffer size and MSS before and after connection establishment.</H5>
<P class="docText"><span class="docEmphasis">sockopt/rcvbuf.c</span></P>
<PRE>
 1 #include    "unp.h"
 2 #include    &lt;netinet/tcp.h&gt;      /* for TCP_MAXSEG */

 3 int
 4 main(int argc, char **argv)
 5 {
 6     int     sockfd, rcvbuf, mss;
 7     socklen_t len;
 8     struct sockaddr_in servaddr;

 9     if (argc != 2)
10         err_quit("usage: rcvbuf &lt;IPaddress&gt;");

11     sockfd = Socket(AF_INET, SOCK_STREAM, 0);

12     len = sizeof(rcvbuf);
13     Getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, &amp;len);
14     len = sizeof(mss);
15     Getsockopt(sockfd, IPPROTO_TCP, TCP_MAXSEG, &amp;mss, &amp;len);
16     printf("defaults: SO_RCVBUF = %d, MSS = %d\n", rcvbuf, mss);

17     bzero(&amp;servaddr, sizeof(servaddr));
18     servaddr.sin_family = AF_INET;
19     servaddr.sin_port = htons(13);  /* daytime server */
20     Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr);

21     Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));

22     len = sizeof(rcvbuf);
23     Getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, &amp;len);
24     len = sizeof(mss);
25     Getsockopt(sockfd, IPPROTO_TCP, TCP_MAXSEG, &amp;mss, &amp;len);
26     printf("after connect: SO_RCVBUF = %d, MSS = %d\n", rcvbuf, mss);

27     exit(0);
28 }
</PRE>
<P class="docText">First, there is no "correct" output from this program. The results vary from system to system. Some systems (notably Solaris 2.5.1 and earlier) always return 0 for the socket buffer sizes, preventing us from seeing what happens with this value across the connection.</P><P class="docText">With regard to the MSS, the value printed before <TT>connect</TT> is the implementation default (often 536 or 512), while the value printed after <TT>connect</TT> depends on a possible MSS option from the peer. On a local Ethernet, for example, the value after <TT>connect</TT> could be 1,460. After a <TT>connect</TT> to a server on a remote network, however, the MSS may be similar to the default, unless your system supports path MTU discovery. If possible, run a tool like <TT>tcpdump</TT> (Section C.5) while the program is running to see the actual MSS option on the SYN segment from the peer.</P><P class="docText">With regard to the socket receive buffer size, many implementations round this value up after the connection is established to a multiple of the MSS. Another way to see the socket receive buffer size after the connection is established is to watch the packets using a tool like <TT>tcpdump</TT> and look at TCP's advertised window.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a03"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q03">7.3</A></B></TD><TD><P class="docText">Allocate a <TT>linger</TT> structure named <TT>ling</TT> and initialize it as follows:</P><pre>
</pre><pre>
str_cli(stdin, sockfd);

ling.l_onoff = 1;
ling.l_linger = 0;
Setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &amp;ling, sizeof(ling));

exit(0);
</pre><pre>
</pre><P class="docText">This should cause the client TCP to terminate the connection with an RST instead of the normal four-segment exchange. The server child's call to <TT>readline</TT> returns an error of <TT>ECONNRESET</TT> and the message printed is as follows:</P><pre>
</pre><pre>
readline error: Connection reset by peer
</pre><pre>
</pre><P class="docText">The client socket should not go through the TIME_WAIT state, even though the client did the active close.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a04"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q04">7.4</A></B></TD><TD><P class="docText">The first client calls <TT>setsockopt</TT>, <TT>bind</TT>, and <TT>connect</TT>. But between the first client's calls to <TT>bind</TT> and <TT>connect</TT>, if the second client calls <TT>bind</TT>, <TT>EADDRINUSE</TT> is returned. But as soon as the first client connects to the peer, the second client's <TT>bind</TT> will work, since the first client's socket is then connected. The only way to handle this is for the second client to try calling <TT>bind</TT> multiple times if <TT>EADDRINUSE</TT> is returned, and not give up the first time the error is returned.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a05"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q05">7.5</A></B></TD><TD><P class="docText">We run the program on a host with multicast support (MacOS X 10.2.6).</P><pre>
</pre><pre>
macosx % <span class="docEmphStrong">sock -s 9999 &amp;</span>                    <span class="docEmphasis">start first server with wildcard</span>
[1]     29697
macosx % <span class="docEmphStrong">sock -s 172.24.37.78 9999</span>         <span class="docEmphasis">try second server, but without -A</span>
can't bind local address: Address already in use
macosx % <span class="docEmphStrong">sock -s -A 172.24.37.78 9999 &amp;</span>    <span class="docEmphasis">try again with -A; works</span>
[2]     29699
macosx % <span class="docEmphStrong">sock -s -A 127.0.0.1 9999 &amp;</span>       <span class="docEmphasis">third server with -A; works</span>
[3]     29700
macosx % <span class="docEmphStrong">netstat -na | grep 9999</span>
tcp4      0      0  127.0.0.1.9999        *.*                       LISTEN
tcp4      0      0  172.24.37.78.9999    *.*                       LISTEN
tcp4      0      0  *.9999                *.*                       LISTEN
</pre><pre>
</pre></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a06"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q06">7.6</A></B></TD><TD><P class="docText">We first try on a host that supports multicasting, but does not support the <TT>SO_REUSEPORT</TT> option (Solaris 9).</P><pre>
</pre><pre>
solaris % <span class="docEmphStrong">sock -s -u 8888 &amp;</span>                <span class="docEmphasis">first one starts</span>
[1]     24051
solaris % <span class="docEmphStrong">sock -s -u 8888</span>
can't bind local address: Address already in use
solaris % <span class="docEmphStrong">sock -s -u -A 8888 &amp;</span>             <span class="docEmphasis">try second again with -A; works</span>
solaris % <span class="docEmphStrong">netstat -na | grep 8888</span>          <span class="docEmphasis">we can see the duplicate bindings</span>
      *.8888                        Idle
      *.8888                        Idle
</pre><pre>
</pre><P class="docText">On this system, we do not need to specify <TT>SO_REUSEADDR</TT> for the first bind, only for the second.</P><P class="docText">Finally, we run this scenario under MacOS X 10.2.6, which supports multicasting and the <TT>SO_REUSEPORT</TT> option. We first try <TT>SO_REUSEADDR</TT> for both servers, but this does not work.</P><pre>
</pre><pre>
macosx % <span class="docEmphStrong">sock -u -s -A 7777 &amp;</span>
[1]     17610
macosx % <span class="docEmphStrong">sock -u -s -A 7777</span>
can't bind local address: Address already in use
</pre><pre>
</pre><P class="docText">Next we try <TT>SO_REUSEPORT</TT>, but only for the second server, not for the first. This does not work since a completely duplicate binding requires the option for all sockets that share the binding.</P><pre>
</pre><pre>
macosx % <span class="docEmphStrong">sock -u -s 8888 &amp;</span>
[1]     17612
macosx % <span class="docEmphStrong">sock -u -s -T 8888</span>
can't bind local address: Address already in use
</pre><pre>
</pre><P class="docText">Finally we specify <TT>SO_REUSEPORT</TT> for both servers, and this works.</P><pre>
</pre><pre>
macosx % <span class="docEmphStrong">sock -u -s -T 9999 &amp;</span>
[1]     17614
macosx % <span class="docEmphStrong">sock -u -s -T 9999 &amp;</span>
[2]     17615
macosx % <span class="docEmphStrong">netstat -na | grep 9999</span>
udp4        0      0  *.9999             *.*
udp4        0      0  *.9999             *.*
</pre><pre>
</pre></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a07"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q07">7.7</A></B></TD><TD><P class="docText">This does nothing because ping uses an ICMP socket and the <TT>SO_DEBUG</TT> socket option affects only TCP sockets. The description for the <TT>SO_DEBUG</TT> socket option has always been something generic such as "this option enables debugging in the respective protocol layer," but the only protocol layer to implement the option has been TCP.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a08"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q08">7.8</A></B></TD><TD><P class="docText"><A class="docLink" HREF="#app05fig06">Figure E.6</A> shows the timeline.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="app05fig06"></A>Figure E.6. Interaction of Nagle algorithm with delayed ACK.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="362" HEIGHT="290" src="FILES/xefig06.gif" ALT="graphics/xefig06.gif"></p>

</CENTER></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a09"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q09">7.9</A></B></TD><TD><P class="docText">Setting the <TT>TCP_NODELAY</TT> socket option causes the data from the second <TT>write</TT> to be sent immediately, even though the connection has a small packet outstanding. We show this in <A class="docLink" HREF="#app05fig07">Figure E.7</A>. The total time in this example is just over 150 ms.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="app05fig07"></A>Figure E.7. Avoidance of Nagle algorithm by setting <TT>TCP_NODELAY</TT> socket option.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="359" HEIGHT="178" src="FILES/xefig07.gif" ALT="graphics/xefig07.gif"></p>

</CENTER></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a10"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q10">7.10</A></B></TD><TD><P class="docText">The advantage to this solution is reducing the number of packets, as we show in <A class="docLink" HREF="#app05fig08">Figure E.8</A>.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="app05fig08"></A>Figure E.8. Using <TT>writev</TT> instead of setting the <TT>TCP_NODELAY</TT> socket option.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="365" HEIGHT="178" src="FILES/xefig08.gif" ALT="graphics/xefig08.gif"></p>

</CENTER></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a11"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q11">7.11</A></B></TD><TD><P class="docText">Section 4.2.3.2 states: "The delay MUST be less than 0.5 seconds, and in a stream of full-sized segments, there SHOULD be an ACK for at least every second segment." Berkeley-derived implementations delay an ACK by at most 200 ms (p.821 of TCPv2).</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a12"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q12">7.12</A></B></TD><TD><P class="docText">The server parent in <A class="docLink" HREF="0131411551_ch05lev1sec2.html#ch05fig02">Figure 5.2</A> spends most of its time blocked in the call to <TT>accept</TT> and the child in <A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig03">Figure 5.3</A> spends most of its time blocked in the call to <TT>read</TT>, which is called by <TT>readline</TT>. The keep-alive option has no effect on a listening socket so the parent is not affected should the client host crash. The child's <TT>read</TT> will return an error of <TT>ETIMEDOUT</TT>, sometime around two hours after the last data exchange across the connection.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a13"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q13">7.13</A></B></TD><TD><P class="docText">The client in <A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A> spends most of its time blocked in the call to <TT>fgets</TT>, which in turn is blocked in some type of read operation on standard input within the standard I/O library. When the keep-alive timer expires around two hours after the last data exchange across the connection, and all the keep-alive probes fail to elicit a response from the server, the socket's pending error is set to <TT>ETIMEDOUT</TT>. But the client is blocked in the call to <TT>fgets</TT> on standard input and will not see this error until it performs a read or write on the socket. This is one reason why we modified <A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A> to use <TT>select</TT> in <A class="docLink" HREF="0131411551_ch06.html#ch06">Chapter 6</A>.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a14"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q14">7.14</A></B></TD><TD><P class="docText">This client spends most of its time blocked in the call to <TT>select</TT>, which will return the socket as readable as soon as the pending error is set to <TT>ETIMEDOUT</TT> (as we described in the previous solution).</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a15"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q15">7.15</A></B></TD><TD><P class="docText">Only two segments are exchanged, not four. There is a very low probability that the two systems will have timers that are exactly synchronized; hence, one end's keep-alive timer will expire shortly before the other's. The first one to expire sends the keep-alive probe, causing the other end to ACK this probe. But the receipt of the keep-alive probe causes the keep-alive timer on the host with the (slightly) slower clock to be reset for two hours in the future.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch07a16"></A><B><A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07q16">7.16</A></B></TD><TD><P class="docText">The original sockets API did not have a <TT>listen</TT> function. Instead, the fourth argument to <TT>socket</TT> contained socket options, and <TT>SO_ACCEPTCON</TT> was used to specify a listening socket. When <TT>listen</TT> was added, the flag stayed around, but it is now set only by the kernel (p.456 of TCPv2).</P></TD></TR></TABLE></P><br>
<P class="docText"></P>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_app05lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_app05lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
