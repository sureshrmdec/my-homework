<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Chapter 6"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_app05lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_app05lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app05lev1sec6"></A>
<H3 class="docSection1Title"> Chapter 6</H3>
<P><TABLE BORDER="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a01"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q01">6.1</A></B></TD><TD><P class="docText">The array of integers is contained within a structure and C allows structures to be assigned across an equals sign.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a02"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q02">6.2</A></B></TD><TD><P class="docText">If <TT>select</TT> tells us that the socket is writable, the socket send buffer has room for 8,192 bytes, but when we call <TT>write</TT> for this blocking socket with a buffer length of 8,193 bytes, <TT>write</TT> can block, waiting for room for the final byte. Read operations on a blocking socket will always return a short count if some data is available, but write operations on a blocking socket will block until all the data can be accepted by the kernel. Therefore, when using <TT>select</TT> to test for writability, we must set the socket to nonblocking to avoid blocking.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a03"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q03">6.3</A></B></TD><TD><P class="docText">If both descriptors are readable, only the first test is performed, the test of the socket. But this does not break the client; it just makes it less efficient. That is, if <TT>select</TT> returns with both descriptors readable, the first <TT>if</TT> is true, causing a <TT>readline</TT> from the socket followed by an <TT>fputs</TT> to standard output. The next <TT>if</TT> is skipped (because of the <TT>else</TT> we prepended), but <TT>select</TT> is then called again and immediately finds standard input readable and returns immediately. The key concept here is that what clears the condition of "standard input being readable" is not <TT>select</TT> returning, but reading from the descriptor.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a04"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q04">6.4</A></B></TD><TD><P class="docText">Use the <TT>getrlimit</TT> function to fetch the values for the <TT>RLIMIT_NOFILE</TT> resource and then call <TT>setrlimit</TT> to set the current soft limit (<TT>rlim_cur</TT>) to the hard limit (<TT>rlim_max</TT>). For example, under Solaris 2.5, the soft limit is 64 but any process can increase this to the default hard limit of 1,024.</P><P class="docText"><TT>getrlimit</TT> and <TT>setrlimit</TT> are not part of POSIX.1, but are required by Unix 98.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a05"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q05">6.5</A></B></TD><TD><P class="docText">The server application continually sends data to the client, which the client TCP acknowledges and throws away.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a06"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q06">6.6</A></B></TD><TD><P class="docText"><TT>shutdown</TT> with <TT>SHUT_WR</TT> or <TT>SHUT_RDWR</TT> always sends a FIN, while <TT>close</TT> sends a FIN only if the descriptor reference count is 1 when <TT>close</TT> is called.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch06a07"></A><B><A class="docLink" HREF="0131411551_ch06lev1sec13.html#ch06q07">6.7</A></B></TD><TD><P class="docText"><span class="docEmphStrong">6.7</span> <TT>read</TT> returns an error, and our <TT>Read</TT> wrapper function terminates the server. Servers must be more robust than this. Notice that we handle this condition in <A class="docLink" HREF="0131411551_ch06lev1sec11.html#ch06fig26">Figure 6.26</A>, although even that code is inadequate. Consider what happens if connectivity is lost between the client and server and one of the server's responses eventually times out. The error returned could be <TT>ETIMEDOUT</TT>.</P><P class="docText">In general, a server should not abort for errors like these. It should log the error, close the socket, and continue servicing other clients. Realize that handling an error of this type by aborting is unacceptable in a server such as this one, where one process is handling all clients. But if the server was a child handling just one client, then having that one child abort would not affect the parent (which we assume handles all new connections and spawns the children), or any of the other children that are servicing other clients.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR></TABLE></P><br>
<P class="docText"></P>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_app05lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_app05lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
