<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.11 TCP Echo Server (Revisited Again)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch06lev1sec10.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch06lev1sec12.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec11"></A>
<H3 class="docSection1Title" id="162666-972">6.11 TCP Echo Server (Revisited Again)</H3>
<P class="docText">We now redo our TCP echo server from <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06lev1sec8">Section 6.8</A> using <TT>poll</TT> instead of <TT>select</TT>. In the previous version using <TT>select</TT>, we had to allocate a <TT>client</TT> array along with a descriptor set named <TT>rset</TT> (<A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig15">Figure 6.15</A>). With <TT>poll</TT>, we must allocate an array of <TT>pollfd</TT> structures to maintain the client information instead of allocating another array. We handle the <TT>fd</TT> member of this array the same way we handled the <TT>client</TT> array in <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig15">Figure 6.15</A>: a value of –1 means the entry is not in use; otherwise, it is the descriptor value. Recall from the previous section that any entry in the array of <TT>pollfd</TT> structures passed to <TT>poll</TT> with a negative value for the <TT>fd</TT> member is just ignored.</P>
<P class="docText"><A class="docLink" HREF="#ch06fig25">Figure 6.25</A> shows the first half of our server.</P>

<H5 class="docExampleTitle"><A NAME="ch06fig25"></A>Figure 6.25 First half of TCP server using <TT>poll</TT>.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/tcpservpoll01.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     &lt;limits.h&gt;         /* for OPEN_MAX */

 3 int
 4 main(int argc, char **argv)
 5 {
 6     int     i, maxi, listenfd, connfd, sockfd;
 7     int     nready;
 8     ssize_t n;
 9     char    buf[MAXLINE];
10     socklen_t clilen;
11     struct pollfd client[OPEN_MAX];
12     struct sockaddr_in cliaddr, servaddr;

13     listenfd = Socket(AF_INET, SOCK_STREAM, 0);

14     bzero(&amp;servaddr, sizeof(servaddr));
15     servaddr.sin_family = AF_INET;
16     servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
17     servaddr.sin_port = htons(SERV_PORT);

18     Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));

19     Listen(listenfd, LISTENQ);

20     client[0].fd = listenfd;
21     client[0].events = POLLRDNORM;
22     for (i = 1; i &lt; OPEN_MAX; i++)
23         client[i].fd = -1;      /* -1 indicates available entry */
24     maxi = 0;                   /* max index into client[] array */
</PRE>

<A NAME="ch06lev3sec8"></A>
<H4 class="docSection2Title"> Allocate array of <TT>pollfd</TT> structures</H4>
<p class="docText"><span class="docEmphasis"><TT>11</TT></span> We declare <TT>OPEN_MAX</TT> elements in our array of <TT>pollfd</TT> structures. Determining the maximum number of descriptors that a process can have open at any one time is difficult. We will encounter this problem again in <A class="docLink" HREF="0131411551_ch13lev1sec4.html#ch13fig04">Figure 13.4</A>. One way is to call the POSIX <TT>sysconf</TT> function with an argument of <TT>_SC_OPEN_MAX</TT> (as described on pp. 42–44 of APUE) and then dynamically allocate an array of the appropriate size. But one of the possible returns from <TT>sysconf</TT> is "indeterminate," meaning we still have to guess a value. Here, we just use the POSIX <TT>OPEN_MAX</TT> constant.</p>

<A NAME="ch06lev3sec9"></A>
<H4 class="docSection2Title"> Initialize</H4>
<p class="docText"><span class="docEmphasis"><TT>20–24</TT></span> We use the first entry in the <TT>client</TT> array for the listening socket and set the descriptor for the remaining entries to –1. We also set the <TT>POLLRDNORM</TT> event for this descriptor, to be notified by <TT>poll</TT> when a new connection is ready to be accepted. The variable <TT>maxi</TT> contains the largest index of the <TT>client</TT> array currently in use.</p>
<P class="docText">The second half of our function is shown in <A class="docLink" HREF="#ch06fig26">Figure 6.26</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch06fig26"></A>Figure 6.26 Second half of TCP server using <TT>poll</TT>.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/tcpservpoll01.c</span></P>

<PRE>
25     for ( ; ; ) {
26         nready = Poll(client, maxi + 1, INFTIM);

27         if (client[0].revents &amp; POLLRDNORM) {  /* new client connection */
28             clilen = sizeof(cliaddr);
29             connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);

30             for (i = 1; i &lt; OPEN_MAX; i++)
31                 if (client[i].fd &lt; 0) {
32                     client[i].fd = connfd;  /* save descriptor */
33                     break;
34                 }
35             if (i == OPEN_MAX)
36                 err_quit("too many clients");
37             client[i].events = POLLRDNORM;
38             if (i &gt; maxi)
39                 maxi = i;       /* max index in client[] array */

40             if (--nready &lt;= 0)
41                 continue;       /* no more readable descriptors */
42         }

43         for (i = 1; i &lt;= maxi; i++) {       /* check all clients for data */
44             if ( (sockfd = client[i].fd) &lt; 0)
45                 continue;
46             if (client[i].revents &amp; (POLLRDNORM | POLLERR)) {
47                 if ( (n = read(sockfd, buf, MAXLINE)) &lt; 0) {
48                     if (errno == ECONNRESET) {
49                             /* connection reset by client */
50                         Close(sockfd);
51                         client[i].fd = -1;
52                     } else
53                         err_sys("read error");
54                 } else if (n == 0) {
55                         /* connection closed by client */
56                     Close(sockfd);
57                     client[i].fd = -1;
58                 } else
59                    Writen(sockfd, buf, n);
60                 if (--nready &lt;= 0)
61                         break;               /* no more readable descriptors */
62             }
63         }
64     }
65 }
</PRE>


<A NAME="ch06lev3sec10"></A>
<H4 class="docSection2Title"> Call <TT>poll</TT>, check for new connection</H4>
<p class="docText"><span class="docEmphasis"><TT>26–42</TT></span> We call <TT>poll</TT> to wait for either a new connection or data on existing connection. When a new connection is accepted, we find the first available entry in the <TT>client</TT> array by looking for the first one with a negative descriptor. Notice that we start the search with the index of 1, since <TT>client[0]</TT> is used for the listening socket. When an available entry is found, we save the descriptor and set the <TT>POLLRDNORM</TT> event.</p>

<A NAME="ch06lev3sec11"></A>
<H4 class="docSection2Title"> Check for data on an existing connection</H4>
<p class="docText"><span class="docEmphasis"><TT>43–63</TT></span> The two return events that we check for are <TT>POLLRDNORM</TT> and <TT>POLLERR</TT>. The second of these we did not set in the <TT>events</TT> member because it is always returned when the condition is true. The reason we check for <TT>POLLERR</TT> is because some implementations return this event when an RST is received for a connection, while others just return <TT>POLLRDNORM</TT>. In either case, we call <TT>read</TT> and if an error has occurred, it will return an error. When an existing connection is terminated by the client, we just set the <TT>fd</TT> member to –1.</p>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch06lev1sec10.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch06lev1sec12.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
