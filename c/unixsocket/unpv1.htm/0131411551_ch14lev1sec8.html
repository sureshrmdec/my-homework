<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="14.8 Sockets and Standard I/O"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch14lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch14lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch14lev1sec8"></A>
<H3 class="docSection1Title">14.8 Sockets and Standard I/O</H3>
<P class="docText">In all our examples so far, we have used what is sometimes called <span class="docEmphasis">Unix I/O</span>, the <TT>read</TT> and <TT>write</TT> functions and their variants (<TT>recv</TT>, <TT>send</TT>, etc.). These functions work with <span class="docEmphasis">descriptors</span> and are normally implemented as system calls within the Unix kernel.</P>
<P class="docText">Another method of performing I/O is the <span class="docEmphasis">standard I/O library</span>. It is specified by the ANSI C standard and is intended to be portable to non-Unix systems that support ANSI C. The standard I/O library handles some of the details that we must worry about ourselves when using the Unix I/O functions, such as automatically buffering the input and output streams. Unfortunately, its handling of a stream's buffering can present a new set of problems we must worry about. Chapter 5 of APUE covers the standard I/O library in detail, and [Plauger 1992] presents and discusses a complete implementation of the standard I/O library.</P>
<BLOCKQUOTE><P><P class="docList">The term <span class="docEmphasis">stream</span> is used with the standard I/O library, as in "we open an input stream" or "we flush the output stream." Do not confuse this with the STREAMS subsystem, which we will discuss in <A class="docLink" HREF="0131411551_ch31.html#ch31">Chapter 31</A>.</P></P></BLOCKQUOTE>
<P class="docText">The standard I/O library can be used with sockets, but there are a few items to consider:</P>
<UL><LI><P class="docList">A standard I/O stream can be created from any descriptor by calling the <TT>fdopen</TT> function. Similarly, given a standard I/O stream, we can obtain the corresponding descriptor by calling <TT>fileno</TT>. Our first encounter with <TT>fileno</TT> was in <A class="docLink" HREF="0131411551_ch06lev1sec4.html#ch06fig09">Figure 6.9</A> when we wanted to call <TT>select</TT> on a standard I/O stream. <TT>select</TT> works only with descriptors, so we had to obtain the descriptor for the standard I/O stream.</P></LI><LI><P class="docList">TCP and UDP sockets are full-duplex. Standard I/O streams can also be full-duplex: we just open the stream with a type of <TT>r+</TT>, which means read-write. But on such a stream, an output function cannot be followed by an input function without an intervening call to <TT>fflush</TT>, <TT>fseek</TT>, <TT>fsetpos</TT>, or <TT>rewind</TT>. Similarly, an input function cannot be followed by an output function without an intervening call to <TT>fseek</TT>, <TT>fsetpos</TT>, or <TT>rewind</TT>, unless the input function encounters an EOF. The problem with these latter three functions is that they all call <TT>lseek</TT>, which fails on a socket.</P></LI><LI><P class="docList">The easiest way to handle this read-write problem is to open two standard I/O streams for a given socket: one for reading and one for writing.</P></LI></UL>
<A NAME="ch14lev2sec5"></A>
<H4 class="docSection2Title"> Example: <TT>str_echo</TT> Function Using Standard I/O</H4>
<P class="docText">We now show an alternate version of our TCP echo server (<A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig03">Figure 5.3</A>), which uses standard I/O instead of <TT>read</TT> and <TT>writen</TT>. <A class="docLink" HREF="#ch14fig14">Figure 14.14</A> is a version of our <TT>str_echo</TT> function that uses standard I/O. (This version has a problem that we will describe shortly.)</P>

<H5 class="docExampleTitle"><A NAME="ch14fig14"></A>Figure 14.14 <TT>str_echo</TT> function recoded to use standard I/O.</H5>
<P class="docText"><span class="docEmphasis">advio/str_echo_stdio02.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 str_echo(int sockfd)
 4 {
 5     char     line[MAXLINE];
 6     FILE    *fpin,  *fpout;

 7     fpin = Fdopen(sockfd, "r");
 8     fpout = Fdopen(sockfd, "w");

 9     while (Fgets(line, MAXLINE, fpin) != NULL)
10         Fputs(line, fpout);
11 }
</PRE>

<A NAME="ch14lev3sec12"></A>
<H5 class="docSection3Title"> Convert descriptor into input stream and output stream</H5>
<p class="docText"><span class="docEmphasis"><TT>7–10</TT></span> Two standard I/O streams are created by <TT>fdopen:</TT> one for input and one for output. The calls to <TT>read</TT> and <TT>writen</TT> are replaced with calls to <TT>fgets</TT> and <TT>fputs</TT>.</p>
<P class="docText">If we run our server with this version of <TT>str_echo</TT> and then run our client, we see the following:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>hpux %</TT> <span class="docEmphStrong"><TT>tcpcli02 206.168.112.96</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>hello, world</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we type this line, but nothing is echoed</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>and hi</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and this one, still no echo</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>hello??</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and this one, still no echo</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>^D</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and our EOF character</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>hello, world</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and then the three echoed lines are output</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>and hi</TT></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>hello??</TT></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR></COLGROUP></TABLE></P>
<P class="docText">There is a buffering problem here because nothing is echoed by the server until we enter our EOF character. The following steps take place:</P>
<UL><LI><P class="docList">We type the first line of input and it is sent to the server.</P></LI><LI><P class="docList">The server reads the line with <TT>fgets</TT> and echoes it with <TT>fputs</TT>.</P></LI><LI><P class="docList">The server's standard I/O stream is <span class="docEmphasis">fully buffered</span> by the standard I/O library. This means the library copies the echoed line into its standard I/O buffer for this stream, but does not write the buffer to the descriptor, because the buffer is not full.</P></LI><LI><P class="docList">We type the second line of input and it is sent to the server.</P></LI><LI><P class="docList">The server reads the line with <TT>fgets</TT> and echoes it with <TT>fputs</TT>.</P></LI><LI><P class="docList">Again, the server's standard I/O library just copies the line into its buffer, but does not write the buffer because it is still not full.</P></LI><LI><P class="docList">The same scenario happens with the third line of input that we enter.</P></LI><LI><P class="docList">We type our EOF character, and our <TT>str_cli</TT> function (<A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>) calls <TT>shutdown</TT>, sending a FIN to the server.</P></LI><LI><P class="docList">The server TCP receives the FIN, which <TT>fgets</TT> reads, causing <TT>fgets</TT> to return a null pointer.</P></LI><LI><P class="docList">The <TT>str_echo</TT> function returns to the server <TT>main</TT> function (<A class="docLink" HREF="0131411551_ch05lev1sec10.html#ch05fig12">Figure 5.12</A>) and the child terminates by calling <TT>exit</TT>.</P></LI><LI><P class="docList">The C library function <TT>exit</TT> calls the standard I/O cleanup function (pp. 162–164 of APUE). The output buffer that was partially filled by our calls to <TT>fputs</TT> is now output.</P></LI><LI><P class="docList">The server child process terminates, causing its connected socket to be closed, sending a FIN to the client, completing the TCP four-packet termination sequence.</P></LI><LI><P class="docList">The three echoed lines are received by our <TT>str_cli</TT> function and output.</P></LI><LI><P class="docList"><TT>str_cli</TT> then receives an EOF on its socket, and the client terminates.</P></LI></UL>
<P class="docText">The problem here is the buffering performed automatically by the standard I/O library on the server. There are three types of buffering performed by the standard I/O library:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList"><span class="docEmphasis">Fully buffered</span> means that I/O takes place only when the buffer is full, the process explicitly calls <TT>fflush</TT>, or the process terminates by calling <TT>exit</TT>. A common size for the standard I/O buffer is 8,192 bytes.</P></span></LI><LI><span style="font-weight:normal"><P class="docList"><span class="docEmphasis">Line buffered</span> means that I/O takes place when a newline is encountered, when the process calls <TT>fflush</TT>, or when the process terminates by calling <TT>exit</TT>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList"><span class="docEmphasis">Unbuffered</span> means that I/O takes place each time a standard I/O output function is called.</P></span></LI></OL></span>
<P class="docText">Most Unix implementations of the standard I/O library use the following rules:</P>
<UL><LI><P class="docList">Standard error is always unbuffered.</P></LI><LI><P class="docList">Standard input and standard output are fully buffered, unless they refer to a terminal device, in which case, they are line buffered.</P></LI><LI><P class="docList">All other streams are fully buffered unless they refer to a terminal device, in which case, they are line buffered.</P></LI></UL>
<P class="docText">Since a socket is not a terminal device, the problem seen with our <TT>str_echo</TT> function in <A class="docLink" HREF="#ch14fig14">Figure 14.14</A> is that the output stream (<TT>fpout</TT>) is fully buffered. One way around this is to force the output stream to be line buffered by calling <TT>setvbuf</TT>. Another is to force each echoed line to be output by calling <TT>fflush</TT> after each call to <TT>fputs</TT>. But in practice, either of these solutions is still error-prone and may interact badly with the Nagle algorithm described in <A class="docLink" HREF="0131411551_ch07lev1sec9.html#ch07lev1sec9">Section 7.9</A>. In most cases, the best solution is to avoid using the standard I/O library altogether for sockets and operate on buffers instead of lines, as described in <A class="docLink" HREF="0131411551_ch03lev1sec9.html#ch03lev1sec9">Section 3.9</A>. Using standard I/O on sockets may make sense when the convenience of standard I/O streams outweighs the concerns about bugs due to buffering, but these are rare cases.</P>
<BLOCKQUOTE><P><P class="docList">Be aware that some implementations of the standard I/O library still have a problem with descriptors greater than 255. This can be a problem with network servers that handle lots of descriptors. Check the definition of the <TT>FILE</TT> structure in your <TT>&lt;stdio.h&gt;</TT> header to see what type of variable holds the descriptor.</P></P></BLOCKQUOTE>



<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch14lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch14lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
