<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.5 Source Code Portability"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch12lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch12lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch12lev1sec5"></A>
<H3 class="docSection1Title">12.5 Source Code Portability</H3>
<P class="docText">Most existing network applications are written assuming IPv4. <TT>sockaddr_in</TT> structures are allocated and filled in and the calls to <TT>socket</TT> specify <TT>AF_INET</TT> as the first argument. We saw in the conversion from <A class="docLink" HREF="0131411551_ch01lev1sec2.html#ch01fig05">Figure 1.5</A> to <A class="docLink" HREF="0131411551_ch01lev1sec3.html#ch01fig06">Figure 1.6</A> that these IPv4 applications could be converted to use IPv6 without too much effort. Many of the changes that we showed could be done automatically using some editing scripts. Programs that are more dependent on IPv4, using features such as multicasting, IP options, or raw sockets, will take more work to convert.</P>
<P class="docText">If we convert an application to use IPv6 and distribute it in source code, we now have to worry about whether or not the recipient's system supports IPv6. The typical way to handle this is with <TT>#ifdefs</TT> throughout the code, using IPv6 when possible (since we have seen in this chapter that an IPv6 client can still communicate with IPv4 servers, and vice versa). The problem with this approach is that the code becomes littered with <TT>#ifdefs</TT> very quickly, and is harder to follow and maintain.</P>
<P class="docText">A better approach is to consider the move to IPv6 as a chance to make the program protocol-independent. The first step is to remove calls to <TT>gethostbyname</TT> and <TT>gethostbyaddr</TT> and use the <TT>getaddrinfo</TT> and <TT>getnameinfo</TT> functions that we described in the previous chapter. This lets us deal with socket address structures as opaque objects, referenced by a pointer and size, which is exactly what the basic socket functions do: <TT>bind</TT>, <TT>connect</TT>, <TT>recvfrom</TT>, and so on. Our <TT>sock_</TT><span class="docEmphasis">XXX</span> functions from <A class="docLink" HREF="0131411551_ch03lev1sec8.html#ch03lev1sec8">Section 3.8</A> can help manipulate these, independent of IPv4 or IPv6. Obviously these functions contain <TT>#ifdefs</TT> to handle IPv4 and IPv6, but hiding all of this protocol dependency in a few library functions makes our code simpler. We will develop a set of <TT>mcast_</TT><span class="docEmphasis">XXX</span> functions in <A class="docLink" HREF="0131411551_ch21lev1sec7.html#ch21lev1sec7">Section 21.7</A> that can make multicast applications independent of IPv4 or IPv6.</P>
<P class="docText">Another point to consider is what happens if we compile our source code on a system that supports both IPv4 and IPv6, distribute either executable code or object files (but not the source code), and someone runs our application on a system that does not support IPv6? There is a chance that the local name server supports AAAA records and returns both AAAA records and A records for some peer with which our application tries to connect. If our application, which is IPv6-capable, calls <TT>socket</TT> to create an IPv6 socket, it will fail if the host does not support IPv6. We handle this in the helper functions described in the previous chapter by ignoring the error from <TT>socket</TT> and trying the next address on the list returned by the name server. Assuming the peer has an A record, and that the name server returns the A record in addition to any AAAA records, the creation of an IPv4 socket will succeed. This is the type of functionality that belongs in a library function, and not in the source code of every application.</P>
<P class="docText">To enable passing socket descriptors to programs that were IPv4-only or IPv6-only, RFC 2133 [Gilligan et al. 1997] introduced the <TT>IPV6_ADDRFORM</TT> socket option, which could return or potentially change the address family associated with a socket. However, the semantics were never completely described, and it was only useful in very specific cases, so it was removed in the next revision of the API.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch12lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch12lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
