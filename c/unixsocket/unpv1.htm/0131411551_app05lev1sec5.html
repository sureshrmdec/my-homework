<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Chapter 5"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_app05lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_app05lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app05lev1sec5"></A>
<H3 class="docSection1Title"> Chapter 5</H3>
<P><TABLE BORDER="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a01"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q01">5.1</A></B></TD><TD><P class="docText">The duration of the TIME_WAIT state should be between 1 and 4 minutes, giving an MSL between 30 seconds and 2 minutes.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a02"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q02">5.2</A></B></TD><TD><P class="docText">Our client/server programs do not work with a binary file. Assume the first 3 bytes in the file are binary 1, binary 0, and a newline. The call to <TT>fgets</TT> in <A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A> reads up to <TT>MAXLINE-1</TT> characters, or until a newline is encountered, or up through the EOF. In this example, it will read the first three characters and then terminate the string with a null byte. But, our call to <TT>strlen</TT> in <A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A> returns 1, since it stops at the first null byte. One byte is sent to the server, but the server blocks in its call to <TT>readline</TT>, waiting for a newline character. The client blocks waiting for the server's reply. This is called a <span class="docEmphasis">deadlock:</span> Both processes are blocked waiting for something that will never arrive from the other one. The problem here is that <TT>fgets</TT> signifies the end of the data that it returns with a null byte, so the data that it reads cannot contain any null bytes.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a03"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q03">5.3</A></B></TD><TD><P class="docText"><span class="docEmphStrong">5.3</span> Telnet converts the input lines into NVT ASCII (Section 26.4 of TCPv1), which terminates every line with the two-character sequence of a CR (carriage return) followed by an LF (linefeed). Our client adds only a newline, which is actually a linefeed character. Nevertheless, we can use the Telnet client to communicate with our server as our server echoes back every character, including the CR that precedes each newline.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a04"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q04">5.4</A></B></TD><TD><P class="docText">No, the final two segments of the connection termination sequence are not sent. When the client sends the data to the server, after we kill the server child (the "another line"), the server TCP responds with an RST. The RST aborts the connection and also prevents the server end of the connection (the end that did the active close) from passing through the TIME_WAIT state.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a05"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q05">5.5</A></B></TD><TD><P class="docText">Nothing changes because the server process that is started on the server host creates a listening socket and is waiting for new connection requests to arrive. What we send in Step 3 is a data segment destined for an ESTABLISHED TCP connection. Our server with the listening socket never sees this data segment, and the server TCP still responds to it with an RST.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a06"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q06">5.6</A></B></TD><TD><P class="docText"><A class="docLink" HREF="#app05fig01">Figure E.1</A> shows the program. Running this program under Solaris generates the following:</P><pre>
</pre><pre>
solaris % <span class="docEmphStrong">tsigpipe 192.168.1.10</span>
SIGPIPE received
write error: Broken pipe
</pre><pre>
</pre><P class="docText">The initial <TT>sleep</TT> of two seconds is to let the daytime server send its reply and close its end of the connection. Our first <TT>write</TT> sends a data segment to the server, which responds with an RST (since the daytime server has completely closed its socket). Note that our TCP allows us to write to a socket that has received a FIN. The second <TT>sleep</TT> lets the server's RST be received, and our second <TT>write</TT> generates <TT>SIGPIPE</TT>. Since our signal handler returns, <TT>write</TT> returns an error of <TT>EPIPE</TT>.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a07"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q07">5.7</A></B></TD><TD><P class="docText">Assuming the server host supports the <span class="docEmphasis">weak end system model</span> (which we describe in <A class="docLink" HREF="0131411551_ch08lev1sec8.html#ch08lev1sec8">Section 8.8</A>), everything works. That is, the server host will accept an incoming IP datagram (which contains a TCP segment in this case) arriving on the leftmost datalink, even though the destination IP address is the address of the rightmost datalink. We can test this by running our server on our host <TT>linux</TT> (<A class="docLink" HREF="0131411551_ch01lev1sec9.html#ch01fig16">Figure 1.16</A>) and then starting the client on our host <TT>solaris</TT>, but specifying the other IP address of the server (206.168.112.96) to the client. After the connection is established, if we run <TT>netstat</TT> on the server, we see that the local IP address is the destination IP address from the client's SYN, not the IP address of the datalink on which the SYN arrived (as we mentioned in <A class="docLink" HREF="0131411551_ch04lev1sec4.html#ch04lev1sec4">Section 4.4</A>).</P>
<H5 class="docExampleTitle"><A NAME="app05fig01"></A>Figure E.1 Generate <TT>SIGPIPE</TT>.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/tsigpipe.c</span></P>
<PRE>
 1 #include    "unp.h"

 2 void
 3 sig_pipe(int signo)
 4 {
 5     printf("SIGPIPE received\n");
 6     return;
 7 }

 8 int
 9 main(int argc, char **argv)
10 {
11     int     sockfd;
12     struct sockaddr_in servaddr;

13     if (argc != 2)
14         err_quit("usage: tcpcli &lt;IPaddress&gt;");

15     sockfd = Socket(AF_INET, SOCK_STREAM, 0);

16     bzero(&amp;servaddr, sizeof(servaddr));
17     servaddr.sin_family = AF_INET;
18     servaddr.sin_port = htons(13);  /* daytime server */
19     Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr);

20     Signal(SIGPIPE, sig_pipe);

21     Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));

22     sleep(2);
23     Write(sockfd, "hello", 5);
24     sleep(2);
25     Write(sockfd, "world", 5);

26     exit(0);
27 }
</PRE>
</TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a08"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q08">5.8</A></B></TD><TD><P class="docText">Our client was on a little-endian Intel system, where the 32-bit integer with a value of 1 was stored as shown in <A class="docLink" HREF="#app05fig02">Figure E.2</A>.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="app05fig02"></A>Figure E.2. Representation of the 32-bit integer 1 in little-endian format.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="309" HEIGHT="93" src="FILES/xefig02.gif" ALT="graphics/xefig02.gif"></p>

</CENTER><P class="docText">The 4 bytes are sent across the socket in the order <span class="docEmphasis">A</span>, <span class="docEmphasis">A+1</span>, <span class="docEmphasis">A+2</span>, and <span class="docEmphasis">A+3</span> where they are stored in the big-endian format, as shown in <A class="docLink" HREF="#app05fig03">Figure E.3</A>.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="app05fig03"></A>Figure E.3. Representation of the 32-bit integer from <A class="docLink" HREF="#app05fig02">Figure E.2</A> in big-endian format.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="243" HEIGHT="48" src="FILES/xefig03.gif" ALT="graphics/xefig03.gif"></p>

</CENTER><P class="docText">This value of <TT>0x01000000</TT> is interpreted as 16,777,216. Similarly, the integer 2 sent by the client will be interpreted at the server as <TT>0x02000000</TT>, or 33,554,432. The sum of these two integers is 50,331,648, or <TT>0x03000000</TT>. When this bigendian value on the server is sent to the client, it is interpreted on the client as the integer value 3.</P><P class="docText">The 32-bit integer value of - 22 is represented on the little-endian system as shown in <A class="docLink" HREF="#app05fig04">Figure E.4</A>, assuming a two's-complement representation of negative numbers.</P><CENTER>
<H5 class="docFigureTitle"><A NAME="app05fig04"></A>Figure E.4. Representation of the 32-bit integer - 22 in little-endian format.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="244" HEIGHT="49" src="FILES/xefig04.gif" ALT="graphics/xefig04.gif"></p>

</CENTER><P class="docText">This is interpreted on the big-endian server as <TT>0xeaffffff</TT>, or - 352,321,537. Similarly, the little-endian representation of - 77 is <TT>0xffffffb3</TT>, but this is represented on the big-endian server as <TT>0xb3ffffff</TT>, or - 1,275,068,417. The addition on the server yields a binary result of <TT>0x9efffffe</TT>, or - 1,627,389,954. This big-endian value is sent across the socket to the client where it is interpreted as the little-endian value <TT>0xfeffff9e</TT>, or - 16,777,314, which is the value printed in our example.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a09"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q09">5.9</A></B></TD><TD><P class="docText">The technique is correct (converting the binary values to network byte order), but the two functions <TT>htonl</TT> and <TT>ntohl</TT> cannot be used. Even though the <TT>l</TT> in these functions once meant "long," these functions operate on 32-bit integers (<A class="docLink" HREF="0131411551_ch03lev1sec4.html#ch03lev1sec4">Section 3.4</A>). On a 64-bit system, a <TT>long</TT> will probably occupy 64 bits and these two functions will not work correctly. One might define two new functions, <TT>hton64</TT> and <TT>ntoh64</TT>, to solve this problem, but this will not work on systems that represent <TT>longs</TT> using 32 bits.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a10"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q10">5.10</A></B></TD><TD><P class="docText">In the first scenario, the server blocks forever in the call to <TT>readn</TT> in <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig20">Figure 5.20</A> because the client sends two 32-bit values but the server is waiting for two 64-bit values. Swapping the client and server between the two hosts causes the client to send two 64-bit values, but the server reads only the first 64 bits, interpreting them as two 32-bit values. The second 64-bit value remains in the server's socket receive buffer. The server writes back one 32-bit value and the client will block forever in its call to <TT>readn</TT> in <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig19">Figure 5.19</A>, waiting to read one 64-bit value.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05a11"></A><B><A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05q11">5.11</A></B></TD><TD><P class="docText">IP's routing function looks at the destination IP address (the server's IP address) and searches the routing table to determine the outgoing interface and next hop (Chapter 9 of TCPv1). The primary IP address of the outgoing interface is used as the source IP address, assuming the socket has not already bound a local IP address.</P></TD></TR></TABLE></P><br>
<P class="docText"></P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_app05lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_app05lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
