<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.13 Lack of Flow Control with UDP"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch08lev1sec12.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch08lev1sec14.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec13"></A>
<H3 class="docSection1Title">8.13 Lack of Flow Control with UDP</H3>
<P class="docText">We now examine the effect of UDP not having any flow control. First, we modify our <TT>dg_cli</TT> function to send a fixed number of datagrams. It no longer reads from standard input. <A class="docLink" HREF="#ch08fig19">Figure 8.19</A> shows the new version. This function writes 2,000 1,400-byte UDP datagrams to the server.</P>
<P class="docText">We next modify the server to receive datagrams and count the number received. This server no longer echoes datagrams back to the client. <A class="docLink" HREF="#ch08fig20">Figure 8.20</A> shows the new <TT>dg_echo</TT> function. When we terminate the server with our terminal interrupt key (<TT>SIGINT</TT>), it prints the number of received datagrams and terminates.</P>

<H5 class="docExampleTitle"><A NAME="ch08fig19"></A>Figure 8.19 <TT>dg_cli</TT> function that writes a fixed number of datagrams to the server.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/dgcliloop1.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 #define NDG      2000          /*  datagrams to send */
 3 #define DGLEN    1400          /*  length of each datagram */

 4 void
 5 dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
 6 {
 7     int     i;
 8     char    sendline[DGLEN];

 9     for (i = 0; i &lt; NDG; i++) {
10         Sendto(sockfd, sendline, DGLEN, 0, pservaddr, servlen);
11     }
12 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch08fig20"></A>Figure 8.20 <TT>dg_echo</TT> function that counts received datagrams.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/dgecholoop1.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 static void recvfrom_int(int);
 3 static int count;

 4 void
 5 dg_echo(int sockfd, SA *pcliaddr, socklen_t clilen)
 6 {
 7     socklen_t len;
 8     char    mesg[MAXLINE];

 9     Signal(SIGINT, recvfrom_int);

10     for ( ; ; ) {
11         len = clilen;
12         Recvfrom(sockfd, mesg, MAXLINE, 0, pcliaddr, &amp;len);

13         count++;
14     }
15 }

16 static void
17 recvfrom_int(int signo)
18 {
19     printf("\nreceived %d datagrams\n", count);
20     exit(0);
21 }
</PRE>

<P class="docText">We now run the server on the host <TT>freebsd</TT>, a slow SPARCStation. We run the client on the RS/6000 system <TT>aix</TT>, connected directly with 100Mbps Ethernet. Additionally, we run <TT>netstat -s</TT> on the server, both before and after, as the statistics that are output tell us how many datagrams were lost. <A class="docLink" HREF="#ch08fig21">Figure 8.21</A> shows the output on the server.</P>

<H5 class="docExampleTitle"><A NAME="ch08fig21"></A>Figure 8.21 Output on server host.</H5>

<PRE>
freebsd % <span class="docEmphStrong">netstat -s -p udp</span>
udp:
        71208 datagrams received
        0 with incomplete header
        0 with bad data length field
        0 with bad checksum
        0 with no checksum
        832 dropped due to no socket
        16 broadcast/multicast datagrams dropped due to no socket
        1971 dropped due to full socket buffers
        0 not for hashed pcb
        68389 delivered
        137685 datagrams output
freebsd % <span class="docEmphStrong">udpserv06</span>             <span class="docEmphasis">start our server</span>
                                                                        <span class="docEmphasis">we run the client here</span>
     <span class="docEmphStrong">^C</span>                              <span class="docEmphasis">we type our interrupt key after the client is finished</span>
received 30 datagrams
freebsd % <span class="docEmphStrong">netstat -s -p udp</span>
udp:
        73208 datagrams received
        0 with incomplete header
        0 with bad data length field
        0 with bad checksum
        0 with no checksum
        832 dropped due to no socket
        16 broadcast/multicast datagrams dropped due to no socket
        3941 dropped due to full socket buffers
        0 not for hashed pcb
        68419 delivered
        137685 datagrams output
</PRE>

<P class="docText">The client sent 2,000 datagrams, but the server application received only 30 of these, for a 98% loss rate. There is <span class="docEmphasis">no</span> indication whatsoever to the server application or to the client application that these datagrams were lost. As we have said, UDP has no flow control and it is unreliable. It is trivial, as we have shown, for a UDP sender to overrun the receiver.</P>
<P class="docText">If we look at the <TT>netstat</TT> output, the total number of datagrams received by the server host (not the server application) is 2,000 (73,208 - 71,208). The counter "dropped due to full socket buffers" indicates how many datagrams were received by UDP but were discarded because the receiving socket's receive queue was full (p. 775 of TCPv2). This value is 1,970 (3,491 - 1,971), which when added to the counter output by the application (30), equals the 2,000 datagrams received by the host. Unfortunately, the <TT>netstat</TT> counter of the number dropped due to a full socket buffer is systemwide. There is no way to determine which applications (e.g., which UDP ports) are affected.</P>
<P class="docText">The number of datagrams received by the server in this example is not predictable. It depends on many factors, such as the network load, the processing load on the client host, and the processing load on the server host.</P>
<P class="docText">If we run the same client and server, but this time with the client on the slow Sun and the server on the faster RS/6000, no datagrams are lost.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>aix %</TT> <span class="docEmphStrong"><TT>udpserv06</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText">^?</P></TD><TD class="docTableCell" align="right" valign="top"><P class="docText"><span class="docEmphasis">we type our interrupt key after the client is finished</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>received 2000 datagrams</TT></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR></COLGROUP></TABLE></P>
<A NAME="ch08lev2sec3"></A>
<H4 class="docSection2Title"> UDP Socket Receive Buffer</H4>
<P class="docText">The number of UDP datagrams that are queued by UDP for a given socket is limited by the size of that socket's receive buffer. We can change this with the <TT>SO_RCVBUF</TT> socket option, as we described in <A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A>. The default size of the UDP socket receive buffer under FreeBSD is 42,080 bytes, which allows room for only 30 of our 1,400-byte datagrams. If we increase the size of the socket receive buffer, we expect the server to receive additional datagrams. <A class="docLink" HREF="#ch08fig22">Figure 8.22</A> shows a modification to the <TT>dg_echo</TT> function from <A class="docLink" HREF="#ch08fig20">Figure 8.20</A> that sets the socket receive buffer to 240 KB.</P>

<H5 class="docExampleTitle"><A NAME="ch08fig22"></A>Figure 8.22 <TT>dg_echo</TT> function that increases the size of the socket receive queue.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/dgecholoop2.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 static void recvfrom_int(int);
 3 static int count;

 4 void
 5 dg_echo(int sockfd, SA *pcliaddr, socklen_t clilen)
 6 {
 7     int     n;
 8     socklen_t len;
 9     char    mesg[MAXLINE];

10     Signal(SIGINT, recvfrom_int);

11     n = 220 * 1024;
12     Setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, sizeof(n));

13     for ( ; ; ) {
14         len = clilen;
15         Recvfrom(sockfd, mesg, MAXLINE, 0, pcliaddr, &amp;len);

16         count++;
17     }
18 }

19 static void
20 recvfrom_int(int signo)
21 {
22     printf("\nreceived %d datagrams\n", count);
23     exit(0);
24 }
</PRE>

<P class="docText">If we run this server on the Sun and the client on the RS/6000, the count of received datagrams is now 103. While this is slightly better than the earlier example with the default socket receive buffer, it is no panacea.</P>
<BLOCKQUOTE><P><P class="docList">Why do we set the receive socket buffer size to 220 x 1,024 in <A class="docLink" HREF="#ch08fig22">Figure 8.22</A>? The maximum size of a socket receive buffer in FreeBSD 5.1 defaults to 262,144 bytes (256 x 1,024), but due to the buffer allocation policy (described in Chapter 2 of TCPv2), the actual limit is 233,016 bytes. Many earlier systems based on 4.3BSD restricted the size of a socket buffer to around 52,000 bytes.</P></P></BLOCKQUOTE>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch08lev1sec12.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch08lev1sec14.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
