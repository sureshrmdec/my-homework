<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="29.3 Datalink Provider Interface (DLPI)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch29lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch29lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch29lev1sec3"></A>
<H3 class="docSection1Title">29.3 Datalink Provider Interface (DLPI)</H3>
<P class="docText">SVR4 provides datalink access through DLPI. DLPI is a protocol-independent interface designed by AT&amp;T that interfaces to the service provided by the datalink layer [Unix International 1991]. Access to DLPI is by sending and receiving STREAMS messages.</P>
<P class="docText">There are two styles of DLPI. In one style, there is a single device to open, and the desired interface is specified using a DLPI <TT>DL_ATTACH_REQ</TT> request. In the other style, the application simply <TT>opens</TT> the device (e.g., <TT>le0</TT>). But for efficient operation, two additional STREAMS modules are normally pushed onto the stream: <TT>pfmod</TT>, which performs packet filtering within the kernel, and <TT>bufmod</TT>, which buffers the data destined for the application. We show this in <A class="docLink" HREF="#ch29fig02">Figure 29.2</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch29fig02"></A>Figure 29.2. Packet capture using DLPI, <TT>pfmod</TT>, and <TT>bufmod</TT>.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="424" src="FILES/29fig02.gif" ALT="graphics/29fig02.gif"></p>

</CENTER>
<P class="docText">Conceptually, this is similar to what we described in the previous section for BPF: <TT>pfmod</TT> supports filtering within the kernel using a pseudomachine and <TT>bufmod</TT> reduces the amount of data and number of system calls by supporting a snapshot length and a read timeout.</P>
<P class="docText">One interesting difference, however, is the type of pseudomachine supported by the BPF and <TT>pfmod</TT> filters. The BPF filter is a directed acyclic control flow graph (CFG), while <TT>pfmod</TT> uses a Boolean expression tree. The former maps naturally into code for a register machine while the latter maps naturally into code for a stack machine [McCanne and Jacobson 1993]. This paper shows that the CFG implementation used by BPF is normally 3 to 20 times faster than the Boolean expression tree, depending on the complexity of the filter.</P>
<P class="docText">Another difference is that BPF always makes the filtering decision before copying the packet, in order to not copy packets that the filter will discard. Depending on the DLPI implementation, the packet may be copied to give it to <TT>pfmod</TT>, which may then discard it.</P>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch29lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch29lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
