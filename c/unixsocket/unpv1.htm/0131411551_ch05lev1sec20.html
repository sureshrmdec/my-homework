<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Exercises"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec19.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch06.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec20"></A>
<H3 class="docSection1Title"> Exercises</H3>
<P><TABLE BORDER="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q01"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a01">5.1</A></B></TD><TD><P class="docText">Build the TCP server from <A class="docLink" HREF="0131411551_ch05lev1sec2.html#ch05fig02">Figures 5.2</A> and <A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig03">5.3</A> and the TCP client from <A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig04">Figures 5.4</A> and <A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">5.5</A>. Start the server and then start the client. Type in a few lines to verify that the client and server work. Terminate the client by typing your EOF character and note the time. Use <TT>netstat</TT> on the client host to verify that the client's end of the connection goes through the TIME_WAIT state. Execute <TT>netstat</TT> every five seconds or so to see when the TIME_WAIT state ends. What is the MSL for this implementation?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q02"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a02">5.2</A></B></TD><TD><P class="docText">What happens with our echo client/server if we run the client and redirect standard input to a binary file?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q03"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a03">5.3</A></B></TD><TD><P class="docText">What is the difference between our echo client/server and using the Telnet client to communicate with our echo server?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q04"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a04">5.4</A></B></TD><TD><P class="docText">In our example in <A class="docLink" HREF="0131411551_ch05lev1sec12.html#ch05lev1sec12">Section 5.12</A>, we verified that the first two segments of the connection termination are sent (the FIN from the server that is then ACKed by the client) by looking at the socket states using <TT>netstat</TT>. Are the final two segments exchanged (a FIN from the client that is ACKed by the server)? If so, when, and if not, why?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q05"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a05">5.5</A></B></TD><TD><P class="docText">What happens in the example outlined in <A class="docLink" HREF="0131411551_ch05lev1sec14.html#ch05lev1sec14">Section 5.14</A> if between Steps 2 and 3 we restart our server application on the server host?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q06"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a06">5.6</A></B></TD><TD><P class="docText">To verify what we claimed happens with <TT>SIGPIPE</TT> in <A class="docLink" HREF="0131411551_ch05lev1sec13.html#ch05lev1sec13">Section 5.13</A>, modify <A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig04">Figure 5.4</A> as follows: Write a signal handler for <TT>SIGPIPE</TT> that just prints a message and returns. Establish this signal handler before calling <TT>connect</TT>. Change the server's port number to 13, the daytime server. When the connection is established, <TT>sleep</TT> for two seconds, <TT>write</TT> a few bytes to the socket, <TT>sleep</TT> for another two seconds, and <TT>write</TT> a few more bytes to the socket. Run the program. What happens?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q07"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a07">5.7</A></B></TD><TD><P class="docText">What happens in <A class="docLink" HREF="0131411551_ch05lev1sec17.html#ch05fig15">Figure 5.15</A> if the IP address of the server host that is specified by the client in its call to <TT>connect</TT> is the IP address associated with the rightmost datalink on the server, instead of the IP address associated with the leftmost datalink on the server?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q08"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a08">5.8</A></B></TD><TD><P class="docText">In our example output from <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig20">Figure 5.20</A>, when the client and server were on different endian systems, the example worked for small positive numbers, but not for small negative numbers. Why? (<span class="docEmphasis">Hint</span>: Draw a picture of the values exchanged across the socket, similar to <A class="docLink" HREF="0131411551_ch03lev1sec4.html#ch03fig09">Figure 3.9</A>.)</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q09"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a09">5.9</A></B></TD><TD><P class="docText">In our example in <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig19">Figures 5.19</A> and <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig20">5.20</A>, can we solve the byte ordering problem by having the client convert the two arguments into network byte order using <TT>htonl</TT>, having the server then call <TT>ntohl</TT> on each argument before doing the addition, and then doing a similar conversion on the result?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q10"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a10">5.10</A></B></TD><TD><P class="docText">What happens in <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig19">Figures 5.19</A> and <A class="docLink" HREF="0131411551_ch05lev1sec18.html#ch05fig20">5.20</A> if the client is on a SPARC that stores a <TT>long</TT> in 32 bits, but the server is on a Digital Alpha that stores a <TT>long</TT> in 64 bits? Does this change if the client and server are swapped between these two hosts?</P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch05q11"></A><B><A class="docLink" HREF="0131411551_app05lev1sec5.html#ch05a11">5.11</A></B></TD><TD><P class="docText">In <A class="docLink" HREF="0131411551_ch05lev1sec17.html#ch05fig15">Figure 5.15</A>, we say that the client IP address is chosen by IP based on routing. What does this mean?</P></TD></TR></TABLE></P><br>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec19.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch06.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
