<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="19.5 Dynamically Maintaining SAs"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch19lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch19lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch19lev1sec5"></A>
<H3 class="docSection1Title">19.5 Dynamically Maintaining SAs</H3>
<P class="docText">For greater security, periodic rekeying is required. This is usually performed by a protocol such as IKE (RFC 2409 [Harkins and Carrel 1998]).</P>
<blockquote>
<p class="docText">As of this writing, the IETF IPsec working group is working on a replacement for IKE.</p>
</blockquote>
<P class="docText">To learn when an SA is required between a new pair of hosts, a daemon registers itself with the kernel using the <TT>SADB_REGISTER</TT> message, specifying the type of SA it can handle in the <TT>sadb_msg_satype</TT> field from the values in <A class="docLink" HREF="0131411551_ch19lev1sec2.html#ch19fig03">Figure 19.3</A>. If a daemon can handle multiple SA types, it sends multiple <TT>SADB_REGISTER</TT> messages, each registering a single type. In its <TT>SADB_REGISTER</TT> reply message, the kernel includes a supported algorithms extension, indicating what encryption and/or authentication mechanisms are supported with what key lengths. The supported algorithms extension is described by an <TT>sadb_supported</TT> structure, shown in <A class="docLink" HREF="#ch19fig13">Figure 19.13</A>; it simply contains a series of encryption or authentication algorithm descriptions in <TT>sadb_alg</TT> structures following the extension header.</P>

<H5 class="docExampleTitle"><A NAME="ch19fig13"></A>Figure 19.13 Supported algorithms extension.</H5>

<PRE>
struct sadb_supported {
  u_int16_t sadb_supported_len;      /* length of extension + algorithms / 8 */
  u_int16_t sadb_supported_exttype;  /* SADB_EXT_SUPPORTED_{AUTH, ENCRYPT} */
  u_int32_t sadb_supported_reserved; /* reserved for future expansion */
};
                                     /* followed by algorithm list */

struct sadb_alg {
  u_int8_t sadb_alg_id;              /* algorithm ID from <A class="docLink" HREF="0131411551_ch19lev1sec4.html#ch19fig08">Figure 19.8</A> */
  u_int8_t sadb_alg_ivlen;           /* IV length, or zero */
  u_int16_t sadb_alg_minbits;        /* minimum key length */
  u_int16_t sadb_alg_maxbits;        /* maximum key length */
  u_int16_t sadb_alg_reserved;       /* reserved for future expansion */
};
</PRE>

<P class="docText">One <TT>sadb_alg</TT> structure follows the <TT>sadb_supported</TT> extension header for each algorithm supported by the system. <A class="docLink" HREF="#ch19fig14">Figure 19.14</A> shows a possible reply to a message registering for SA type <TT>SADB_SATYPE_ESP</TT>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch19fig14"></A>Figure 19.14. Data returned from kernel for <TT>SADB_REGISTER</TT> command.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="534" src="FILES/19fig14.gif" ALT="graphics/19fig14.gif"></p>

</CENTER>
<P class="docText">Our first example program, shown in <A class="docLink" HREF="#ch19fig15">Figure 19.15</A>, simply registers with the kernel for a given mechanism and prints the supported algorithms reply.</P>

<H5 class="docExampleTitle"><A NAME="ch19fig15"></A>Figure 19.15 Program to register on key management socket.</H5>
<P class="docText"><span class="docEmphasis">key/register.c</span></P>

<PRE>
 1 void
 2 sadb_register(int type)
 3 {
 4     int     s;
 5     char    buf[4096];         /* XXX */
 6     struct sadb_msg msg;
 7     int     goteof;
 8     int     mypid;

 9     s = Socket(PF_KEY, SOCK_RAW, PF_KEY_V2);

10     mypid = getpid();

11     /* Build and write SADB_REGISTER request */
12     bzero(&amp;msg, sizeof(msg));
13     msg.sadb_msg_version = PF_KEY_V2;
14     msg.sadb_msg_type = SADB_REGISTER;
15     msg.sadb_msg_satype = type;
16     msg.sadb_msg_len = sizeof(msg) / 8;
17     msg.sadb_msg_pid = mypid;
18     printf("Sending message:\n");
19     print_sadb_msg(&amp;msg, sizeof(msg));
20     Write(s, &amp;msg, sizeof(msg));

21     printf("\nReply returned:\n");
22     /* Read and print SADB_REGISTER reply, discarding any others */
23     for ( ; ; ) {
24         int     msglen;
25         struct sadb_msg *msgp;

26         msglen = Read(s, &amp;buf, sizeof(buf));
27         msgp = (struct sadb_msg *) &amp;buf;
28         if (msgp-&gt;sadb_msg_pid == mypid &amp;&amp;
29            msgp-&gt;sadb_msg_type == SADB_REGISTER) {
30            print_sadb_msg(msgp, msglen);
31            break;
32         }
33     }
34     close(s);
35 }
</PRE>

<A NAME="ch19lev3sec16"></A>
<H4 class="docSection2Title"> Open <TT>PF_KEY</TT> socket</H4>
<p class="docText"><span class="docEmphasis"><TT>1–9</TT></span> We open the <TT>PF_KEY</TT> socket.</p>

<A NAME="ch19lev3sec17"></A>
<H4 class="docSection2Title"> Store PID</H4>
<p class="docText"><span class="docEmphasis"><TT>10</TT></span> Since messages will be addressed to us using our PID, we store it for comparison later.</p>

<A NAME="ch19lev3sec18"></A>
<H4 class="docSection2Title"> Create <TT>SADB_REGISTER</TT> message</H4>
<p class="docText"><span class="docEmphasis"><TT>11–17</TT></span> Just like <TT>SADB_DUMP</TT>, the <TT>SADB_REGISTER</TT> message does not require any extensions. We zero out the message and then fill in the individual fields needed.</p>

<A NAME="ch19lev3sec19"></A>
<H4 class="docSection2Title"> Display and write message to socket</H4>
<p class="docText"><span class="docEmphasis"><TT>18–20</TT></span> We display the message that we're sending using our <TT>print_sadb_msg</TT> function, and send the message to the socket.</p>

<A NAME="ch19lev3sec20"></A>
<H4 class="docSection2Title"> Wait for reply</H4>
<p class="docText"><span class="docEmphasis"><TT>23–33</TT></span> We read messages from the socket and wait for the reply to our register message. The reply is addressed to our PID and is a <TT>SADB_REGISTER</TT> message. It contains a list of supported algorithms, which we print with our <TT>print_sadb_msg</TT> function.</p>

<A NAME="ch19lev2sec3"></A>
<H4 class="docSection2Title"> Example</H4>
<P class="docText">We run the <TT>register</TT> program on a system that supports several more protocols than are described in RFC 2367.</P>
<pre>

</pre><pre>
macosx % <span class="docEmphStrong">register -t ah</span>
Sending register message:
SADB Message Register, errno 0, satype IPsec AH, seq 0, pid 20746

Reply returned:
SADB Message Register, errno 0, satype IPsec AH, seq 0, pid 20746
 Supported authentication algorithms:
  HMAC-MD5 ivlen 0 bits 128-128
  HMAC-SHA-1 ivlen 0 bits 160-160
  Keyed MD5 ivlen 0 bits 128-128
  Keyed SHA-1 ivlen 0 bits 160-160
  Null ivlen 0 bits 0-2048
  SHA2-256 ivlen 0 bits 256-256
  SHA2-384 ivlen 0 bits 384-384
  SHA2-512 ivlen 0 bits 512-512
 Supported encryption algorithms:
  DES-CBC ivlen 8 bits 64-64
  3DES-CBC ivlen 8 bits 192-192
  Null ivlen 0 bits 0-2048
  Blowfish-CBC ivlen 8 bits 40-448
  CAST128-CBC ivlen 8 bits 40-128
  AES ivlen 16 bits 128-256
</pre><pre>
</pre>
<P class="docText">When the kernel needs to communicate with a peer and policy says that an SA is required but one is not available, the kernel sends an <TT>SADB_ACQUIRE</TT> message to key management sockets that have registered the SA type required, containing a proposal extension describing the kernel's proposed algorithms and key lengths. The proposal may be a combination of what is supported by the system and preconfigured policy that limits what is permitted for this communication. The proposal is a list of algorithms, key lengths, and lifetimes, in order of preference. When a key management daemon receives an <TT>SADB_ACQUIRE</TT> message, it performs the acts required to choose a key that fits one of the kernel's proposed combinations, and installs this key in the kernel. It uses the <TT>SADB_GETSPI</TT> message to ask the kernel to select an SPI from a desired range. The kernel's response to the <TT>SADB_GETSPI</TT> message includes creating an SA in the larval state. The daemon then negotiates security parameters with the remote end using the SPI supplied by the kernel, and uses the <TT>SADB_UPDATE</TT> message to complete the SA and cause it to enter the mature state. Dynamically created SAs generally have both a soft and a hard lifetime associated with them. When either lifetime expires, the kernel sends an <TT>SADB_EXPIRE</TT> message, indicating whether the soft or hard lifetime has expired. If the soft lifetime has expired, the SA has entered the dying state, during which it can still be used but a new SA must be obtained. If the hard lifetime has expired, the SA has entered the dead state, in which it is no longer used for security purposes and will be removed from the SADB.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch19lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch19lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
