<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.5 'listen' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch04lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch04lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch04lev1sec5"></A>
<H3 class="docSection1Title">4.5 <TT>listen</TT> Function</H3>
<P class="docText">The <TT>listen</TT> function is called only by a TCP server and it performs two actions:</P>
<A NAME="ch04pro02"></A>


<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">When a socket is created by the <TT>socket</TT> function, it is assumed to be an active socket, that is, a client socket that will issue a <TT>connect</TT>. The <TT>listen</TT> function converts an unconnected socket into a passive socket, indicating that the kernel should accept incoming connection requests directed to this socket. In terms of the TCP state transition diagram (<A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig04">Figure 2.4</A>), the call to <TT>listen</TT> moves the socket from the CLOSED state to the LISTEN state.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">The second argument to this function specifies the maximum number of connections the kernel should queue for this socket.</P>
</span></LI></OL></span>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/socket.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#int listen (int</TT> <span class="docEmphasis">sockfd</span>, <TT>int</TT> <span class="docEmphasis">backlog</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK, -1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">This function is normally called after both the <TT>socket</TT> and <TT>bind</TT> functions and must be called before calling the <TT>accept</TT> function.</P>
<P class="docText">To understand the <span class="docEmphasis">backlog</span> argument, we must realize that for a given listening socket, the kernel maintains two queues:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">An <span class="docEmphasis">incomplete connection queue</span>, which contains an entry for each SYN that has arrived from a client for which the server is awaiting completion of the TCP three-way handshake. These sockets are in the SYN_RCVD state (<A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig04">Figure 2.4</A>).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A <span class="docEmphasis">completed connection queue</span>, which contains an entry for each client with whom the TCP three-way handshake has completed. These sockets are in the ESTABLISHED state (<A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig04">Figure 2.4</A>).</P></span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="#ch04fig07">Figure 4.7</A> depicts these two queues for a given listening socket.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig07"></A>Figure 4.7. The two queues maintained by TCP for a listening socket.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="274" src="FILES/04fig07.gif" ALT="graphics/04fig07.gif"></p>

</CENTER>
<P class="docText">When an entry is created on the incomplete queue, the parameters from the listen socket are copied over to the newly created connection. The connection creation mechanism is completely automatic; the server process is not involved. <A class="docLink" HREF="#ch04fig08">Figure 4.8</A> depicts the packets exchanged during the connection establishment with these two queues.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig08"></A>Figure 4.8. TCP three-way handshake and the two queues for a listening socket.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="194" src="FILES/04fig08.gif" ALT="graphics/04fig08.gif"></p>

</CENTER>
<P class="docText">When a SYN arrives from a client, TCP creates a new entry on the incomplete queue and then responds with the second segment of the three-way handshake: the server's SYN with an ACK of the client's SYN (<A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02lev1sec6">Section 2.6</A>). This entry will remain on the incomplete queue until the third segment of the three-way handshake arrives (the client's ACK of the server's SYN), or until the entry times out. (Berkeley-derived implementations have a timeout of 75 seconds for these incomplete entries.) If the three-way handshake completes normally, the entry moves from the incomplete queue to the end of the completed queue. When the process calls <TT>accept</TT>, which we will describe in the next section, the first entry on the completed queue is returned to the process, or if the queue is empty, the process is put to sleep until an entry is placed onto the completed queue.</P>
<P class="docText">There are several points to consider regarding the handling of these two queues.</P>
<UL><LI><P class="docList">The <span class="docEmphasis">backlog</span> argument to the <TT>listen</TT> function has historically specified the maximum value for the sum of both queues.</P><BLOCKQUOTE><P><P class="docList">There has never been a formal definition of what the <span class="docEmphasis">backlog</span> means. The 4.2BSD man page says that it "defines the maximum length the queue of pending connections may grow to." Many man pages and even the POSIX specification copy this definition verbatim, but this definition does not say whether a pending connection is one in the SYN_RCVD state, one in the ESTABLISHED state that has not yet been accepted, or either. The historical definition in this bullet is the Berkeley implementation, dating back to 4.2BSD, and copied by many others.</P></P></BLOCKQUOTE></LI><LI><P class="docList">Berkeley-derived implementations add a fudge factor to the <span class="docEmphasis">backlog</span>: It is multiplied by 1.5 (p. 257 of TCPv1 and p. 462 of TCPV2). For example, the commonly specified <span class="docEmphasis">backlog</span> of 5 really allows up to 8 queued entries on these systems, as we show in <A class="docLink" HREF="#ch04fig10">Figure 4.10</A>.</P><BLOCKQUOTE><P><P class="docList">The reason for adding this fudge factor appears lost to history [Joy 1994]. But if we consider the <span class="docEmphasis">backlog</span> as specifying the maximum number of completed connections that the kernel will queue for a socket ([Borman 1997b], as discussed shortly), then the reason for the fudge factor is to take into account incomplete connections on the queue.</P></P></BLOCKQUOTE></LI><LI><P class="docList">Do not specify a <span class="docEmphasis">backlog</span> of 0, as different implementations interpret this differently (<A class="docLink" HREF="#ch04fig10">Figure 4.10</A>). If you do not want any clients connecting to your listening socket, close the listening socket.</P></LI><LI><P class="docList">Assuming the three-way handshake completes normally (i.e., no lost segments and no retransmissions), an entry remains on the incomplete connection queue for one RTT, whatever that value happens to be between a particular client and server. Section 14.4 of TCPv3 shows that for one Web server, the median RTT between many clients and the server was 187 ms. (The median is often used for this statistic, since a few large values can noticeably skew the mean.)</P></LI><LI><P class="docList">Historically, sample code always shows a <span class="docEmphasis">backlog</span> of 5, as that was the maximum value supported by 4.2BSD. This was adequate in the 1980s when busy servers would handle only a few hundred connections per day. But with the growth of the World Wide Web (WWW), where busy servers handle millions of connections per day, this small number is completely inadequate (pp. 187–192 of TCPv3). Busy HTTP servers must specify a much larger <span class="docEmphasis">backlog</span>, and newer kernels must support larger values.</P><BLOCKQUOTE><P><P class="docList">Many current systems allow the administrator to modify the maximum value for the <span class="docEmphasis">backlog</span>.</P></P></BLOCKQUOTE></LI><LI><P class="docList">A problem is: What value should the application specify for the <span class="docEmphasis">backlog</span>, since 5 is often inadequate? There is no easy answer to this. HTTP servers now specify a larger value, but if the value specified is a constant in the source code, to increase the constant requires recompiling the server. Another method is to assume some default but allow a command-line option or an environment variable to override the default. It is always acceptable to specify a value that is larger than supported by the kernel, as the kernel should silently truncate the value to the maximum value that it supports, without returning an error (p. 456 of TCPv2).</P><P class="docList">We can provide a simple solution to this problem by modifying our wrapper function for the <TT>listen</TT> function. <A class="docLink" HREF="#ch04fig09">Figure 4.9</A> shows the actual code. We allow the environment variable <TT>LISTENQ</TT> to override the value specified by the caller.</P>
<H5 class="docExampleTitle"><A NAME="ch04fig09"></A>Figure 4.9 Wrapper function for <TT>listen</TT> that allows an environment variable to specify <span class="docEmphasis">backlog</span>.</H5>
<P class="docText"><span class="docEmphasis">lib/wrapsock.c</span></P>

<PRE>
137 void
138 Listen (int fd, int backlog)
139 {
140     char    *ptr;

141         /* can override 2nd argument with environment variable */
142     if ( (ptr = getenv("LISTENQ")) != NULL)
143         backlog = atoi (ptr);

144     if (listen (fd, backlog) &lt; 0)
145         err_sys ("listen error");
146 }
</PRE>
</LI></UL>
<UL><LI><P class="docList">Manuals and books have historically said that the reason for queuing a fixed number of connections is to handle the case of the server process being busy between successive calls to <TT>accept</TT>. This implies that of the two queues, the completed queue should normally have more entries than the incomplete queue. Again, busy Web servers have shown that this is false. The reason for specifying a large <span class="docEmphasis">backlog</span> is because the incomplete connection queue can grow as client SYNs arrive, waiting for completion of the three-way handshake.</P></LI><LI><P class="docList">If the queues are full when a client SYN arrives, TCP ignores the arriving SYN (pp. 930–931 of TCPv2); it does not send an RST. This is because the condition is considered temporary, and the client TCP will retransmit its SYN, hopefully finding room on the queue in the near future. If the server TCP immediately responded with an RST, the client's <TT>connect</TT> would return an error, forcing the application to handle this condition instead of letting TCP's normal retransmission take over. Also, the client could not differentiate between an RST in response to a SYN meaning "there is no server at this port" versus "there is a server at this port but its queues are full."</P><BLOCKQUOTE><P><P class="docList">Some implementations do send an RST when the queue is full. This behavior is incorrect for the reasons stated above, and unless your client specifically needs to interact with such a server, it's best to ignore this possibility. Coding to handle this case reduces the robustness of the client and puts more load on the network in the normal RST case, where the port really has no server listening on it.</P></P></BLOCKQUOTE></LI></UL>
<UL><LI><P class="docList">Data that arrives after the three-way handshake completes, but before the server calls <TT>accept</TT>, should be queued by the server TCP, up to the size of the connected socket's receive buffer.</P></LI></UL>
<P class="docText"><A class="docLink" HREF="#ch04fig10">Figure 4.10</A> shows the actual number of queued connections provided for different values of the <span class="docEmphasis">backlog</span> argument for the various operating systems in <A class="docLink" HREF="0131411551_ch01lev1sec9.html#ch01fig16">Figure 1.16</A>. For seven different operating systems there are five distinct columns, showing the variety of interpretations about what <span class="docEmphasis">backlog</span> means!</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig10"></A>Figure 4.10. Actual number of queued connections for values of <span class="docEmphasis">backlog</span>.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="494" HEIGHT="283" src="FILES/04fig10.gif" ALT="graphics/04fig10.gif"></p>

</CENTER>
<P class="docText">AIX and MacOS have the traditional Berkeley algorithm, and Solaris seems very close to that algorithm as well. FreeBSD just adds one to <span class="docEmphasis">backlog</span>.</P>
<BLOCKQUOTE><P><P class="docList">The program to measure these values is shown in the solution for <A class="docLink" HREF="0131411551_ch15lev1sec10.html#ch15lev1sec10">Exercise 15.4</A>.</P></P><P><P class="docList">As we said, historically the <span class="docEmphasis">backlog</span> has specified the maximum value for the sum of both queues. During 1996, a new type of attack was launched on the Internet called <span class="docEmphasis">SYN flooding</span> [CERT 1996b]. The hacker writes a program to send SYNs at a high rate to the victim, filling the incomplete connection queue for one or more TCP ports. (We use the term <span class="docEmphasis">hacker</span> to mean the attacker, as described in [Cheswick, Bellovin, and Rubin 2003].) Additionally, the source IP address of each SYN is set to a random number (this is called <span class="docEmphasis">IP spoofing</span>) so that the server's SYN/ACK goes nowhere. This also prevents the server from knowing the real IP address of the hacker. By filling the incomplete queue with bogus SYNs, legitimate SYNs are not queued, providing a <span class="docEmphasis">denial of service</span> to legitimate clients. There are two commonly used methods of handling these attacks, summarized in [Borman 1997b]. But what is most interesting in this note is revisiting what the <TT>listen</TT> <span class="docEmphasis">backlog</span> really means. It should specify the maximum number of <span class="docEmphasis">completed</span> connections for a given socket that the kernel will queue. The purpose of having a limit on these completed connections is to stop the kernel from accepting new connection requests for a given socket when the application is not accepting them (for whatever reason). If a system implements this interpretation, as does BSD/OS 3.0, then the application need not specify huge <span class="docEmphasis">backlog</span> values just because the server handles lots of client requests (e.g., a busy Web server) or to provide protection against SYN flooding. The kernel handles lots of incomplete connections, regardless of whether they are legitimate or from a hacker. But even with this interpretation, scenarios do occur where the traditional value of 5 is inadequate.</P></P></BLOCKQUOTE>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch04lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch04lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
