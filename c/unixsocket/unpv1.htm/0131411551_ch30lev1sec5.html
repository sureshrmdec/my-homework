<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="30.5 TCP Concurrent Server, One Child per Client"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch30lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch30lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch30lev1sec5"></A>
<H3 class="docSection1Title">30.5 TCP Concurrent Server, One Child per Client</H3>
<P class="docText">Traditionally, a concurrent TCP server calls <TT>fork</TT> to spawn a child to handle each client. This allows the server to handle numerous clients at the same time, one client per process. The only limit on the number of clients is the OS limit on the number of child processes for the user ID under which the server is running. <A class="docLink" HREF="0131411551_ch05lev1sec10.html#ch05fig12">Figure 5.12</A> is an example of a concurrent server and most TCP servers are written in this fashion.</P>
<P class="docText">The problem with these concurrent servers is the amount of CPU time it takes to <TT>fork</TT> a child for each client. Years ago (the late 1980s), when a busy server handled hundreds or perhaps even a few thousand clients per day, this was acceptable. But the explosion of the Web has changed this attitude. Busy Web servers measure the number of TCP connections per day in the millions. This is for an individual host, and the busiest sites run multiple hosts, distributing the load among the hosts. (Section 14.2 of TCPv3 talks about a common way to distribute this load using what is called "DNS round robin.") Later sections will describe various techniques that avoid the per-client <TT>fork</TT> incurred by a concurrent server, but concurrent servers are still common.</P>
<P class="docText"><A class="docLink" HREF="#ch30fig04">Figure 30.4</A> shows the <TT>main</TT> function for our concurrent TCP server.</P>

<H5 class="docExampleTitle"><A NAME="ch30fig04"></A>Figure 30.4 <TT>main</TT> function for TCP concurrent server.</H5>
<P class="docText"><span class="docEmphasis">server/serv01.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd;
 6     pid_t   childpid;
 7     void    sig_chld(int), sig_int(int), web_child(int);
 8     socklen_t clilen, addrlen;
 9     struct sockaddr *cliaddr;

10     if (argc == 2)
11         listenfd = Tcp_listen(NULL, argv[1], &amp;addrlen);
12     else if (argc == 3)
13         listenfd = Tcp_listen(argv[1], argv[2], &amp;addrlen);
14     else
15         err_quit("usage: serv01 [ &lt;host&gt; ] &lt;port#&gt;");
16     cliaddr = Malloc(addrlen);

17     Signal(SIGCHLD, sig_chld);
18     Signal(SIGINT, sig_int);

19     for ( ; ; ) {
20         clilen = addrlen;
21         if  ( (connfd = accept(listenfd, cliaddr, &amp;clilen)) &lt; 0) {
22              if (errno == EINTR)
23                  continue;      /* back to for() */
24              else
25                  err_sys("accept error");
26         }

27         if ( (childpid = Fork()) == 0) { /* child process */
28             Close(listenfd);     /* close listening socket */
29             web_child(connfd);   /* process request */
30             exit(0);
31         }
32         Close(connfd);            /* parent closes connected socket */
33     }
34 }
</PRE>

<P class="docText">This function is similar to <A class="docLink" HREF="0131411551_ch05lev1sec10.html#ch05fig12">Figure 5.12</A>: It calls <TT>fork</TT> for each client connection and handles the <TT>SIGCHLD</TT> signals from the terminating children. This function, however, we have made protocol-independent by calling our <TT>tcp_listen</TT> function. We do not show the <TT>sig_chld</TT> signal handler: It is the same as <A class="docLink" HREF="0131411551_ch05lev1sec10.html#ch05fig11">Figure 5.11</A>, with the <TT>printf</TT> removed.</P>
<P class="docText">We also catch the <TT>SIGINT</TT> signal, generated when we type our terminal interrupt key. We type this key after the client completes, to print the CPU time required for the program. <A class="docLink" HREF="#ch30fig05">Figure 30.5</A> shows the signal handler. This is an example of a signal handler that does not return.</P>

<H5 class="docExampleTitle"><A NAME="ch30fig05"></A>Figure 30.5 Signal handler for <TT>SIGINT</TT>.</H5>
<P class="docText"><span class="docEmphasis">server/serv01.c</span></P>

<PRE>
35 void
36 sig_int(int signo)
37 {
38     void    pr_cpu_time(void);

39     pr_cpu_time();
40     exit(0);
41 }
</PRE>

<P class="docText"><A class="docLink" HREF="#ch30fig06">Figure 30.6</A> shows the <TT>pr_cpu_time</TT> function that is called by the signal handler.</P>

<H5 class="docExampleTitle"><A NAME="ch30fig06"></A>Figure 30.6 <TT>pr_cpu_time</TT> function: prints total CPU time.</H5>
<P class="docText"><span class="docEmphasis">server/pr_cpu_time.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 #include    &lt;sys/resource.h&gt;

 3 #ifndef HAVE_GETRUSAGE_PROTO
 4 int     getrusage(int, struct rusage *);
 5 #endif

 6 void
 7 pr_cpu_time(void)
 8 {
 9     double user, sys;
10     struct rusage myusage, childusage;

11     if (getrusage(RUSAGE_SELF, &amp;myusage) &lt; 0)
12         err_sys("getrusage error");
13     if (getrusage(RUSAGE_CHILDREN, &amp;childusage) &lt; 0)
14         err_sys("getrusage error");

15     user = (double) myusage.ru_utime.tv_sec +
16         myusage.ru_utime.tv_usec / 1000000.0;
17     user += (double) childusage.ru_utime.tv_sec +
18         childusage.ru_utime.tv_usec / 1000000.0;
19     sys = (double) myusage.ru_stime.tv_sec +
20         myusage.ru_stime.tv_usec / 1000000.0;
21     sys += (double) childusage.ru_stime.tv_sec +
22         childusage.ru_stime.tv_usec / 1000000.0;

23     printf("\nuser time = %g, sys time = %g\n", user, sys);
24 }
</PRE>

<P class="docText">The <TT>getrusage</TT> function is called twice to return the resource utilization of both the calling process (<TT>RUSAGE_SELF</TT>) and all the terminated children of the calling process (<TT>RUSAGE_CHILDREN</TT>). The values printed are the total user time (CPU time spent in the user process) and total system time (CPU time spent within the kernel, executing on behalf of the calling process).</P>
<P class="docText">The <TT>main</TT> function in <A class="docLink" HREF="#ch30fig04">Figure 30.4</A> calls the function <TT>web_child</TT> to handle each client request. <A class="docLink" HREF="#ch30fig07">Figure 30.7</A> shows this function.</P>

<H5 class="docExampleTitle"><A NAME="ch30fig07"></A>Figure 30.7 <TT>web_child</TT> function to handle each client's request.</H5>
<P class="docText"><span class="docEmphasis">server/web_child.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 #define MAXN    16384     /* max # bytes client can request */

 3 void
 4 web_child(int sockfd)
 5 {
 6     int     ntowrite;
 7     ssize_t nread;
 8     char    line[MAXLINE], result[MAXN];

 9     for ( ; ; ) {
10         if ( (nread = Readline(sockfd, line, MAXLINE)) == 0)
11             return;             /* connection closed by other end */

12             /* line from client specifies #bytes to write back */
13         ntowrite = atol(line);
14         if ((ntowrite &lt;= 0) || (ntowrite &gt; MAXN))
15             err_quit("client request for %d bytes", ntowrite);

16         Writen(sockfd, result, ntowrite);
17     }
18 }
</PRE>

<P class="docText">After the client establishes the connection with the server, the client writes a single line specifying the number of bytes the server must return to the client. This is some-what similar to HTTP: The client sends a small request and the server responds with the desired information (often an HTML file or a GIF image, for example). In the case of HTTP, the server normally closes the connection after sending back the requested data, although newer versions are using <span class="docEmphasis">persistent connections</span>, holding the TCP connection open for additional client requests. In our <TT>web_child</TT> function, the server allows additional requests from the client, but we saw in <A class="docLink" HREF="0131411551_ch30lev1sec3.html#ch30fig03">Figure 30.3</A> that our client sends only one request per connection and the client then closes the connection.</P>
<P class="docText">Row 1 of <A class="docLink" HREF="0131411551_ch30lev1sec1.html#ch30fig01">Figure 30.1</A> shows the timing result for this concurrent server. When compared to the subsequent lines in this figure, we see that the concurrent server requires the most CPU time, which is what we expect with one <TT>fork</TT> per client.</P>
<BLOCKQUOTE><P><P class="docList">One server design that we do not measure in this chapter is one invoked by <TT>inetd</TT>, which we covered in <A class="docLink" HREF="0131411551_ch13lev1sec5.html#ch13lev1sec5">Section 13.5</A>. From a process control perspective, a server invoked by <TT>inetd</TT> involves a <TT>fork</TT> and an <TT>exec</TT>, so the CPU time will be even greater than the times shown in row 1 of <A class="docLink" HREF="0131411551_ch30lev1sec1.html#ch30fig01">Figure 30.1</A>.</P></P></BLOCKQUOTE>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch30lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch30lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
