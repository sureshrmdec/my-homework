<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="30.1 Introduction"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch30.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch30lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch30lev1sec1"></A>
<H3 class="docSection1Title">30.1 Introduction</H3>
<P class="docText">We have several choices for the type of process control to use when writing a Unix server:</P>
<UL><LI><P class="docList">Our first server, <A class="docLink" HREF="0131411551_ch01lev1sec5.html#ch01fig09">Figure 1.9</A>, was an <span class="docEmphasis">iterative server</span>, but there are a limited number of scenarios where this is recommended because the server cannot process a pending client until it has completely serviced the current client.</P></LI><LI><P class="docList"><A class="docLink" HREF="0131411551_ch05lev1sec2.html#ch05fig02">Figure 5.2</A> was our first <span class="docEmphasis">concurrent server</span> and it called <TT>fork</TT> to spawn a child process for every client. Traditionally, most Unix servers fall into this category.</P></LI><LI><P class="docList">In <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06lev1sec8">Section 6.8</A>, we developed a different version of our TCP server consisting of a single process using <TT>select</TT> to handle any number of clients.</P></LI><LI><P class="docList">In <A class="docLink" HREF="0131411551_ch26lev1sec4.html#ch26fig03">Figure 26.3</A>, we modified our concurrent server to create one thread per client instead of one process per client.</P></LI></UL>
<P class="docText">There are two other modifications to the concurrent server design that we will look at in this chapter:</P>
<UL><LI><P class="docList"><span class="docEmphasis">Preforking</span> has the server call <TT>fork</TT> when it starts, creating a pool of child processes. One process from the currently available pool handles each client request.</P></LI><LI><P class="docList"><span class="docEmphasis">Prethreading</span> has the server create a pool of available threads when it starts, and one thread from the pool handles each client.</P></LI></UL>
<P class="docText">There are numerous details with preforking and prethreading that we will examine in this chapter: What if there are not enough processes or threads in the pool? What if there are too many processes or threads in the pool? How can the parent and its children or threads synchronize with each other?</P>
<P class="docText">Clients are typically easier to write than servers because there is less process control in a client. Nevertheless, we have already examined various ways to write our simple echo client and we summarize these in <A class="docLink" HREF="0131411551_ch30lev1sec2.html#ch30lev1sec2">Section 30.2</A>.</P>
<P class="docText">In this chapter, we will look at nine different server designs and we will run each server against the same client. Our client/server scenario is typical of the Web: The client sends a small request to the server and the server responds with data back to the client. Some of the servers we have already discussed in detail (e.g., the concurrent server with one <TT>fork</TT> per client), while the preforked and prethreaded servers are new and therefore discussed in detail in this chapter.</P>
<P class="docText">We will run multiple instances of a client against each server, measuring the CPU time required to service a fixed number of client requests. Instead of scattering all our CPU timings throughout the chapter, we summarize them in <A class="docLink" HREF="#ch30fig01">Figure 30.1</A> and refer to this figure throughout the chapter. We note that the times in this figure measure the CPU time required <span class="docEmphasis">only for process control</span> and the iterative server is our baseline we subtract from actual CPU time because an iterative server has no process control overhead. We include the baseline time of 0.0 in this figure to reiterate this point. We use the term <span class="docEmphasis">process control CPU time</span> in this chapter to denote this difference from the baseline for a given system.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch30fig01"></A>Figure 30.1. Timing comparisons of the various servers discussed in this chapter.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="163" src="FILES/30fig01.gif" ALT="graphics/30fig01.gif"></p>

</CENTER>
<P class="docText">All these server timings were obtained by running the client shown in <A class="docLink" HREF="0131411551_ch30lev1sec3.html#ch30fig03">Figure 30.3</A> on two different hosts on the same subnet as the server. For all tests, both clients spawned five children to create five simultaneous connections to the server, for a maximum of 10 simultaneous connections at the server at any time. Each client requested 4,000 bytes from the server across the connection. For those tests involving a preforked or a prethreaded server, the server created 15 children or 15 threads when it started.</P>
<P class="docText">Some server designs involve creating a pool of child processes or a pool of threads. An item to consider in these cases is the distribution of the client requests to the available pool. <A class="docLink" HREF="#ch30fig02">Figure 30.2</A> summarizes these distributions and we will discuss each column in the appropriate section.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch30fig02"></A>Figure 30.2. Number of clients or threads serviced by each of the 15 children or threads.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="499" HEIGHT="372" src="FILES/30fig02.gif" ALT="graphics/30fig02.gif"></p>

</CENTER>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch30.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch30lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
