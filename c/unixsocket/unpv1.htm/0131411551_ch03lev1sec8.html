<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="3.8 'sock_ntop' and Related Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch03lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch03lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch03lev1sec8"></A>
<H3 class="docSection1Title">3.8 <TT>sock_ntop</TT> and Related Functions</H3>
<P class="docText">A basic problem with <TT>inet_ntop</TT> is that it requires the caller to pass a pointer to a binary address. This address is normally contained in a socket address structure, requiring the caller to know the format of the structure and the address family. That is, to use it, we must write code of the form</P>
<pre>

</pre><pre>
struct sockaddr_in   addr;

inet_ntop(AF_INET, &amp;addr.sin_addr, str, sizeof(str));
</pre><pre>
</pre>
<P class="docText">for IPv4, or</P>
<pre>

</pre><pre>
struct sockaddr_in6   addr6;

inet_ntop(AF_INET6, &amp;addr6.sin6_addr, str, sizeof(str));
</pre><pre>
</pre>
<P class="docText">for IPv6. This makes our code protocol-dependent.</P>
<P class="docText">To solve this, we will write our own function named <TT>sock_ntop</TT> that takes a pointer to a socket address structure, looks inside the structure, and calls the appropriate function to return the presentation format of the address.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include "unp.h"</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>char *sock_ntop(const struct sockaddr *</TT><span class="docEmphasis">sockaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: non-null pointer if OK, <TT>NULL</TT> on error</P></TD></TR></COLGROUP></TABLE></P>
<blockquote>
<p class="docText">This is the notation we use for functions of our own (nonstandard system functions) that we use throughout the book: the box around the function prototype and return value is dashed. The header is included at the beginning is usually our <TT>unp.h</TT> header.</p>
</blockquote>
<P class="docText"><span class="docEmphasis">sockaddr</span> points to a socket address structure whose length is <span class="docEmphasis">addrlen</span>. The function uses its own static buffer to hold the result and a pointer to this buffer is the return value.</P>
<BLOCKQUOTE><P><P class="docList">Notice that using static storage for the result prevents the function from being <span class="docEmphasis">re-entrant</span> or <span class="docEmphasis">thread-safe</span>. We will talk more about this in <A class="docLink" HREF="0131411551_ch11lev1sec18.html#ch11lev1sec18">Section 11.18</A>. We made this design decision for this function to allow us to easily call it from the simple examples in the book.</P></P></BLOCKQUOTE>
<P class="docText">The presentation format is the dotted-decimal form of an IPv4 address or the hex string form of an IPv6 address surrounded by brackets, followed by a terminator (we use a colon, similar to URL syntax), followed by the decimal port number, followed by a null character. Hence, the buffer size must be at least <TT>INET_ADDRSTRLEN</TT> plus 6 bytes for IPv4 (16 + 6 = 22), or <TT>INET6_ADDRSTRLEN</TT> plus 8 bytes for IPv6 (46 + 8 = 54).</P>
<P class="docText">We show the source code for only the <TT>AF_INET case</TT> in <A class="docLink" HREF="#ch03fig14">Figure 3.14</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch03fig14"></A>Figure 3.14 Our <TT>sock_ntop</TT> function.</H5>
<P class="docText"><span class="docEmphasis">lib/sock_ntop.c</span></P>

<PRE>
 5 char *
 6 sock_ntop(const struct sockaddr *sa, socklen_t salen)
 7 {
 8     char    portstr[8];
 9     static char str[128];       /* Unix domain is largest */

10     switch (sa-&gt;sa_family) {
11     case AF_INET:{
12             struct sockaddr_in *sin = (struct sockaddr_in *) sa;

13             if (inet_ntop(AF_INET, &amp;sin-&gt;sin_addr, str, sizeof(str)) == NULL)
14                 return (NULL);
15             if (ntohs(sin-&gt;sin_port) != 0) {
16                 snprintf(portstr, sizeof(portstr), ":%d",
17                          ntohs(sin-&gt;sin_port));
18                 strcat(str, portstr);
19             }
20             return (str);
21        }
</PRE>

<P class="docText">There are a few other functions that we define to operate on socket address structures, and these will simplify the portability of our code between IPv4 and IPv6.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include "unp.h"</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int sock_bind_wild(int</TT> <span class="docEmphasis">sockfd</span>, <TT>int</TT> <span class="docEmphasis">family</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK, -1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int sock_cmp_addr(const struct sockaddr *</TT><span class="docEmphasis">sockaddr1</span>,</P></TD></TR><TR><TD class="docTableCell" align="center" valign="top"><P class="docText"><TT>const struct sockaddr *</TT><span class="docEmphasis">sockaddr2</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if addresses are of the same family and ports are equal, else nonzero</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int sock_cmp_port(const struct sockaddr *</TT><span class="docEmphasis">sockaddr1</span>,</P></TD></TR><TR><TD class="docTableCell" align="center" valign="top"><P class="docText"><TT>const struct sockaddr *</TT><span class="docEmphasis">sockaddr2</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if addresses are of the same family and ports are equal, else nonzero</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int sock_get_port(const struct sockaddr *</TT><span class="docEmphasis">sockaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: non-negative port number for IPv4 or IPv6 address, else -1</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>char *sock_ntop_host(const struct sockaddr *</TT><span class="docEmphasis">sockaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: non-null pointer if OK, <TT>NULL</TT> on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void sock_set_addr(const struct sockaddr *</TT><span class="docEmphasis">sockaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span>, <TT>void *</TT><span class="docEmphasis">ptr</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void sock_set_port(const struct sockaddr *</TT><span class="docEmphasis">sockaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span>, <TT>int</TT> <span class="docEmphasis">port</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void sock_set_wild(struct sockaddr *</TT><span class="docEmphasis">sockaddr</span>, <TT>socklen_t</TT> <span class="docEmphasis">addrlen</span><TT>);</TT></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>sock_bind_wild</TT> binds the wildcard address and an ephemeral port to a socket. <TT>sock_cmp_addr</TT> compares the address portion of two socket address structures, and <TT>sock_cmp_port</TT> compares the port number of two socket address structures. <TT>sock_get_port</TT> returns just the port number, and <TT>sock_ntop_host</TT> converts just the host portion of a socket address structure to presentation format (not the port number). <TT>sock_set_addr</TT> sets just the address portion of a socket address structure to the value pointed to by <span class="docEmphasis">ptr</span>, and <TT>sock_set_port</TT> sets just the port number of a socket address structure. <TT>sock_set_wild</TT> sets the address portion of a socket address structure to the wildcard. As with all the functions in the text, we provide a wrapper function whose name begins with "<TT>S</TT>" for all of these functions that return values other than <TT>void</TT> and normally call the wrapper function from our programs. We do not show the source code for all these functions, but it is freely available (see the Preface).</P>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch03lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch03lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
