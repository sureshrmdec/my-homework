<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="24.2 TCP Out-of-Band Data"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch24lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch24lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch24lev1sec2"></A>
<H3 class="docSection1Title">24.2 TCP Out-of-Band Data</H3>
<P class="docText">TCP does not have true <span class="docEmphasis">out-of-band data</span>. Instead, TCP provides an <span class="docEmphasis">urgent mode</span>. Assume a process has written <span class="docEmphasis">N</span> bytes of data to a TCP socket and that data is queued by TCP in the socket send buffer, waiting to be sent to the peer. We show this in <A class="docLink" HREF="#ch24fig01">Figure 24.1</A> and have labeled the data bytes 1 through <span class="docEmphasis">N</span>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch24fig01"></A>Figure 24.1. Socket send buffer containing data to send.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="330" HEIGHT="117" src="FILES/24fig01.gif" ALT="graphics/24fig01.gif"></p>

</CENTER>
<P class="docText">The process now writes a single byte of out-of-band data, containing the ASCII character <TT>a</TT>, using the <TT>send</TT> function and the <TT>MSG_OOB</TT> flag.</P>
<pre>

</pre><pre>
send(fd, "a", 1, MSG_OOB);
</pre><pre>
</pre>
<P class="docText">TCP places the data in the next available position in the socket send buffer and sets its <span class="docEmphasis">urgent pointer</span> for this connection to be the next available location. We show this in <A class="docLink" HREF="#ch24fig02">Figure 24.2</A> and have labeled the out-of-band byte "OOB."</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch24fig02"></A>Figure 24.2. Socket send buffer after one byte of out-of-band data is written by application.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="330" HEIGHT="136" src="FILES/24fig02.gif" ALT="graphics/24fig02.gif"></p>

</CENTER>
<BLOCKQUOTE><P><P class="docList">TCP's urgent pointer has a sequence number one greater than the byte of data that is written with the <TT>MSG_OOB</TT> flag. As discussed on pp. 292–296 of TCPv1, this is an historical artifact that is now emulated by all implementations. As long as the sending TCP and the receiving TCP agree on the interpretation of TCP's urgent pointer, all is fine.</P></P></BLOCKQUOTE>
<P class="docText">Given the state of the TCP socket send buffer shown in <A class="docLink" HREF="#ch24fig02">Figure 24.2</A>, the next segment sent by TCP will have its URG flag set in the TCP header and the urgent offset field in the TCP header will point to the byte following the out-of-band byte. But this segment may or may not contain the byte that we have labeled as OOB. Whether the OOB byte is sent depends on the number of bytes ahead of it in the socket send buffer, the segment size that TCP is sending to the peer, and the current window advertised by the peer.</P>
<BLOCKQUOTE><P><P class="docList">We have used the terms <span class="docEmphasis">urgent pointer</span> and <span class="docEmphasis">urgent offset</span>. At the TCP level, the two are different. The 16-bit value in the TCP header is called the urgent offset and it must be added to the sequence number field in the header to obtain the 32-bit urgent pointer. TCP looks at the urgent offset only if another bit in the header is set, and this bit is called the <span class="docEmphasis">URG flag</span>. From a programming perspective, we need not worry about this detail and just refer to TCP's urgent pointer.</P></P></BLOCKQUOTE>
<P class="docText">This is an important characteristic of TCP's urgent mode: The TCP header indicates that the sender has entered urgent mode (i.e., the URG flag is set along with the urgent offset), but the actual byte of data referred to by the urgent pointer need not be sent. Indeed, if the sending TCP is stopped by flow control (the receiver's socket receive buffer is full, so its TCP has advertised a window of 0 to the sending TCP), the urgent notification is sent without any data (pp. 1016–1017 of TCPv2), as we will show in <A class="docLink" HREF="0131411551_ch24lev1sec3.html#ch24fig10">Figures 24.10</A> and <A class="docLink" HREF="0131411551_ch24lev1sec3.html#ch24fig11">24.11</A>. This is one reason why applications use TCP's urgent mode (i.e., out-of-band data): The urgent notification is <span class="docEmphasis">always</span> sent to the peer TCP, even if the flow of data is stopped by TCP's flow control.</P>
<P class="docText">What happens if we send multiple bytes of out-of-band data, as in</P>
<pre>

</pre><pre>
send(fd, "abc", 3, MSG_OOB);
</pre><pre>
</pre>
<P class="docText">In this example, TCP's urgent pointer points one beyond the final byte; that is, the final byte (the <TT>c</TT>) is considered the out-of-band byte.</P>
<P class="docText">Now that we have covered the sending of out-of-band data, let's look at it from the receiver's side:</P>
<A NAME="ch24pro01"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">When TCP receives a segment with the URG flag set, the urgent pointer is examined to see whether it refers to <span class="docEmphasis">new</span> out-of-band data, that is, whether this is the first time TCP's urgent mode has referenced this particular byte in the stream of data from the sender to the receiver. It is common for the sending TCP to send multiple segments (typically over a short period of time) containing the URG flag, but with the urgent pointer pointing to the same byte of data. Only the first of these segments causes the receiving process to be notified that new out-of-band data has arrived.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docList">The receiving process is notified when a new urgent pointer arrives. First the <TT>SIGURG</TT> signal is sent to the owner of the socket, assuming either <TT>fcntl</TT> or <TT>ioctl</TT> has been called to establish an owner for the socket (<A class="docLink" HREF="0131411551_ch07lev1sec11.html#ch07fig20">Figure 7.20</A>). Second, if the process is blocked in a call to <TT>select</TT> waiting for this socket descriptor to have an exception condition, <TT>select</TT> returns.</P>
<P class="docList">These two potential notifications to the receiving process take place when a new urgent pointer arrives, regardless of whether the actual byte of data pointed to by the urgent pointer has arrived at the receiving TCP.</P>
<P class="docText">There is only one OOB mark; if a new OOB byte arrives before the old OOB byte was read, the old byte is discarded.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docList">When the actual byte of data pointed to by the urgent pointer arrives at the receiving TCP, the data byte can be pulled out-of-band or left inline. By default, the <TT>SO_OOBINLINE</TT> socket option is <span class="docEmphasis">not</span> set for a socket, so the single byte of data is not placed into the socket receive buffer. Instead, the data byte is placed into a separate one-byte out-of-band buffer for this connection (pp. 986–988 of TCPv2). The only way for the process to read from this special one-byte buffer is to call <TT>recv</TT>, <TT>recvfrom</TT>, or <TT>recvmsg</TT> and specify the <TT>MSG_OOB</TT> flag. If a new OOB byte arrives before the old byte is read, the previous value in this buffer is discarded.</P>
<P class="docText">If, however, the process sets the <TT>SO_OOBINLINE</TT> socket option, then the single byte of data referred to by TCP's urgent pointer is left in the normal socket receive buffer. The process cannot specify the <TT>MSG_OOB</TT> flag to read the data byte in this case. The process will know when it reaches this byte of data by checking the <span class="docEmphasis">out-of-band mark</span> for this connection, as we will describe in <A class="docLink" HREF="0131411551_ch24lev1sec3.html#ch24lev1sec3">Section 24.3</A>.</P>
</span></LI></OL></span>
<P class="docText">Some of the following errors are possible:</P>
<A NAME="ch24pro02"></A>




<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">If the process asks for out-of-band data (e.g., specifying the <TT>MSG_OOB</TT> flag), but the peer has not sent any, <TT>EINVAL</TT> is returned.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">If the process has been notified that the peer has sent an out-of-band byte (e.g., by <TT>SIGURG</TT> or <TT>select</TT>), and the process tries to read it but that byte has not yet arrived, <TT>EWOULDBLOCK</TT> is returned. All the process can do at this point is read from the socket receive buffer (possibly discarding the data if it has no room to store the data), to make space in the buffer so that the peer TCP can send the out-of-band byte.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">If the process tries to read the same out-of-band byte multiple times, <TT>EINVAL</TT> is returned.</P>
</span></LI><LI><span style="font-weight:normal" value="4"><P class="docText">If the process has set the <TT>SO_OOBINLINE</TT> socket option and then tries to read the out-of-band data by specifying <TT>MSG_OOB</TT>, <TT>EINVAL</TT> is returned.</P>
</span></LI></OL></span>
<A NAME="ch24lev2sec1"></A>
<H4 class="docSection2Title"> Simple Example Using <TT>SIGURG</TT></H4>
<P class="docText">We now show a trivial example of sending and receiving out-of-band data. <A class="docLink" HREF="#ch24fig03">Figure 24.3</A> shows the sending program.</P>
<P class="docText">Nine bytes are sent, with a one-second <TT>sleep</TT> between each output operation. The purpose of the pause is to let each <TT>write</TT> or <TT>send</TT> be transmitted as a single TCP segment and received as such by the other end. We'll talk later about some of the timing considerations with out-of-band data. When we run this program, we see the expected output.</P>
<pre>

</pre><pre>
macosx % <span class="docEmphStrong">tcpsend01 freebsd4 9999</span>
wrote 3 bytes of normal data
wrote 1 byte of OOB data
wrote 2 bytes of normal data
wrote 1 byte of OOB data
wrote 2 bytes of normal data
</pre><pre>
</pre>

<H5 class="docExampleTitle"><A NAME="ch24fig03"></A>Figure 24.3 Simple out-of-band sending program.</H5>
<P class="docText"><span class="docEmphasis">oob/tcpsend01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;

 6     if (argc != 3)
 7         err_quit("usage: tcpsend01 &lt;host&gt; &lt;port#&gt;");

 8     sockfd = Tcp_connect(argv[1], argv[2]);

 9     Write(sockfd, "123", 3);
10     printf("wrote 3 bytes of normal data\n");
11     sleep(1);

12     Send(sockfd, "4", 1, MSG_OOB);
13     printf("wrote 1 byte of OOB data\n");
14     sleep(1);

15     Write(sockfd, "56", 2);
16     printf("wrote 2 bytes of normal data\n");
17     sleep(1);

18     Send(sockfd, "7", 1, MSG_OOB);
19     printf("wrote 1 byte of OOB data\n");
20     sleep(1);

21     Write(sockfd, "89", 2);
22     printf("wrote 2 bytes of normal data\n");
23     sleep(1);

24     exit(0);
25 }
</PRE>

<P class="docText"><A class="docLink" HREF="#ch24fig04">Figure 24.4</A> is the receiving program.</P>
<A NAME="ch24lev3sec1"></A>
<H5 class="docSection3Title"> Establish signal handler and socket owner</H5>
<p class="docText"><span class="docEmphasis"><TT>16–17</TT></span> The signal handler for <TT>SIGURG</TT> is established, and <TT>fcntl</TT> sets the owner of the connected socket.</p>
<BLOCKQUOTE><P><P class="docList">Notice that we do not establish the signal handler until <TT>accept</TT> returns. There is a small probability that out-of-band data can arrive after our TCP completes the three-way handshake, but before <TT>accept</TT> returns, which we would miss. But if we established the signal handler before calling <TT>accept</TT> and also set the owner of the listening socket (which carries over to the connected socket), then if out-of-band data arrives before <TT>accept</TT> returns, our signal handler won't yet have a value for <TT>connfd</TT>. If this scenario is important for the application, it should initialize <TT>connfd</TT> to –1, check for this value in the signal handler, and if true, just set a flag for the main loop to check after <TT>accept</TT> returns. Alternately, it could block the signal around the call to <TT>accept</TT>, but this is subject to all the signal race conditions we discussed in <A class="docLink" HREF="0131411551_ch20lev1sec5.html#ch20lev1sec5">Section 20.5</A>.</P></P></BLOCKQUOTE>

<H5 class="docExampleTitle"><A NAME="ch24fig04"></A>Figure 24.4 Simple out-of-band receiving program.</H5>
<P class="docText"><span class="docEmphasis">oob/tcprecv01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int     listenfd, connfd;

 3 void    sig_urg(int);

 4 int
 5 main(int argc, char **argv)
 6 {
 7     int     n;
 8     char    buff[100];

 9     if (argc == 2)
10         listenfd = Tcp_listen(NULL, argv[1], NULL);
11     else if (argc == 3)
12         listenfd = Tcp_listen(argv[1], argv[2], NULL);
13     else
14         err_quit("usage: tcprecv01 [ &lt;host&gt; ] &lt;port#&gt;");

15     connfd = Accept(listenfd, NULL, NULL);

16     Signal(SIGURG, sig_urg);
17     Fcntl(connfd, F_SETOWN, getpid());

18     for ( ; ; ) {
19         if ( (n = Read(connfd, buff, sizeof(buff) - 1)) == 0) {
20             printf("received EOF\n");
21             exit(0);
22         }
23         buff[n] = 0;            /* null terminate */
24         printf("read %d bytes: %s\n", n, buff);
25     }
26 }

27 void
28 sig_urg(int signo)
29 {
30     int     n;
31     char    buff[100];

32     printf("SIGURG received\n");
33     n = Recv(connfd, buff, sizeof(buff) - 1, MSG_OOB);
34     buff[n] = 0;                /* null terminate */
35     printf("read %d OOB byte: %s\n", n, buff);
36 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>18–25</TT></span> The process reads from the socket, printing each string that is returned by <TT>read</TT>. When the sender terminates the connection, the receiver then terminates.</p>

<A NAME="ch24lev3sec2"></A>
<H5 class="docSection3Title"> <TT>SIGURG</TT> handler</H5>
<p class="docText"><span class="docEmphasis"><TT>27–36</TT></span> Our signal handler calls <TT>printf</TT>, reads the out-of-band byte by specifying the <TT>MSG_OOB</TT> flag, and then prints the returned data. Notice that we ask for up to 100 bytes in the call to <TT>recv</TT>, but as we will see shortly, only 1 byte is ever returned as out-of-band data.</p>
<BLOCKQUOTE><P><P class="docList">As stated earlier, calling the unsafe <TT>printf</TT> function from a signal handler is not recommended. We do it just to see what's happening with our programs.</P></P></BLOCKQUOTE>
<P class="docText">Here is the output when we run the receiving program, and then run the sending program from <A class="docLink" HREF="#ch24fig03">Figure 24.3</A>:</P>
<pre>

</pre><pre>
freebsd4 % <span class="docEmphStrong">tcprecv01 9999</span>
read 3 bytes: 123
SIGURG received
read 1 OOB byte: 4
read 2 bytes: 56
SIGURG received
read 1 OOB byte: 7
read 2 bytes: 89
received EOF
</pre><pre>
</pre>
<P class="docText">The results are as we expect. Each sending of out-of-band data by the sender generates <TT>SIGURG</TT> for the receiver, which then reads the single out-of-band byte.</P>


<A NAME="ch24lev2sec2"></A>
<H4 class="docSection2Title"> Simple Example Using <TT>select</TT></H4>
<P class="docText">We now redo our out-of-band receiver to use <TT>select</TT> instead of the <TT>SIGURG</TT> signal. <A class="docLink" HREF="#ch24fig05">Figure 24.5</A> is the receiving program.</P>
<p class="docText"><span class="docEmphasis"><TT>15–20</TT></span> The process calls <TT>select</TT> while waiting for either normal data (the read set, <TT>rset</TT>) or out-of-band data (the exception set, <TT>xset</TT>). In each case, the received data is printed.</p>
<P class="docText">When we run this program and then run the same sending program as earlier (<A class="docLink" HREF="#ch24fig03">Figure 24.3</A>), we encounter the following error:</P>
<pre>

</pre><pre>
freebsd4 % <span class="docEmphStrong">tcprecv02 9999</span>
read 3 bytes: 123
read 1 OOB byte: 4
recv error: Invalid argument
</pre><pre>
</pre>
<P class="docText">The problem is that <TT>select</TT> indicates an exception condition until the process reads <span class="docEmphasis">beyond</span> the out-of-band data (pp. 530–531 of TCPv2). We cannot read the out-of-band data more than once because after we read it the first time, the kernel clears the one-byte out-of-band buffer. When we call <TT>recv</TT> specifying the <TT>MSG_OOB</TT> flag the second time, it returns <TT>EINVAL</TT>.</P>

<H5 class="docExampleTitle"><A NAME="ch24fig05"></A>Figure 24.5 Receiving program that (incorrectly) uses <TT>select</TT> to be notified of out-of-band data.</H5>
<P class="docText"><span class="docEmphasis">oob/tcprecv02.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd, n;
 6     char    buff[100];
 7     fd_set  rset, xset;

 8     if (argc == 2)
 9         listenfd = Tcp_listen(NULL, argv[1], NULL);
10     else if (argc == 3)
11         listenfd = Tcp_listen(argv[1], argv[2], NULL);
12     else
13         err_quit("usage: tcprecv02 [ &lt;host&gt; ] &lt;port#&gt;");

14     connfd = Accept(listenfd, NULL, NULL);

15     FD_ZERO(&amp;rset);
16     FD_ZERO(&amp;xset);
17     for ( ; ; ) {
18         FD_SET(connfd, &amp;rset);
19         FD_SET(connfd, &amp;xset);

20         Select(connfd + 1, &amp;rset, NULL, &amp;xset, NULL);

21         if (FD_ISSET(connfd, &amp;xset)) {
22             n = Recv(connfd, buff, sizeof(buff) - 1, MSG_OOB);
23             buff[n] = 0;        /* null terminate */
24             printf("read %d OOB byte: %s\n", n, buff);
25         }

26         if (FD_ISSET(connfd, &amp;rset)) {
27             if ( (n = Read(connfd, buff, sizeof(buff) - 1)) == 0) {
28                 printf("received EOF\n");
29                 exit(0);
30             }
31             buff[n] = 0;        /* null terminate */
32             printf("read %d bytes: %s\n", n, buff);
33         }
34     }
35 }
</PRE>

<P class="docText">The solution is to <TT>select</TT> for an exception condition only after reading normal data. <A class="docLink" HREF="#ch24fig06">Figure 24.6</A> is a modification of <A class="docLink" HREF="#ch24fig05">Figure 24.5</A> that handles this scenario correctly.</P>
<p class="docText"><span class="docEmphasis"><TT>5</TT></span> We declare a new variable named <TT>justreadoob</TT>, which indicates whether we just read out-of-band data or not. This flag determines whether or not to <TT>select</TT> for an exception condition.</p>
<p class="docText"><span class="docEmphasis"><TT>26–27</TT></span> When we set the <TT>justreadoob</TT> flag, we must also clear the bit for this descriptor in the exception set.</p>
<P class="docText">The program now works as expected.</P>

<H5 class="docExampleTitle"><A NAME="ch24fig06"></A>Figure 24.6 Modification of <A class="docLink" HREF="#ch24fig05">Figure 24.5</A> to <TT>select</TT> for an exception condition correctly.</H5>
<P class="docText"><span class="docEmphasis">oob/tcprecv03.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd, n, justreadoob = 0;
 6     char    buff[100];
 7     fd_set  rset, xset;

 8     if (argc == 2)
 9         listenfd = Tcp_listen(NULL, argv[1], NULL);
10     else if (argc == 3)
11         listenfd = Tcp_listen(argv[1], argv[2], NULL);
12     else
13         err_quit("usage: tcprecv03 [ &lt;host&gt; ] &lt;port#&gt;");

14     connfd = Accept(listenfd, NULL, NULL);

15     FD_ZERO(&amp;rset);
16     FD_ZERO(&amp;xset);
17     for ( ; ; ) {
18         FD_SET(connfd, &amp;rset);
19         if (justreadoob == 0)
20             FD_SET(connfd, &amp;xset);

21         Select(connfd + 1, &amp;rset, NULL, &amp;xset, NULL);

22         if (FD_ISSET(connfd, &amp;xset)) {
23             n = Recv(connfd, buff, sizeof(buff) - 1, MSG_OOB);
24             buff[n] = 0;        /* null terminate */
25             printf("read %d OOB byte: %s\n", n, buff);
26             justreadoob = 1;
27             FD_CLR(connfd, &amp;xset);
28         }

29         if (FD_ISSET(connfd, &amp;rset)) {
30             if ( (n = Read(connfd, buff, sizeof(buff) - 1) ) == 0) {
31                 printf("received EOF\n");
32                 exit(0);
33             }
34             buff[n] = 0;        /* null terminate */
35             printf("read %d bytes: %s\n", n, buff);
36             justreadoob = 0;
37         }
38     }
39 }
</PRE>



<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch24lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch24lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
