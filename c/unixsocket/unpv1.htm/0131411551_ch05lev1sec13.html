<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.13 'SIGPIPE' Signal"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec12.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec14.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec13"></A>
<H3 class="docSection1Title" id="162666-869">5.13 <TT>SIGPIPE</TT> Signal</H3>
<P class="docText">What happens if the client ignores the error return from <TT>readline</TT> and writes more data to the server? This can happen, for example, if the client needs to perform two writes to the server before reading anything back, with the first write eliciting the RST.</P>
<P class="docText">The rule that applies is: When a process writes to a socket that has received an RST, the <TT>SIGPIPE</TT> signal is sent to the process. The default action of this signal is to terminate the process, so the process must catch the signal to avoid being involuntarily terminated.</P>
<P class="docText">If the process either catches the signal and returns from the signal handler, or ignores the signal, the write operation returns <TT>EPIPE</TT>.</P>
<BLOCKQUOTE><P><P class="docList">A frequently asked question (FAQ) on Usenet is how to obtain this signal on the first write, and not the second. This is not possible. Following our discussion above, the first write elicits the RST and the second write elicits the signal. It is okay to write to a socket that has received a FIN, but it is an error to write to a socket that has received an RST.</P></P></BLOCKQUOTE>
<P class="docText">To see what happens with <TT>SIGPIPE</TT>, we modify our client as shown in <A class="docLink" HREF="#ch05fig14">Figure 5.14</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch05fig14"></A>Figure 5.14 <TT>str_cli</TT> that calls <TT>writen</TT> twice.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/str_cli11.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 void
 3 str_cli(FILE *fp, int sockfd)
 4 {
 5     char    sendline [MAXLINE], recvline [MAXLINE];

 6     while (Fgets(sendline, MAXLINE, fp) != NULL) {

 7         Writen(sockfd, sendline, 1);
 8         sleep(1);
 9         Writen(sockfd, sendline + 1, strlen(sendline) - 1);

10         if (Readline(sockfd, recvline, MAXLINE) == 0)
11             err_quit("str_cli: server terminated prematurely");

12         Fputs(recvline, stdout);
13     }
14 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>7–9</TT></span> All we have changed is to call <TT>writen</TT> two times: the first time the first byte of data is written to the socket, followed by a pause of one second, followed by the remainder of the line. The intent is for the first <TT>writen</TT> to elicit the RST and then for the second <TT>writen</TT> to generate <TT>SIGPIPE</TT>.</p>
<P class="docText">If we run the client on our Linux host, we get:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top" colspan="2"><P class="docText"><TT>linux %</TT> <span class="docEmphStrong"><TT>tcpclill 127.0.0.1</TT></span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>hi there</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we type this line</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>hi there</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">this is echoed by the server</span></P></TD></TR><TR><TD class="docTableCell" valign="top">&nbsp;</TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">here we kill the server child</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>bye</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">then we type this line</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>Broken pipe</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">this is printed by the shell</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">We start the client, type in one line, see that line echoed correctly, and then terminate the server child on the server host. We then type another line ("bye") and the shell tells us the process died with a <TT>SIGPIPE</TT> signal (some shells do not print anything when a process dies without dumping core, but the shell we're using for this example, <TT>bash</TT>, tells us what we want to know).</P>
<P class="docText">The recommended way to handle <TT>SIGPIPE</TT> depends on what the application wants to do when this occurs. If there is nothing special to do, then setting the signal disposition to <TT>SIG_IGN</TT> is easy, assuming that subsequent output operations will catch the error of <TT>EPIPE</TT> and terminate. If special actions are needed when the signal occurs (writing to a log file perhaps), then the signal should be caught and any desired actions can be performed in the signal handler. Be aware, however, that if multiple sockets are in use, the delivery of the signal will not tell us which socket encountered the error. If we need to know which <TT>write</TT> caused the error, then we must either ignore the signal or return from the signal handler and handle <TT>EPIPE</TT> from the <TT>write</TT>.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec12.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec14.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
