<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.11 Connection Abort before 'accept' Returns"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec10.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec12.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec11"></A>
<H3 class="docSection1Title">5.11 Connection Abort before <TT>accept</TT> Returns</H3>
<P class="docText">There is another condition similar to the interrupted system call example in the previous section that can cause <TT>accept</TT> to return a nonfatal error, in which case we should just call <TT>accept</TT> again. The sequence of packets shown in <A class="docLink" HREF="#ch05fig13">Figure 5.13</A> has been seen on busy servers (typically busy Web servers).</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch05fig13"></A>Figure 5.13. Receiving an RST for an ESTABLISHED connection before <TT>accept</TT> is called.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="248" src="FILES/05fig13.gif" ALT="graphics/05fig13.gif"></p>

</CENTER>
<P class="docText">Here, the three-way handshake completes, the connection is established, and then the client TCP sends an RST (reset). On the server side, the connection is queued by its TCP, waiting for the server process to call <TT>accept</TT> when the RST arrives. Sometime later, the server process calls <TT>accept</TT>.</P>
<BLOCKQUOTE><P><P class="docList">An easy way to simulate this scenario is to start the server, have it call <TT>socket</TT>, <TT>bind</TT>, and <TT>listen</TT>, and then go to sleep for a short period of time before calling <TT>accept</TT>. While the server process is asleep, start the client and have it call <TT>socket</TT> and <TT>connect</TT>. As soon as <TT>connect</TT> returns, set the <TT>SO_LINGER</TT> socket option to generate the RST (which we will describe in <A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A> and show an example of in <A class="docLink" HREF="0131411551_ch16lev1sec6.html#ch16fig21">Figure 16.21</A>) and terminate.</P></P></BLOCKQUOTE>
<P class="docText">Unfortunately, what happens to the aborted connection is implementation-dependent. Berkeley-derived implementations handle the aborted connection completely within the kernel, and the server process never sees it. Most SVR4 implementations, however, return an error to the process as the return from <TT>accept</TT>, and the error depends on the implementation. These SVR4 implementations return an <TT>errno</TT> of <TT>EPROTO</TT> ("protocol error"), but POSIX specifies that the return must be <TT>ECONNABORTED</TT> ("software caused connection abort") instead. The reason for the POSIX change is that <TT>EPROTO</TT> is also returned when some fatal protocol-related events occur on the streams subsystem. Returning the same error for the nonfatal abort of an established connection by the client makes it impossible for the server to know whether to call <TT>accept</TT> again or not. In the case of the <TT>ECONNABORTED</TT> error, the server can ignore the error and just call <TT>accept</TT> again.</P>
<BLOCKQUOTE><P><P class="docList">The steps involved in Berkeley-derived kernels that never pass this error to the process can be followed in TCPv2. The RST is processed on p. 964, causing <TT>tcp_close</TT> to be called. This function calls <TT>in_pcbdetach</TT> on p. 897, which in turn calls <TT>sofree</TT> on p. 719. <TT>sofree</TT> (p. 473) finds that the socket being aborted is still on the listening socket's completed connection queue and removes the socket from the queue and frees the socket. When the server gets around to calling <TT>accept</TT>, it will never know that a connection that was completed has since been removed from the queue.</P></P></BLOCKQUOTE>
<P class="docText">We will return to these aborted connections in <A class="docLink" HREF="0131411551_ch16lev1sec6.html#ch16lev1sec6">Section 16.6</A> and see how they can present a problem when combined with <TT>select</TT> and a listening socket in the normal blocking mode.</P>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec10.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec12.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
