<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="16.2 Nonblocking Reads and Writes: 'str_cli' Function (Revisited)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch16lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch16lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch16lev1sec2"></A>
<H3 class="docSection1Title" id="162666-803">16.2 Nonblocking Reads and Writes: <TT>str_cli</TT> Function (Revisited)</H3>
<P class="docText">We return once again to our <TT>str_cli</TT> function, which we discussed in <A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05lev1sec5">Sections 5.5</A> and <A class="docLink" HREF="0131411551_ch06lev1sec4.html#ch06lev1sec4">6.4</A>. The latter version, which uses <TT>select</TT>, still uses blocking I/O. For example, if a line is available on standard input, we read it with <TT>read</TT> and then send it to the server with <TT>writen</TT>. But the call to <TT>writen</TT> can block if the socket send buffer is full. While we are blocked in the call to <TT>writen</TT>, data could be available for reading from the socket receive buffer. Similarly, if a line of input is available from the socket, we can block in the subsequent call to <TT>write</TT>, if standard output is slower than the network. Our goal in this section is to develop a version of this function that uses nonblocking I/O. This prevents us from blocking while we could be doing something productive.</P>
<P class="docText">Unfortunately, the addition of nonblocking I/O complicates the function's buffer management noticeably, so we will present the function in pieces. As we discussed in <A class="docLink" HREF="0131411551_ch06.html#ch06">Chapter 6</A>, using standard I/O with sockets can be difficult, and that is very much the case with nonblocking I/O. So we continue to avoid standard I/O in this example.</P>
<P class="docText">We maintain two buffers: <TT>to</TT> contains data going from standard input to the server, and <TT>fr</TT> contains data arriving from the server going to standard output. <A class="docLink" HREF="#ch16fig01">Figure 16.1</A> shows the arrangement of the <TT>to</TT> buffer and the pointers into the buffer.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig01"></A>Figure 16.1. Buffer containing data from standard input going to the socket.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="500" HEIGHT="187" src="FILES/16fig01.gif" ALT="graphics/16fig01.gif"></p>

</CENTER>
<P class="docText">The pointer <TT>toiptr</TT> points to the next byte into which data can be read from standard input. <TT>tooptr</TT> points to the next byte that must be written to the socket. There are <TT>toiptr</TT> minus <TT>tooptr</TT> bytes to be written to the socket. The number of bytes that can be read from standard input is <TT>&amp;to [MAXLINE]</TT> minus <TT>toiptr</TT>. As soon as <TT>tooptr</TT> reaches <TT>toiptr</TT>, both pointers are reset to the beginning of the buffer.</P>
<P class="docText"><A class="docLink" HREF="#ch16fig02">Figure 16.2</A> shows the corresponding arrangement of the <TT>fr</TT> buffer.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig02"></A>Figure 16.2. Buffer containing data from the socket going to standard output.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="500" HEIGHT="178" src="FILES/16fig02.gif" ALT="graphics/16fig02.gif"></p>

</CENTER>
<P class="docText"><A class="docLink" HREF="#ch16fig03">Figure 16.3</A> shows the first part of the function.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig03"></A>Figure 16.3 <TT>str_cli</TT> function, first part: initializes and calls <TT>select</TT>.</H5>
<P class="docText"><span class="docEmphasis">nonblock/strclinonb.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 void
 3 str_cli(FILE *fp, int sockfd)
 4 {
 5     int     maxfdp1, val, stdineof;
 6     ssize_t n, nwritten;
 7     fd_set  rset, wset;
 8     char    to[MAXLINE], fr[MAXLINE];
 9     char    *toiptr, *tooptr, *friptr, *froptr;

10     val = Fcntl(sockfd, F_GETFL, 0);
11     Fcntl(sockfd, F_SETFL, val | O_NONBLOCK);

12     val = Fcntl(STDIN_FILENO, F_GETFL, 0);
13     Fcntl(STDIN_FILENO, F_SETFL, val | O_NONBLOCK);

14     val = Fcntl(STDOUT_FILENO, F_GETFL, 0);
15     Fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK);

16     toiptr = tooptr = to;       /* initialize buffer pointers */
17     friptr = froptr = fr;
18     stdineof = 0;

19     maxfdp1 = max(max(STDIN_FILENO, STDOUT_FILENO), sockfd) + 1;
20     for ( ; ; ) {
21         FD_ZERO(&amp;rset);
22         FD_ZERO(&amp;wset);
23         if (stdineof == 0 &amp;&amp; toiptr &lt; &amp;to[MAXLINE])
24             FD_SET(STDIN_FILENO, &amp;rset);     /* read from stdin */
25         if (friptr &lt; &amp;fr[MAXLINE])
26             FD_SET(sockfd, &amp;rset);  /* read from socket */
27         if (tooptr != toiptr)
28             FD_SET(sockfd, &amp;wset);  /* data to write to socket */
29         if (froptr != friptr)
30             FD_SET(STDOUT_FILENO, &amp;wset);   /* data to write to stdout */

31         Select(maxfdp1, &amp;rset, &amp;wset, NULL, NULL);
</PRE>

<A NAME="ch16lev3sec1"></A>
<H4 class="docSection2Title"> Set descriptors to nonblocking</H4>
<p class="docText"><span class="docEmphasis"><TT>10–15</TT></span> All three descriptors are set to nonblocking using <TT>fcntl:</TT> the socket to and from the server, standard input, and standard output.</p>

<A NAME="ch16lev3sec2"></A>
<H4 class="docSection2Title"> Initialize buffer pointers</H4>
<p class="docText"><span class="docEmphasis"><TT>16–19</TT></span> The pointers into the two buffers are initialized and the maximum descriptor plus one is calculated, which will be used as the first argument for <TT>select</TT>.</p>

<A NAME="ch16lev3sec3"></A>
<H4 class="docSection2Title"> Main loop: prepare to call <TT>select</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>20</TT></span> As with the previous version of this function, <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>, the main loop of the function is a call to <TT>select</TT> followed by individual tests of the various conditions we are interested in.</p>

<A NAME="ch16lev3sec4"></A>
<H4 class="docSection2Title"> Specify descriptors we are interested in</H4>
<p class="docText"><span class="docEmphasis"><TT>21–30</TT></span> Both descriptor sets are set to 0 and then up to 2 bits are turned on in each set. If we have not yet read an EOF on standard input, and there is room for at least one byte of data in the <TT>to</TT> buffer, the bit corresponding to standard input is turned on in the read set. If there is room for at least one byte of data in the <TT>fr</TT> buffer, the bit corresponding to the socket is turned on in the read set. If there is data to write to the socket in the <TT>to</TT> buffer, the bit corresponding to the socket is turned on in the write set. Finally, if there is data in the <TT>fr</TT> buffer to send to standard output, the bit corresponding to standard output is turned on in the write set.</p>

<A NAME="ch16lev3sec5"></A>
<H4 class="docSection2Title"> Call <TT>select</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>31</TT></span> <TT>select</TT> is called, waiting for any one of the four possible conditions to be true. We do not specify a timeout for this function.</p>
<P class="docText">The next part of the function is shown in <A class="docLink" HREF="#ch16fig04">Figure 16.4</A>. This code contains the first two tests (of four) that are made after <TT>select</TT> returns.</P>

<A NAME="ch16lev3sec6"></A>
<H4 class="docSection2Title"> <TT>read</TT> from standard input</H4>
<p class="docText"><span class="docEmphasis"><TT>32–33</TT></span> If standard input is readable, we call <TT>read</TT>. The third argument is the amount of available space in the <TT>to</TT> buffer.</p>

<A NAME="ch16lev3sec7"></A>
<H4 class="docSection2Title"> Handle nonblocking error</H4>
<p class="docText"><span class="docEmphasis"><TT>34–35</TT></span> If an error occurs and it is <TT>EWOULDBLOCK</TT>, nothing happens. Normally this condition "should not happen," that is, <TT>select</TT> telling us that the descriptor is readable and <TT>read</TT> returning <TT>EWOULDBLOCK</TT>, but we handle it nevertheless.</p>

<A NAME="ch16lev3sec8"></A>
<H4 class="docSection2Title"> <TT>read</TT> returns EOF</H4>
<p class="docText"><span class="docEmphasis"><TT>36–40</TT></span> If <TT>read</TT> returns 0, we are finished with the standard input. Our flag <TT>stdineof</TT> is set. If there is no more data in the <TT>to</TT> buffer to send (<TT>tooptr</TT> equals <TT>toiptr</TT>), <TT>shutdown</TT> sends a FIN to the server. If there is still data in the <TT>to</TT> buffer to send, the FIN cannot be sent until the buffer is written to the socket.</p>
<BLOCKQUOTE><P><P class="docList">We output a line to standard error noting the EOF, along with the current time, and we show how we use this output after describing this function. Similar calls to <TT>fprintf</TT> are found throughout this function.</P></P></BLOCKQUOTE>

<H5 class="docExampleTitle"><A NAME="ch16fig04"></A>Figure 16.4 <TT>str_cli</TT> function, second part: reads from standard input or socket.</H5>
<P class="docText"><span class="docEmphasis">nonblock/strclinonb.c</span></P>

<PRE>
32      if (FD_ISSET(STDIN_FILENO, &amp;rset)) {
33          if ( (n = read(STDIN_FILENO, toiptr, &amp;to[MAXLINE] - toiptr)) &lt; 0) {
34              if (errno != EWOULDBLOCK)
35                  err_sys("read error on stdin");

36          } else if (n == 0) {
37              fprintf(stderr, "%s: EOF on stdin\n", gf_time());
38              stdineof = 1;   /* all done with stdin */
39              if (tooptr == toiptr)
40                  Shutdown(sockfd, SHUT_WR);   /* send FIN */

41          } else {
42              fprintf(stderr, "%s: read %d bytes from stdin\n", gf_time(),
43                      n);
44              toiptr += n;     /* # just read */
45              FD_SET(sockfd, &amp;wset); /* try and write to socket below */
46          }
47      }

48      if (FD_ISSET(sockfd, &amp;rset)) {
49          if ( (n = read(sockfd, friptr, &amp;fr[MAXLINE] - friptr)) &lt; 0) {
50              if (errno != EWOULDBLOCK)
51                  err_sys("read error on socket");

52          } else if (n == 0) {
53              fprintf(stderr, "%s: EOF on socket\n", gf_time());
54              if (stdineof)
55                  return;     /* normal termination */
56              else
57                 err_quit("str_cli: server terminated prematurely");

58          } else {
59              fprintf(stderr, "%s: read %d bytes from socket\n",
60                      gf_time(), n);
61              friptr += n;     /* # just read */
62              FD_SET(STDOUT_FILENO, &amp;wset);     /* try and write below */
63          }
64      }
</PRE>


<A NAME="ch16lev3sec9"></A>
<H4 class="docSection2Title"> <TT>read</TT> returns data</H4>
<p class="docText"><span class="docEmphasis"><TT>41–45</TT></span> When <TT>read</TT> returns data, we increment <TT>toiptr</TT> accordingly. We also turn on the bit corresponding to the socket in the write set, to cause the test for this bit to be true later in the loop, thus causing a <TT>write</TT> to be attempted to the socket.</p>
<BLOCKQUOTE><P><P class="docList">This is one of the hard design decisions when writing code. We have a few alternatives here. Instead of setting the bit in the write set, we could do nothing, in which case, <TT>select</TT> will test for writability of the socket the next time it is called. But this requires another loop around and another call to <TT>select</TT> when we already know that we have data to write to the socket. Another choice is to duplicate the code that writes to the socket here, but this seems wasteful and a potential source for error (in case there is a bug in that piece of duplicated code, and we fix it in one location but not the other). Lastly, we could create a function that writes to the socket and call that function instead of duplicating the code, but that function needs to share three of the local variables with <TT>str_cli</TT>, which would necessitate making these variables global. The choice made is the authors' view on which alternative is best.</P></P></BLOCKQUOTE>

<A NAME="ch16lev3sec10"></A>
<H4 class="docSection2Title"> <TT>read</TT> from socket</H4>
<p class="docText"><span class="docEmphasis"><TT>48–64</TT></span> These lines of code are similar to the <TT>if</TT> statement we just described when standard input is readable. If <TT>read</TT> returns <TT>EWOULDBLOCK</TT>, nothing happens. If we encounter an EOF from the server, this is okay if we have already encountered an EOF on the standard input, but it is not expected otherwise. If <TT>read</TT> returns some data, <TT>friptr</TT> is incremented and the bit for standard output is turned on in the write descriptor set, to try to write the data in the next part of the function.</p>
<P class="docText"><A class="docLink" HREF="#ch16fig05">Figure 16.5</A> shows the final portion of the function.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig05"></A>Figure 16.5 <TT>str_cli</TT> function, third part: writes to standard output or socket.</H5>
<P class="docText"><span class="docEmphasis">nonblock/strclinonb.c</span></P>

<PRE>
65      if (FD_ISSET(STDOUT_FILENO, &amp;wset) &amp;&amp; ((n = friptr - froptr) &gt; 0)) {
66          if ( (nwritten = write(STDOUT_FILENO, froptr, n)) &lt; 0) {
67              if (errno != EWOULDBLOCK)
68                  err_sys("write error to stdout");

69          } else {
70              fprintf(stderr, "%s: wrote %d bytes to stdout\n",
71                      gf_time(), nwritten);
72              froptr += nwritten; /* # just written */
73              if (froptr == friptr)
74                  froptr = friptr = fr;   /* back to beginning of buffer */
75          }
76      }

77      if (FD_ISSET(sockfd, &amp;wset) &amp;&amp; ((n = toiptr - tooptr) &gt; 0)) {
78          if ( (nwritten = write(sockfd, tooptr, n)) &lt; 0) {
79              if (errno != EWOULDBLOCK)
80                  err_sys("write error to socket");

81          } else {
82              fprintf(stderr, "%s: wrote %d bytes to socket\n",
83                      gf_time(), nwritten);
84              tooptr += nwritten; /* # just written */
85              if (tooptr == toiptr) {
86                  toiptr = tooptr = to;   /* back to beginning of buffer */
87                  if (stdineof)
88                      Shutdown(sockfd, SHUT_WR);  /* send FIN */
89              }
90          }
91       }
92    }
93 }
</PRE>


<A NAME="ch16lev3sec11"></A>
<H4 class="docSection2Title"> <TT>write</TT> to standard output</H4>
<p class="docText"><span class="docEmphasis"><TT>65–68</TT></span> If standard output is writable and the number of bytes to write is greater than 0, <TT>write</TT> is called. If <TT>EWOULDBLOCK</TT> is returned, nothing happens. Notice that this condition is entirely possible because the code at the end of the previous part of this function turns on the bit for standard output in the write set, without knowing whether the <TT>write</TT> will succeed or not.</p>

<A NAME="ch16lev3sec12"></A>
<H4 class="docSection2Title"> <TT>write</TT> OK</H4>
<p class="docText"><span class="docEmphasis"><TT>69–75</TT></span> If the <TT>write</TT> is successful, <TT>froptr</TT> is incremented by the number of bytes written. If the output pointer has caught up with the input pointer, both pointers are reset to point to the beginning of the buffer.</p>

<A NAME="ch16lev3sec13"></A>
<H4 class="docSection2Title"> <TT>write</TT> to socket</H4>
<p class="docText"><span class="docEmphasis"><TT>77–91</TT></span> This section of code is similar to the code we just described for writing to the standard output. The one difference is that when the output pointer catches up with the input pointer, not only are both pointers reset to the beginning of the buffer, but if we encountered an EOF on standard input, the FIN can be sent to the server.</p>
<P class="docText">We now examine the operation of this function and the overlapping of the nonblocking I/O. <A class="docLink" HREF="#ch16fig06">Figure 16.6</A> shows our <TT>gf_time</TT> function, which is called from our <TT>str_cli</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig06"></A>Figure 16.6 <TT>gf_time</TT> function: returns pointer to time string.</H5>
<P class="docText"><span class="docEmphasis">lib/gf_time.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     &lt;time.h&gt;

 3 char *
 4 gf_time(void)
 5 {
 6     struct timeval tv;
 7     static char str[30];
 8     char  *ptr;

 9     if (gettimeofday(&amp;tv, NULL) &lt; 0)
10         err_sys("gettimeofday error");

11     ptr = ctime(&amp;tv.tv_sec);
12     strcpy(str, &amp;ptr[11]);
13     /* Fri Sep 13 00:00:00 1986\n\0 */
14     /* 0123456789012345678901234 5 */
15     snprintf(str + 8, sizeof(str) - 8, ".%06ld", tv.tv_usec);

16     return (str);
17 }
</PRE>

<P class="docText">This function returns a string containing the current time, including microseconds, in the following format:</P>
<pre>

</pre><pre>
12:34:56.123456
</pre><pre>
</pre>
<P class="docText">This is intentionally in the same format as the timestamps output by <TT>tcpdump</TT>. Also notice that all the calls to <TT>fprintf</TT> in our <TT>str_cli</TT> function write to standard error, allowing us to separate standard output (the lines echoed by the server) from our diagnostic output. We can then run our client and <TT>tcpdump</TT> and take this diagnostic output along with the <TT>tcpdump</TT> output and sort the two outputs together, ordered by the time. This lets us see what happens in our program and correlate it with the corresponding TCP action.</P>
<P class="docText">For example, we first run <TT>tcpdump</TT> on our host <TT>solaris</TT>, capturing only TCP segments to or from port 7 (the echo server), saving the output in the file named <TT>tcpd</TT>.</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">tcpdump -w tcpd tcp and port 7</span>
</pre><pre>
</pre>
<P class="docText">We then run our TCP client on this host, specifying the server on the host <TT>linux</TT>.</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">tcpcli02 192.168.1.10 &lt; 2000.lines &gt; out 2&gt; diag</span>
</pre><pre>
</pre>
<P class="docText">Standard input is the file <TT>2000.lines</TT>, the same file we used with <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>. Standard output is sent to the file <TT>out</TT>, and standard error is sent to the file <TT>diag</TT>. On completion, we run</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">diff 2000.lines out</span>
</pre><pre>
</pre>
<P class="docText">to verify that the echoed lines are identical to the input lines. Finally, we terminate <TT>tcpdump</TT> with our interrupt key and then print the <TT>tcpdump</TT> records, sorting these records with the diagnostic output from the client. <A class="docLink" HREF="#ch16fig07">Figure 16.7</A> shows the first part of this result.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig07"></A>Figure 16.7 Sorted output from <TT>tcpdump</TT> and diagnostic output.</H5>

<PRE>
solaris % <span class="docEmphStrong">tcpdump -r tcpd -N | sort diag -</span>
10:18:34.486392 solaris.33621 &gt; linux.echo: S 1802738644:1802738644(0)
                                           win 8760 &lt;mss 1460&gt;
10:18:34.488278 linux.echo &gt; solaris.33621: S 3212986316:3212986316(0)
                                           ack 1802738645 win 8760 &lt;mss 1460&gt;
10:18:34.488490 solaris.33621 &gt; linux.echo: . ack 1 win 8760

10:18:34.491482: read 4096 bytes from stdin
10:18:34.518663 solaris.33621 &gt; linux.echo: P 1:1461(1460) ack 1 win 8760
10:18:34.519016: wrote 4096 bytes to socket
10:18:34.528529 linux.echo &gt; solaris.33621: P 1:1461(1460) ack 1461 win 8760
10:18:34.528785 solaris.33621 &gt; linux.echo: . 1461:2921(1460) ack 1461 win 8760
10:18:34.528900 solaris.33621 &gt; linux.echo: P 2921:4097(1176) ack 1461 win 8760
10:18:34.528958 solaris.33621 &gt; linux.echo: . ack 1461 win 8760
10:18:34.536193 linux.echo &gt; solaris.33621: . 1461:2921(1460) ack 4097 win 8760
10:18:34.536697 linux.echo &gt; solaris.33621: P 2921:3509(588) ack 4097 win 8760
10:18:34.544636: read 4096 bytes from stdin
10:18:34.568505: read 3508 bytes from socket
10:18:34.580373 solaris.33621 &gt; linux.echo: . ack 3509 win 8760
10:18:34.582244 linux.echo &gt; solaris.33621: P 3509:4097(588) ack 4097 win 8760
10:18:34.593354: wrote 3508 bytes to stdout
10:18:34.617272 solaris.33621 &gt; linux.echo: P 4097:5557(1460) ack 4097 win 8760
10:18:34.617610 solaris.33621 &gt; linux.echo: P 5557:7017(1460) ack 4097 win 8760
10:18:34.617908 solaris.33621 &gt; linux.echo: P 7017:8193(1176) ack 4097 win 8760
10:18:34.618062: wrote 4096 bytes to socket
10:18:34.623310 linux.echo &gt; solaris.33621: . ack 8193 win 8760
10:18:34.626129 linux.echo &gt; solaris.33621: . 4097:5557(1460) ack 8193 win 8760
10:18:34.626339 solaris.33621 &gt; linux.echo: . ack 5557 win 8760
10:18:34.626611 linux.echo &gt; solaris.33621: P 5557:6145(588) ack 8193 win 8760
10:18:34.628396 linux.echo &gt; solaris.33621: . 6145:7605(1460) ack 8193 win 8760
10:18:34.643524: read 4096 bytes from stdin
10:18:34.667305: read 2636 bytes from socket
10:18:34.670324 solaris.33621 &gt; linux.echo: . ack 7605 win 8760
10:18:34.672221 linux.echo &gt; solaris.33621: P 7605:8193(588) ack 8193 win 8760
10:18:34.691039: wrote 2636 bytes to stdout
</PRE>

<P class="docText">We wrapped the long lines containing the SYNs and we also removed the don't fragment <TT>(DF)</TT> notations from the Solaris segments, denoting that the DF bit is set (path MTU discovery).</P>
<P class="docText">Using this output, we can draw a timeline of what's happening. We show this in <A class="docLink" HREF="#ch16fig08">Figure 16.8</A>, with time increasing down the page.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig08"></A>Figure 16.8. Timeline of nonblocking example.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="500" HEIGHT="486" src="FILES/16fig08.gif" ALT="graphics/16fig08.gif"></p>

</CENTER>
<P class="docText">In this figure, we do not show the ACK segments. Also realize that when the program outputs "wrote <span class="docEmphasis">N</span> bytes to stdout," the <TT>write</TT> has returned, possibly causing TCP to send one or more segments of data.</P>
<P class="docText">What we can see from this timeline are the dynamics of a client/server exchange. Using nonblocking I/O lets the program take advantage of these dynamics, reading or writing when the operation can take place. We let the kernel tell us when an I/O operation can occur by using the <TT>select</TT> function.</P>
<P class="docText">We can time our nonblocking version using the same 2,000-line file and the same server (a 175-ms RTT from the client) as in <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06lev1sec7">Section 6.7</A>. The clock time is now 6.9 seconds, compared to 12.3 seconds for the version in <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06lev1sec7">Section 6.7</A>. Therefore, nonblocking I/O reduces the overall time for this example that sends a file to the server.</P>

<A NAME="ch16lev2sec1"></A>
<H4 class="docSection2Title"> A Simpler Version of <TT>str_cli</TT></H4>
<P class="docText">The nonblocking version of <TT>str_cli</TT> that we just showed is nontrivial: about 135 lines of code, compared to 40 lines for the version using <TT>select</TT> with blocking I/O in <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>, and 20 lines for our original stop-and-wait version (<A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A>). We know that doubling the size of the code from 20 to 40 lines was worth the effort, because the speed increased by almost a factor of 30 in a batch mode and using <TT>select</TT> with blocking descriptors was not overly complicated. But, is it worth the effort to code an application using nonblocking I/O, given the complexity of the resulting code? The answer is no. Whenever we find the need to use nonblocking I/O, it will usually be simpler to split the application into either processes (using <TT>fork</TT>) or threads (<A class="docLink" HREF="0131411551_ch26.html#ch26">Chapter 26</A>).</P>
<P class="docText"><A class="docLink" HREF="#ch16fig10">Figure 16.10</A> is yet another version of our <TT>str_cli</TT> function, with the function dividing itself into two processes using <TT>fork</TT>.</P>
<P class="docText">The function immediately calls <TT>fork</TT> to split into a parent and child. The child copies lines from the server to standard output and the parent copies lines from standard input to the server, as shown in <A class="docLink" HREF="#ch16fig09">Figure 16.9</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig09"></A>Figure 16.9. <TT>str_cli</TT> function using two processes.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="500" HEIGHT="129" src="FILES/16fig09.gif" ALT="graphics/16fig09.gif"></p>

</CENTER>
<P class="docText">We explicitly note that the TCP connection is full-duplex and that the parent and child are sharing the same socket descriptor: The parent writes to the socket and the child reads from the socket. There is only one socket, one socket receive buffer, and one socket send buffer, but this socket is referenced by two descriptors: one in the parent and one in the child.</P>
<P class="docText">We again need to worry about the termination sequence. Normal termination occurs when the EOF on standard input is encountered. The parent reads this EOF and calls <TT>shutdown</TT> to send a FIN. (The parent cannot call <TT>close</TT>. See <A class="docLink" HREF="0131411551_ch16lev1sec8.html#ch16lev1sec8">Exercise 16.1</A>.) But when this happens, the child needs to continue copying from the server to the standard output, until it reads an EOF on the socket.</P>
<P class="docText">It is also possible for the server process to terminate prematurely (<A class="docLink" HREF="0131411551_ch05lev1sec12.html#ch05lev1sec12">Section 5.12</A>); if this occurs, the child will read an EOF on the socket. If this happens, the child must tell the parent to stop copying from the standard input to the socket (see <A class="docLink" HREF="0131411551_ch16lev1sec8.html#ch16lev1sec8">Exercise 16.2</A>). In <A class="docLink" HREF="#ch16fig10">Figure 16.10</A>, the child sends the <TT>SIGTERM</TT> signal to the parent, in case the parent is still running (see <A class="docLink" HREF="0131411551_ch16lev1sec8.html#ch16lev1sec8">Exercise 16.3</A>). Another way to handle this would be for the child to terminate and have the parent catch <TT>SIGCHLD</TT>, if the parent is still running.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig10"></A>Figure 16.10 Version of <TT>str_cli</TT> function that uses <TT>fork</TT>.</H5>
<P class="docText"><span class="docEmphasis">nonblock/strclifork.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 void
 3 str_cli(FILE *fp, int sockfd)
 4 {
 5     pid_t     pid;
 6     char     sendline[MAXLINE], recvline[MAXLINE];

 7     if ( (pid = Fork()) == 0) {   /* child: server -&gt; stdout */
 8        while (Readline(sockfd, recvline, MAXLINE) &gt; 0)
 9            Fputs(recvline, stdout);

10        kill(getppid(), SIGTERM);    /* in case parent still running */
11        exit(0);
12     }

13     /* parent: stdin -&gt; server */
14     while (Fgets(sendline, MAXLINE, fp) != NULL)
15         Writen(sockfd, sendline, strlen(sendline));

16     Shutdown(sockfd, SHUT_WR);  /* EOF on stdin, send FIN */
17     pause();
18     return;
19 }
</PRE>

<P class="docText">The parent calls <TT>pause</TT> when it has finished copying, which puts it to sleep until a signal is caught. Even though our parent does not catch any signals, this puts the parent to sleep until it receives the <TT>SIGTERM</TT> signal from the child. The default action of this signal is to terminate the process, which is fine for this example. The reason we make the parent wait for the child is to measure an accurate clock time for this version of <TT>str_cli</TT>. Normally, the child finishes after the parent, but since we measure the clock time using the shell's <TT>time</TT> command, the measurement ends when the parent terminates.</P>
<P class="docText">Notice the simplicity of this version compared to the nonblocking I/O version shown earlier in this section. Our nonblocking version managed four different I/O streams at the same time, and since all four were nonblocking, we had to concern ourselves with partial reads and writes for all four streams. But in the <TT>fork</TT> version, each process handles only two I/O streams, copying from one to the other. There is no need for nonblocking I/O because if there is no data to read from the input stream, there is nothing to write to the corresponding output stream.</P>

<A NAME="ch16lev2sec2"></A>
<H4 class="docSection2Title"> Timing of <TT>str_cli</TT></H4>
<P class="docText">We have now shown four different versions of the <TT>str_cli</TT> function. We summarize the clock time required for these versions, along with a version using threads (<A class="docLink" HREF="0131411551_ch26lev1sec3.html#ch26fig02">Figure 26.2</A>), when copying 2,000 lines from a Solaris client to a server with an RTT of 175 ms:</P>
<UL><LI><P class="docList">354.0 sec, stop-and-wait (<A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A>)</P></LI><LI><P class="docList">12.3 sec, <TT>select</TT> and blocking I/O (<A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>)</P></LI><LI><P class="docList">6.9 sec, nonblocking I/O (<A class="docLink" HREF="#ch16fig03">Figure 16.3</A>)</P></LI><LI><P class="docList">8.7 sec, <TT>fork</TT> (<A class="docLink" HREF="#ch16fig10">Figure 16.10</A>)</P></LI><LI><P class="docList">8.5 sec, threaded version (<A class="docLink" HREF="0131411551_ch26lev1sec3.html#ch26fig02">Figure 26.2</A>)</P></LI></UL>
<P class="docText">Our nonblocking I/O version is almost twice as fast as our version using blocking I/O with <TT>select</TT>. Our simple version using <TT>fork</TT> is slower than our nonblocking I/O version. Nevertheless, given the complexity of the nonblocking I/O code versus the <TT>fork</TT> code, we recommend the simple approach.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch16lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch16lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
