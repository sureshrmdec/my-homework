<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.15 TCP and UDP Echo Server Using 'select'"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch08lev1sec14.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch08lev1sec16.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec15"></A>
<H3 class="docSection1Title">8.15 TCP and UDP Echo Server Using <TT>select</TT></H3>
<P class="docText">We now combine our concurrent TCP echo server from <A class="docLink" HREF="0131411551_ch05.html#ch05">Chapter 5</A> with our iterative UDP echo server from this chapter into a single server that uses <TT>select</TT> to multiplex a TCP and UDP socket. <A class="docLink" HREF="#ch08fig24">Figure 8.24</A> is the first half of this server.</P>
<A NAME="ch08lev3sec6"></A>
<H4 class="docSection2Title"> Create listening TCP socket</H4>
<p class="docText"><span class="docEmphasis"><TT>14–22</TT></span> A listening TCP socket is created that is bound to the server's well-known port. We set the <TT>SO_REUSEADDR</TT> socket option in case connections exist on this port.</p>

<A NAME="ch08lev3sec7"></A>
<H4 class="docSection2Title"> Create UDP socket</H4>
<p class="docText"><span class="docEmphasis"><TT>23–29</TT></span> A UDP socket is also created and bound to the same port. Even though the same port is used for TCP and UDP sockets, there is no need to set the <TT>SO_REUSEADDR</TT> socket option before this call to <TT>bind</TT>, because TCP ports are independent of UDP ports.</p>
<P class="docText"><A class="docLink" HREF="#ch08fig25">Figure 8.25</A> shows the second half of our server.</P>
<A NAME="ch08lev3sec8"></A>
<H5 class="docSection3Title"> Establish signal handler for <TT>SIGCHLD</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>30</TT></span> A signal handler is established for <TT>SIGCHLD</TT> because TCP connections will be handled by a child process. We showed this signal handler in <A class="docLink" HREF="0131411551_ch05lev1sec10.html#ch05fig11">Figure 5.11</A>.</p>

<A NAME="ch08lev3sec9"></A>
<H5 class="docSection3Title"> Prepare for <TT>select</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>31–32</TT></span> We initialize a descriptor set for <TT>select</TT> and calculate the maximum of the two descriptors for which we will wait.</p>

<H5 class="docExampleTitle"><A NAME="ch08fig24"></A>Figure 8.24 First half of echo server that handles TCP and UDP using <TT>select</TT>.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/udpservselect01.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd, udpfd, nready, maxfdp1;
 6     char    mesg[MAXLINE];
 7     pid_t   childpid;
 8     fd_set  rset;
 9     ssize_t n;
10     socklen_t len;
11     const int on = 1;
12     struct sockaddr_in cliaddr, servaddr;
13     void    sig_chld(int);

14         /* create listening TCP socket */
15     listenfd = Socket(AF_INET, SOCK_STREAM, 0);

16     bzero(&amp;servaddr, sizeof(servaddr));
17     servaddr.sin_family = AF_INET;
18     servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
19     servaddr.sin_port = htons(SERV_PORT);

20     Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));
21     Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));

22     Listen(listenfd, LISTENQ);

23          /* create UDP socket */
24     udpfd = Socket(AF_INET, SOCK_DGRAM, 0);

25     bzero(&amp;servaddr, sizeof(servaddr));
26     servaddr.sin_family = AF_INET;
27     servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
28     servaddr.sin_port = htons(SERV_PORT);

29     Bind(udpfd, (SA *) &amp;servaddr, sizeof(servaddr));
</PRE>


<A NAME="ch08lev3sec10"></A>
<H5 class="docSection3Title"> Call <TT>select</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>34–41</TT></span> We call <TT>select</TT>, waiting only for readability on the listening TCP socket or readability on the UDP socket. Since our <TT>sig_chld</TT> handler can interrupt our call to <TT>select</TT>, we handle an error of <TT>EINTR</TT>.</p>

<A NAME="ch08lev3sec11"></A>
<H5 class="docSection3Title"> Handle new client connection</H5>
<p class="docText"><span class="docEmphasis"><TT>42–51</TT></span> We <TT>accept</TT> a new client connection when the listening TCP socket is readable, <TT>fork</TT> a child, and call our <TT>str_echo</TT> function in the child. This is the same sequence of steps we used in <A class="docLink" HREF="0131411551_ch05.html#ch05">Chapter 5</A>.</p>

<H5 class="docExampleTitle"><A NAME="ch08fig25"></A>Figure 8.25 Second half of echo server that handles TCP and UDP using <TT>select</TT>.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/udpservselect01.c</span></P>

<PRE>
30     Signal(SIGCHLD, sig_chld);     /* must call waitpid() */

31     FD_ZERO(&amp;rset);
32     maxfdp1 = max(listenfd, udpfd) + 1;
33     for ( ; ; ) {
34         FD_SET(listenfd, &amp;rset);
35         FD_SET(udpfd, &amp;rset);
36         if ( (nready = select(maxfdp1, &amp;rset, NULL, NULL, NULL)) &lt; 0) {
37             if (errno == EINTR)
38                 continue;     /* back to for() */
39             else
40                 err_sys("select error");
41          }

42          if (FD_ISSET(listenfd, &amp;rset)) {
43              len = sizeof(cliaddr);
44              connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len);

45              if ( (childpid = Fork()) == 0) { /* child process */
46                  Close(listenfd);     /* close listening socket */
47                  str_echo(connfd);    /* process the request */
48                  exit(0);
49               }
50               Close(connfd);     /* parent closes connected socket */
51          }

52          if (FD_ISSET(udpfd, &amp;rset)) {
53              len = sizeof(cliaddr);
54              n = Recvfrom(udpfd, mesg, MAXLINE, 0, (SA *) &amp;cliaddr, &amp;len);

55              Sendto(udpfd, mesg, n, 0, (SA *) &amp;cliaddr, len);
56          }
57     }
58 }
</PRE>


<A NAME="ch08lev3sec12"></A>
<H5 class="docSection3Title"> Handle arrival of datagram</H5>
<p class="docText"><span class="docEmphasis"><TT>52–57</TT></span> If the UDP socket is readable, a datagram has arrived. We read it with <TT>recvfrom</TT> and send it back to the client with <TT>sendto</TT>.</p>



<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch08lev1sec14.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch08lev1sec16.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
