<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.13 'tcp_listen' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch11lev1sec12.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch11lev1sec14.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch11lev1sec13"></A>
<H3 class="docSection1Title">11.13 <TT>tcp_listen</TT> Function</H3>
<P class="docText">Our next function, <TT>tcp_listen</TT>, performs the normal TCP server steps: create a TCP socket, <TT>bind</TT> the server's well-known port, and allow incoming connection requests to be accepted. <A class="docLink" HREF="#ch11fig12">Figure 11.12</A> shows the source code.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include "unp.h"</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int tcp_listen (const char</TT> *<span class="docEmphasis">hostname</span>, <TT>const char</TT> *<span class="docEmphasis">service</span>, <TT>socklen_t</TT> *<span class="docEmphasis">addrlenp</span>);</P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: connected socket descriptor if OK, no return on error</P></TD></TR></COLGROUP></TABLE></P>
<A NAME="ch11lev3sec11"></A>
<H4 class="docSection2Title"> Call <TT>getaddrinfo</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>8–15</TT></span> We initialize an <TT>addrinfo</TT> structure with our hints: <TT>AI_PASSIVE</TT>, since this function is for a server, <TT>AF_UNSPEC</TT> for the address family, and <TT>SOCK_STREAM</TT>. Recall from <A class="docLink" HREF="0131411551_ch11lev1sec9.html#ch11fig08">Figure 11.8</A> that if a hostname is not specified (which is common for a server that wants to bind the wildcard address), the <TT>AI_PASSIVE</TT> and <TT>AF_UNSPEC</TT> hints will cause two socket address structures to be returned: the first for IPv6 and the next for IPv4 (assuming a dual-stack host).</p>

<A NAME="ch11lev3sec12"></A>
<H4 class="docSection2Title"> Create socket and bind address</H4>
<p class="docText"><span class="docEmphasis"><TT>16–25</TT></span> The <TT>socket</TT> and <TT>bind</TT> functions are called. If either call fails, we just ignore this <TT>addrinfo</TT> structure and move on to the next one. As stated in <A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A>, we always set th&egrave; <TT>SO_REUSEADDR</TT> socket option for a TCP server.</p>

<A NAME="ch11lev3sec13"></A>
<H4 class="docSection2Title"> Check for failure</H4>
<p class="docText"><span class="docEmphasis"><TT>26–27</TT></span> If all the calls to <TT>socket</TT> and <TT>bind</TT> fail, we print an error and terminate. As with our <TT>tcp_connect</TT> function in the previous section, we do not try to return an error from this function.</p>
<p class="docText"><span class="docEmphasis"><TT>28</TT></span> The socket is turned into a listening socket by <TT>listen</TT>.</p>

<A NAME="ch11lev3sec14"></A>
<H4 class="docSection2Title"> Return size of socket address structure</H4>
<p class="docText"><span class="docEmphasis"><TT>29–32</TT></span> If the <span class="docEmphasis">addrlenp</span> argument is non-null, we return the size of the protocol addresses through this pointer. This allows the caller to allocate memory for a socket address structure to obtain the client's protocol address from <TT>accept</TT>. (See <A class="docLink" HREF="0131411551_ch11lev1sec23.html#ch11lev1sec23">Exercise 11.7</A> also.)</p>

<A NAME="ch11lev2sec7"></A>
<H4 class="docSection2Title"> Example: Daytime Server</H4>
<P class="docText"><A class="docLink" HREF="#ch11fig13">Figure 11.13</A> shows our daytime server from <A class="docLink" HREF="0131411551_ch04lev1sec6.html#ch04fig11">Figure 4.11</A>, recoded to use <TT>tcp_listen</TT>.</P>
<A NAME="ch11lev3sec15"></A>
<H5 class="docSection3Title"> Require service name or port number as command-line argument</H5>
<p class="docText"><span class="docEmphasis"><TT>11–12</TT></span> We require a command-line argument to specify either the service name or port number. This makes it easier to test our server, since binding port 13 for the daytime server requires superuser privileges.</p>

<A NAME="ch11lev3sec16"></A>
<H5 class="docSection3Title"> Create listening socket</H5>
<p class="docText"><span class="docEmphasis"><TT>13</TT></span> <TT>tcp_listen</TT> creates the listening socket. We pass a NULL pointer as the third argument because we don't care what size address structure the address family uses; we will use <TT>sockaddr_storage</TT>.</p>

<H5 class="docExampleTitle"><A NAME="ch11fig12"></A>Figure 11.12 <TT>tcp_listen</TT> function: performs normal server steps.</H5>
<P class="docText"><span class="docEmphasis">lib/tcp_listen.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 tcp_listen(const char *host, const char *serv, socklen_t *addrlenp)
 4 {
 5     int      listenfd, n;
 6     const int on = 1;
 7     struct addrinfo hints, *res, *ressave;

 8     bzero(&amp;hints, sizeof (struct addrinfo)) ;
 9     hints.ai_flags = AI_PASSIVE;
10     hints.ai_family = AF_UNSPEC;
11     hints.ai_socktype = SOCK_STREAM;

12     if ( (n = getaddrinfo (host, serv, &amp;hints, &amp;res)) != 0)
13         err_quit("tcp_listen error for %s, %s: %s",
14                  host, serv, gai_strerror(n)) ;
15     ressave = res;

16     do {
17         listenfd =
18             socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
19         if (listenfd &lt; 0)
20             continue;            /* error, try next one */

21         Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof (on) ) ;
22         if (bind(listenfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == 0)
23             break;               /* success */

24         Close (listenfd);        /* bind error, close and try next one */
25      } while ( (res = res-&gt;ai_next) != NULL);

26      if (res == NULL)            /* errno from final socket () or bind () */
27          err_sys ("tcp_listen error for %s, %s", host, serv);

28      Listen (listenfd, LISTENQ);

29      if (addrlenp)
30          *addrlenp = res-&gt;ai_addrlen;     /* return size of protocol address */

31      freeaddrinfo (ressave);

32      return (listenfd);
33 }
</PRE>


<A NAME="ch11lev3sec17"></A>
<H5 class="docSection3Title"> Server loop</H5>
<p class="docText"><span class="docEmphasis"><TT>14–22</TT></span> <TT>accept</TT> waits for each client connection. We print the client address by calling <TT>sock_ntop</TT>. In the case of either IPv4 or IPv6, this function prints the IP address and port number. We could use the function <TT>getnameinfo</TT> (<A class="docLink" HREF="0131411551_ch11lev1sec17.html#ch11lev1sec17">Section 11.17</A>) to try to obtain the hostname of the client, but that involves a PTR query in the DNS, which can take some time, especially if the PTR query fails. Section 14.8 of TCPv3 notes that on a busy Web server, almost 25% of all clients connecting to that server did not have PTR records in the DNS. Since we do not want a server (especially an iterative server) to wait seconds for a PTR query, we just print the IP address and port.
</p>

<H5 class="docExampleTitle"><A NAME="ch11fig13"></A>Figure 11.13 Daytime server recoded to use <TT>tcp_listen</TT> (see also <A class="docLink" HREF="#ch11fig14">Figure 11.14</A>).</H5>
<P class="docText"><span class="docEmphasis">names/daytimetcpsrv1.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     &lt;time.h&gt;

 3 int
 4 main(int argc, char **argv)
 5 {
 6     int     listenfd, connfd;
 7     socklen_t len;
 8     char    buff[MAXLINE];
 9     time_t  ticks;
10     struct sockaddr_storage cliaddr;

11     if (argc != 2)
12         err_quit("usage: daytimetcpsrv1 &lt;service or port#&gt;");

13     listenfd = Tcp_listen (NULL, argv[1], NULL);

14     for ( ; ; ) {
15         len = sizeof (cliaddr);
16         connfd = Accept (listenfd, (SA *) &amp;cliaddr, &amp;len);
17         printf("connection from %s\n", Sock_ntop ( (SA *) &amp;cliaddr, len) );

18         ticks = time (NULL);
19         snprintf(buff, sizeof (buff), "%.24s\r\n", ctime (&amp;ticks) ) ;
20         Write(connfd, buff, strlen (buff) ) ;

21         Close (connfd);
22     }
23 }
</PRE>



<A NAME="ch11lev2sec8"></A>
<H4 class="docSection2Title"> Example: Daytime Server with Protocol Specification</H4>
<P class="docText">There is a slight problem with <A class="docLink" HREF="#ch11fig13">Figure 11.13</A>: The first argument to <TT>tcp_listen</TT> is a null pointer, which combined with the address family of <TT>AF_UNSPEC</TT> that <TT>tcp_listen</TT> specifies might cause <TT>getaddrinfo</TT> to return a socket address structure with an address family other than what is desired. For example, the first socket address structure returned will be for IPv6 on a dual-stack host <A class="docLink" HREF="0131411551_ch11lev1sec9.html#ch11fig08">Figure 11.8</A>, but we might want our server to handle only IPv4.</P>
<P class="docText">Clients do not have this problem since the client must always specify either an IP address or a hostname. Client applications normally allow the user to enter this as a command-line argument. This gives us the opportunity to specify a hostname that is associated with a particular type of IP address (recall our <TT>-4</TT> and <TT>-6</TT> hostnames in <A class="docLink" HREF="0131411551_ch11lev1sec2.html#ch11lev1sec2">Section 11.2</A>), or to specify either an IPv4 dotted-decimal string (forcing IPv4) or an IPv6 hex string (forcing IPv6).</P>
<P class="docText">But there is a simple technique for servers that lets us force a given protocol on a server, either IPv4 or IPv6: Allow the user to enter either an IP address or a hostname as a command-line argument to the program and pass this to <TT>getaddrinfo</TT>. In the case of an IP address, an IPv4 dotted-decimal string differs from an IPv6 hex string. The following calls to <TT>inet_pton</TT> either fail or succeed, as indicated:</P>
<pre>

</pre><pre>
inet_pton (AF_INET,  "0.0.0.0", &amp;foo);   /* succeeds */
inet_pton (AF_INET,  "0::0",    &amp;foo);   /* fails */
inet_pton (AF_INET6, "0.0.0.0", &amp;foo);   /* fails */
inet_pton (AF_INET6, "0::0",    &amp;foo);   /* succeeds */
</pre><pre>
</pre>
<P class="docText">Therefore, if we change our servers to accept an optional argument, and if we enter</P>
<pre>

</pre><pre>
% server
</pre><pre>
</pre>
<P class="docText">it defaults to IPv6 on a dual-stack host, but entering</P>
<pre>

</pre><pre>
% server 0.0.0.0
</pre><pre>
</pre>
<P class="docText">explicitly specifies IPv4 and</P>
<pre>

</pre><pre>
% server 0::0
</pre><pre>
</pre>
<P class="docText">explicitly specifies IPv6.</P>
<P class="docText"><A class="docLink" HREF="#ch11fig14">Figure 11.14</A> shows this final version of our daytime server.</P>
<A NAME="ch11lev3sec18"></A>
<H5 class="docSection3Title"> Handle command-line arguments</H5>
<p class="docText"><span class="docEmphasis"><TT>11–16</TT></span> The only change from <A class="docLink" HREF="#ch11fig13">Figure 11.13</A> is the handling of the command-line arguments, allowing the user to specify either a hostname or an IP address for the server to bind, in addition to a service name or port.</p>
<P class="docText">We first start this server with an IPv4 socket and then connect to the server from clients on two other hosts on the local subnet.</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">daytimetcpsrv2 0.0.0.0 9999</span>
connection from 192.168.42.2:32961
connection from 192.168.42.3:1389
</pre><pre>
</pre>
<P class="docText">Now we start the server with an IPv6 socket.</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">daytimetcpsrv2 0: :0 9999</span>
c&oacute;nnection from [3ffe:b80:1f8d:2:204:acff:fe17:bf38]:32964
connection from [3ffe:b80:1f8d:2:230:65ff:fe15:caa7]:49601
connection from [::ffff:192.168.42.2]:32967
connection from [::ffff:192.168.42.3]:49602
</pre><pre>
</pre>
<P class="docText">The first connection is from the host <TT>aix</TT> using IPv6 and the second is from the host <TT>macosx</TT> using IPv6. The next two connections are from the hosts <TT>aix</TT> and <TT>macosx</TT>, but using IPv4, not IPv6. We can tell this because the client's addresses returned by <TT>accept</TT> are both IPv4-mapped IPv6 addresses.</P>
<P class="docText">What we have just shown is that an IPv6 server running on a dual-stack host can handle either IPv4 or IPv6 clients. The IPv4 client addresses are passed to the IPv6 server as IPv4-mapped IPv6 addresses, as we will discuss in <A class="docLink" HREF="0131411551_ch12lev1sec2.html#ch12lev1sec2">Section 12.2</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch11fig14"></A>Figure 11.14 Protocol-independent daytime server that uses <TT>tcp_listen</TT>.</H5>
<P class="docText"><span class="docEmphasis">names/daytimetcpsrv2.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     &lt;time.h&gt;

 3 int
 4 main (int argc, char **argv)
 5 {
 6     int     listenfd, connfd;
 7     socklen_t len;
 8     char     buff [MAXLINE];
 9     time_t ticks;
10     struct sockaddr_storage cliaddr;

11     if (argc == 2)
12         listenfd = Tcp_listen (NULL, argv [1], &amp;addrlen);
13     else if (argc == 3)
14         listenfd = Tcp_listen (argv [1], argv[2], &amp;addrlen);
15     else
16         err_quit ("usage: daytimetcpsrv2 [ &lt;host&gt; ] &lt;service or port&gt;");

17     for ( ; ; ) {
18         len = sizeof (cliaddr);
19         connfd = Accept (listenfd, (SA *) &amp;cliaddr, &amp;len);
20         printf ("connection from %s\n", Sock_ntop ((SA *) &amp;cliaddr, len) ) ;

21         ticks = time (NULL);
22         snprintf (buff, sizeof (buff), "%.24s\r\n", ctime (&amp;ticks) ) ;
23         Write (connfd, buff, strlen (buff) ) ;

24         Close (connfd);
25     }
26 }
</PRE>




<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch11lev1sec12.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch11lev1sec14.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
