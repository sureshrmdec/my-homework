<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="22.8 IPv6 Packet Information"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch22lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch22lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch22lev1sec8"></A>
<H3 class="docSection1Title">22.8 IPv6 Packet Information</H3>
<P class="docText">IPv6 allows an application to specify up to five pieces of information for an outgoing datagram:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Source IPv6 address</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Outgoing interface index</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Outgoing hop limit</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Next-hop address</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Outgoing traffic class</P></span></LI></OL></span>
<P class="docText">This information is sent as ancillary data with <TT>sendmsg</TT>. "Sticky" values can be set for the socket, so that they apply to every packet sent, as described in <A class="docLink" HREF="0131411551_ch27lev1sec7.html#ch27lev1sec7">Section 27.7</A>. Four similar pieces of information can be returned for a received packet, and they are returned as ancillary data with <TT>recvmsg</TT>:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Destination IPv6 address</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Arriving interface index</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Arriving hop limit</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Arriving traffic class</P></span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="#ch22fig21">Figure 22.21</A> summarizes the contents of the ancillary data, which we will discuss shortly.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch22fig21"></A>Figure 22.21. Ancillary data for IPv6 packet information.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="368" src="FILES/22fig21.gif" ALT="graphics/22fig21.gif"></p>

</CENTER>
<P class="docText">An <TT>in6_pktinfo</TT> structure contains either the source IPv6 address and outgoing interface index for an outgoing datagram or the destination IPv6 address and arriving interface index for a received datagram.</P>
<pre>

</pre><pre>
struct in6_pktinfo {
  struct in6_addr ipi6_addr;     /* src/dst IPv6 address */
  int             ipi6_ifindex;  /* send/recv interface index */
};
</pre><pre>
</pre>
<P class="docText">This structure is defined by including the <TT>&lt;netinet/in.h&gt;</TT> header. In the <TT>cmsghdr</TT> structure containing this ancillary data, the <TT>cmsg_level</TT> member will be <TT>IPPROTO_IPV6</TT>, the <TT>cmsg_type</TT> member will be <TT>IPV6_PKTINFO</TT>, and the first byte of data will be the first byte of the <TT>in6_pktinfo</TT> structure. In the example in <A class="docLink" HREF="#ch22fig21">Figure 22.21</A>, we assume no padding between the <TT>cmsghdr</TT> structure and the data, and 4 bytes for an integer.</P>
<P class="docText">To specify this information for a given packet, just specify the control information as ancillary data for <TT>sendmsg</TT>. To specify this information for all packets sent on a socket, set the <TT>IPV6_PKTINFO</TT> socket option with the <TT>in6_pktinfo</TT> as the option value as described in <A class="docLink" HREF="0131411551_ch27lev1sec7.html#ch27lev1sec7">Section 27.7</A>. This information is returned as ancillary data by <TT>recvmsg</TT> only if the application has the <TT>IPV6_RECVPKTINFO</TT> socket option enabled.</P>
<A NAME="ch22lev2sec3"></A>
<H4 class="docSection2Title"> Outgoing and Arriving Interface</H4>
<P class="docText">Interfaces on an IPv6 node are identified by positive integers, as we discussed in <A class="docLink" HREF="0131411551_ch18lev1sec6.html#ch18lev1sec6">Section 18.6</A>. Recall that no interface is ever assigned an index of 0. When specifying the outgoing interface, if the <TT>ipi6_ifindex</TT> value is 0, the kernel will choose the outgoing interface. If the application specifies an outgoing interface for a multicast packet, the interface specified by the ancillary data overrides any interface specified by the <TT>IPV6_MULTICAST_IF</TT> socket option for this datagram only.</P>

<A NAME="ch22lev2sec4"></A>
<H4 class="docSection2Title"> Source and Destination IPv6 Addresses</H4>
<P class="docText">The source IPv6 address is normally specified by calling <TT>bind</TT>. Supplying the source address together with the data may require less overhead. This option also allows a server to guarantee that the source address of its reply equals the destination address of the client's request, a feature some clients require and that is harder to accomplish with IPv4 (<A class="docLink" HREF="0131411551_ch22lev1sec11.html#ch22lev1sec11">Exercise 22.4</A>).</P>
<P class="docText">When specifying the source IPv6 address as ancillary data, if the <TT>ipi6_addr</TT> member of the <TT>in6_pktinfo</TT> structure is <TT>IN6ADDR_ANY_INIT</TT>, then: (i) if an address is currently bound to the socket, it is used as the source address, or (ii) if no address is currently bound to the socket, the kernel will choose the source address. If the <TT>ipi6_addr</TT> member is not the unspecified address, but the socket has already bound a source address, then the <TT>ipi6_addr</TT> value overrides the already bound source address for this output operation only. The kernel will verify that the requested source address is indeed a unicast address assigned to the node.</P>
<P class="docText">When the <TT>in6_pktinfo</TT> structure is returned as ancillary data by <TT>recvmsg</TT>, the <TT>ipi6_addr</TT> member contains the destination IPv6 address from the received packet. This is similar in concept to the <TT>IP_RECVDSTADDR</TT> socket option for IPv4.</P>

<A NAME="ch22lev2sec5"></A>
<H4 class="docSection2Title"> Specifying and Receiving the Hop Limit</H4>
<P class="docText">The outgoing hop limit is normally specified with either the <TT>IPV6_UNICAST_HOPS</TT> socket option for unicast datagrams (<A class="docLink" HREF="0131411551_ch07lev1sec8.html#ch07lev1sec8">Section 7.8</A>) or the <TT>IPV6_MULTICAST_HOPS</TT> socket option for multicast datagrams (<A class="docLink" HREF="0131411551_ch21lev1sec6.html#ch21lev1sec6">Section 21.6</A>). Specifying the hop limit as ancillary data lets us override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received hop limit is useful for programs such as <TT>traceroute</TT> and for a class of IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).</P>
<P class="docText">The received hop limit is returned as ancillary data by <TT>recvmsg</TT> only if the application has enabled the <TT>IPV6_RECVHOPLIMIT</TT> socket option. In the <TT>cmsghdr</TT> structure containing this ancillary data, the <TT>cmsg_level</TT> member will be <TT>IPPROTO_IPV6</TT>, the <TT>cmsg_type</TT> member will be <TT>IPV6_HOPLIMIT</TT>, and the first byte of data will be the first byte of the (4-byte) integer hop limit. We showed this in <A class="docLink" HREF="#ch22fig21">Figure 22.21</A>. Realize that the value returned as ancillary data is the actual value from the received datagram, while the value returned by a <TT>getsockopt</TT> of the <TT>IPV6_UNICAST_HOPS</TT> option is the default value the kernel will use for outgoing datagrams on the socket.</P>
<P class="docText">To control the outgoing hop limit for a given packet, just specify the control information as ancillary data for <TT>sendmsg</TT>. The normal values for the hop limit are between 0 and 255, inclusive, but if the integer value is -1, this tells the kernel to use its default.</P>
<BLOCKQUOTE><P><P class="docList">The hop limit is not contained in the <TT>in6_pktinfo</TT> structure for the following reason: Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request. To do this, the application can enable just the <TT>IPV6_RECVPKTINFO</TT> socket option and then use the received control information from <TT>recvmsg</TT> as the outgoing control information for <TT>sendmsg</TT>. The application need not examine or modify the <TT>in6_pktinfo</TT> structure at all. But if the hop limit was contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.</P></P></BLOCKQUOTE>

<A NAME="ch22lev2sec6"></A>
<H4 class="docSection2Title"> Specifying the Next-Hop Address</H4>
<P class="docText">The <TT>IPV6_NEXTHOP</TT> ancillary data object specifies the next hop for the datagram as a socket address structure. In the <TT>cmsghdr</TT> structure containing this ancillary data, the <TT>cmsg_level</TT> member is <TT>IPPROTO_IPV6</TT>, the <TT>cmsg_type</TT> member is <TT>IPV6_NEXTHOP</TT>, and the first byte of data is the first byte of the socket address structure.</P>
<P class="docText">In <A class="docLink" HREF="#ch22fig21">Figure 22.21</A>, we show an example of this ancillary data object, assuming the socket address structure is a 28-byte <TT>sockaddr_in6</TT> structure. In this case, the node identified by that address must be a neighbor of the sending host. If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing <TT>SO_DONTROUTE</TT> socket option. The next-hop address can be set for all packets on a socket by setting the <TT>IPv6_NEXTHOP</TT> socket option with the <TT>sockaddr_in6</TT> as the option value, as described in <A class="docLink" HREF="0131411551_ch27lev1sec7.html#ch27lev1sec7">Section 27.7</A>. Setting this option requires superuser privileges.</P>

<A NAME="ch22lev2sec7"></A>
<H4 class="docSection2Title"> Specifying and Receiving the Traffic Class</H4>
<P class="docText">The <TT>IPV6_TCLASS</TT> ancillary data object specifies the traffic class for the datagram. In the <TT>cmsghdr</TT> structure containing this ancillary data, the <TT>cmsg_level</TT> member will be <TT>IPPROTO_IPV6</TT>, the <TT>cmsg_type</TT> member will be <TT>IPV6_TCLASS</TT>, and the first byte of data will be the first byte of the (4-byte) integer traffic class. We showed this in <A class="docLink" HREF="#ch22fig21">Figure 22.21</A>. As described in <A class="docLink" HREF="0131411551_app01lev1sec3.html#app01lev1sec3">Section A.3</A>, the traffic class is made up of the <span class="docEmphasis">DSCP</span> and <span class="docEmphasis">ECN</span> fields. These fields must be set together. The kernel may mask or ignore the user-specified value if it needs to control the value (e.g., if the kernel implements ECN, it may set the ECN bits to its own desired value, ignoring the two bits specified with the <TT>IPV6_TCLASS</TT> option). The traffic class specified may be in the normal range of 0 to 255, or -1 to allow the kernel to use its default value.</P>
<P class="docText">To specify the traffic class for a given packet, include the ancillary data with that packet. To specify the traffic class for all packets on a socket, specify the traffic class as an integer to the <TT>IPV6_TCLASS</TT> socket option, as described in <A class="docLink" HREF="0131411551_ch27lev1sec7.html#ch27lev1sec7">Section 27.7</A>. The received traffic class is returned as ancillary data by <TT>recvmsg</TT> only if the application has the <TT>IPV6_RECVTCLASS</TT> socket option enabled.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch22lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch22lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
