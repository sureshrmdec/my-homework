<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.6 'getaddrinfo' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch11lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch11lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch11lev1sec6"></A>
<H3 class="docSection1Title">11.6 <TT>getaddrinfo</TT> Function</H3>
<P class="docText">The <TT>gethostbyname</TT> and <TT>gethostbyaddr</TT> functions only support IPv4. The API for resolving IPv6 addresses went through several iterations, as will be described in <A class="docLink" HREF="0131411551_ch11lev1sec20.html#ch11lev1sec20">Section 11.20</A>; the final result is the <TT>getaddrinfo</TT> function. The <TT>getaddrinfo</TT> function handles both name-to-address and service-to-port translation, and returns <TT>sockaddr</TT> structures instead of a list of addresses. These <TT>sockaddr</TT> structures can then be used by the socket functions directly. In this way, the <TT>getaddrinfo</TT> function hides all the protocol dependencies in the library function, which is where they belong. The application deals only with the socket address structures that are filled in by <TT>getaddrinfo</TT>. This function is defined in the POSIX specification.</P>
<BLOCKQUOTE><P><P class="docList">The POSIX definition of this function comes from an earlier proposal by Keith Sklower for a function named <TT>getconninfo</TT>. This function was the result of discussions with Eric Allman, William Durst, Michael Karels, and Steven Wise, and from an early implementation written by Eric Allman. The observation that specifying a hostname and a service name would suffice for connecting to a service independent of protocol details was made by Marshall Rose in a proposal to X/Open.</P></P></BLOCKQUOTE>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;netdb.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int getaddrinfo (const char *</TT><span class="docEmphasis">hostname</span>, <TT>const char *</TT><span class="docEmphasis">service</span>, <TT>const struct addrinfo *</TT><span class="docEmphasis">hints</span>, <TT>struct addrinfo **</TT><span class="docEmphasis">result</span>) ;</P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK, nonzero on error (see <A class="docLink" HREF="0131411551_ch11lev1sec7.html#ch11fig07">Figure 11.7</A>)</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">This function returns through the <span class="docEmphasis">result</span> pointer a pointer to a linked list of <TT>addrinfo</TT> structures, which is defined by including <TT>&lt;netdb.h&gt;</TT>.</P>
<pre>

</pre><pre>
struct addrinfo {
   int          ai_flags;           /* AI_PASSIVE, AI_CANONNAME */
   int          ai_family;          /* AF_xxx */
   int          ai_socktype;        /* SOCK_xxx */
   int          ai_protocol;        /* 0 or IPPROTO_xxx for IPv4 and IPv6 */
   socklen_t    ai_addrlen;         /* length of ai_addr */
   char        *ai_canonname;       /* ptr to canonical name for host */
   struct sockaddr    *ai_addr;     /* ptr to socket address structure */
   struct addrinfo    *ai_next;     /* ptr to next structure in linked list */
};
</pre><pre>
</pre>
<P class="docText">The <span class="docEmphasis">hostname</span> is either a hostname or an address string (dotted-decimal for IPv4 or a hex string for IPv6). The <span class="docEmphasis">service</span> is either a service name or a decimal port number string. (See also <A class="docLink" HREF="0131411551_ch11lev1sec23.html#ch11lev1sec23">Exercise 11.4</A>, where we want to allow an address string for the host or a port number string for the service.)</P>
<P class="docText"><span class="docEmphasis">hints</span> is either a null pointer or a pointer to an <TT>addrinfo</TT> structure that the caller fills in with hints about the types of information the caller wants returned. For example, if the specified service is provided for both TCP and UDP (e.g., the <TT>domain</TT> service, which refers to a DNS server), the caller can set the <TT>ai_socktype</TT> member of the <span class="docEmphasis">hints</span> structure to <TT>SOCK_DGRAM</TT>. The only information returned will be for datagram sockets.</P>
<P class="docText">The members of the <span class="docEmphasis">hints</span> structure that can be set by the caller are:</P>
<UL><LI><P class="docList"><TT>ai_flags</TT> (zero or more <TT>AI_</TT><span class="docEmphasis"><TT>XXX</TT></span> values <span class="docEmphasis">OR'ed</span> together)</P></LI><LI><P class="docList"><TT>ai_family</TT> (an <TT>AF_</TT><span class="docEmphasis">xxx</span> value)</P></LI><LI><P class="docList"><TT>ai_socktype</TT> (a <TT>SOCK_</TT><span class="docEmphasis">xxx</span> value)</P></LI><LI><P class="docList"><TT>ai_protocol</TT></P></LI></UL>
<P class="docText">The possible values for the <TT>ai_flags</TT> member and their meanings are:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_PASSIVE</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">The caller will use the socket for a passive open.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_CANONNAME</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Tells the function to return the canonical name of the host.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_NUMERICHOST</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Prevents any kind of name-to-address mapping; the <span class="docEmphasis">hostname</span> argument must be an address string.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_NUMERICSERV</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Prevents any kind of name-to-service mapping; the <span class="docEmphasis">service</span> argument must be a decimal port number string.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_V4MAPPED</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">If specified along with an <TT>ai_family</TT> of <TT>AF_INET6</TT>, then returns IPv4-mapped IPv6 addresses corresponding to A records if there are no available AAAA records.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_ALL</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">If specified along with <TT>AI_V4MAPPED</TT>, then returns IPv4-mapped IPv6 addresses in addition to any AAAA records belonging to the name.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>AI_ADDRCONFIG</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Only looks up addresses for a given IP version if there is one or more interface that is not a loopback interface configured with an IP address of that version.</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">If the <span class="docEmphasis">hints</span> argument is a null pointer, the function assumes a value of 0 for <TT>ai_flags</TT>, <TT>ai_socktype</TT>, and <TT>ai_protocol</TT>, and a value of <TT>AF_UNSPEC</TT> for <TT>ai_family</TT>.</P>
<P class="docText">If the function returns success (0), the variable pointed to by the <span class="docEmphasis">result</span> argument is filled in with a pointer to a linked list of <TT>addrinfo</TT> structures, linked through the <TT>ai_next</TT> pointer. There are two ways that multiple structures can be returned:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">If there are multiple addresses associated with the <span class="docEmphasis">hostname</span>, one structure is returned for each address that is usable with the requested address family (the <TT>ai_family</TT> hint, if specified).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">If the service is provided for multiple socket types, one structure can be returned for each socket type, depending on the <TT>ai_socktype</TT> hint. (Note that most <TT>getaddrinfo</TT> implementations consider a port number string to be implemented only by the socket type requested in <TT>ai_socktype</TT>; if <TT>ai_socktype</TT> is not specified, an error is returned instead.)</P></span></LI></OL></span>
<P class="docText">For example, if no hints are provided and if the <TT>domain</TT> service is looked up for a host with two IP addresses, four <TT>addrinfo</TT> structures are returned:</P>
<UL><LI><P class="docList">One for the first IP address and a socket type of <TT>SOCK_STREAM</TT></P></LI><LI><P class="docList">One for the first IP address and a socket type of <TT>SOCK_DGRAM</TT></P></LI><LI><P class="docList">One for the second IP address and a socket type of <TT>SOCK_STREAM</TT></P></LI><LI><P class="docList">One for the second IP address and a socket type of <TT>SOCK_DGRAM</TT></P></LI></UL>
<P class="docText">We show this example in <A class="docLink" HREF="#ch11fig05">Figure 11.5</A>. There is no guaranteed order of the structures when multiple items are returned; that is, we cannot assume that TCP services will be returned before UDP services.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch11fig05"></A>Figure 11.5. Example of information returned by <TT>getaddrinfo</TT>.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="640" src="FILES/11fig05.jpg" ALT="graphics/11fig05.jpg"></p>

</CENTER>
<BLOCKQUOTE><P><P class="docList">Although not guaranteed, an implementation should return the IP addresses in the same order as they are returned by the DNS. Some resolvers allow the administrator to specify an address sorting order in the <TT>/etc/resolv.conf</TT> file. IPv6 specifies address selection rules (RFC 3484 [Draves 2003]), which could affect the order of addresses returned by <TT>getaddrinfo</TT>.</P></P></BLOCKQUOTE>
<P class="docText">The information returned in the <TT>addrinfo</TT> structures is ready for a call to <TT>socket</TT> and then either a call to <TT>connect</TT> or <TT>sendto</TT> (for a client), or <TT>bind</TT> (for a server). The arguments to <TT>socket</TT> are the members <TT>ai_family</TT>, <TT>ai_socktype</TT>, and <TT>ai_protocol</TT>. The second and third arguments to either <TT>connect</TT> or <TT>bind</TT> are <TT>ai_addr</TT> (a pointer to a socket address structure of the appropriate type, filled in by <TT>getaddrinfo</TT>) and <TT>ai_addrlen</TT> (the length of this socket address structure).</P>
<P class="docText">If the <TT>AI_CANONNAME</TT> flag is set in the <span class="docEmphasis">hints</span> structure, the <TT>ai_canonname</TT> member of the first returned structure points to the canonical name of the host. In terms of the DNS, this is normally the FQDN. Programs like <TT>telnet</TT> commonly use this flag to be able to print the canonical hostname of the system to which they are connecting, so that if the user supplied a shortcut or an alias, he or she knows what got looked up.</P>
<P class="docText"><A class="docLink" HREF="#ch11fig05">Figure 11.5</A> shows the returned information if we execute the following:</P>
<pre>

</pre><pre>
struct addrinfo          hints, *res;

bzero(&amp;hints, sizeof(hints) ) ;
hints.ai_flags = AI_CANONNAME;
hints.ai_family = AF_INET;

getaddrinfo("freebsd4", "domain", &amp;hints, &amp;res);
</pre><pre>
</pre>
<P class="docText">In this figure, everything except the <TT>res</TT> variable is dynamically allocated memory (e.g., from <TT>malloc</TT>). We assume that the canonical name of the host <TT>freebsd4</TT> is <TT>freebsd4.unpbook.com</TT> and that this host has two IPv4 addresses in the DNS.</P>
<P class="docText">Port 53 is for the <TT>domain</TT> service. This port number will be in network byte order in the socket address structures. We also show the returned <TT>ai_protocol</TT> values as IPPROTO_TCP or IPPROTO_UDP. It would also be acceptable for <TT>getaddrinfo</TT> to return an <TT>ai_protocol</TT> of 0 for the two <TT>SOCK_STREAM</TT> structures if that is sufficient to specify TCP (it is not sufficient if the system implements SCTP, for example), and an <TT>ai_protocol</TT> of 0 for the two <TT>SOCK_DGRAM</TT> structures if the system doesn't implement any other <TT>SOCK_DGRAM</TT> protocols for IP (as of this writing, none are yet standardized, but two are in development in the IETF). It is safest for <TT>getaddrinfo</TT> to always return the specific protocol.</P>
<P class="docText"><A class="docLink" HREF="#ch11fig06">Figure 11.6</A> summarizes the number of <TT>addrinfo</TT> structures returned for each address that is being returned, based on the specified service name (which can be a decimal port number) and any <TT>ai_socktype</TT> hint.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch11fig06"></A>Figure 11.6. Number of <TT>addrinfo</TT> structures returned per IP address.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="93" src="FILES/11fig06.gif" ALT="graphics/11fig06.gif"></p>

</CENTER>
<P class="docText">Multiple <TT>addrinfo</TT> structures are returned for each IP address only when no <TT>ai_socktype</TT> hint is provided and the service name is supported by multiple transport protocols (as indicated in the <TT>/etc/services</TT> file).</P>
<P class="docText">If we were to enumerate all 64 possible inputs to <TT>getaddrinfo</TT> (there are six input variables), many would be invalid and some would make little sense. Instead, we will look at the common cases.</P>
<UL><LI><P class="docList">Specify the <span class="docEmphasis">hostname</span> and <span class="docEmphasis">service</span>. This is normal for a TCP or UDP client. On return, a TCP client loops through all returned IP addresses, calling <TT>socket</TT> and <TT>connect</TT> for each one, until the connection succeeds or until all addresses have been tried. We will show an example of this with our <TT>tcp_connect</TT> function in <A class="docLink" HREF="0131411551_ch11lev1sec12.html#ch11fig10">Figure 11.10</A>.</P></LI><LI><P class="docList">For a UDP client, the socket address structure filled in by <TT>getaddrinfo</TT> would be used in a call to <TT>sendto</TT> or <TT>connect</TT>. If the client can tell that the first address doesn't appear to work (either by receiving an error on a connected UDP socket or by experiencing a timeout on an unconnected socket), additional addresses can be tried.</P></LI><LI><P class="docList">If the client knows it handles only one type of socket (e.g., Telnet and FTP clients handle only TCP; TFTP clients handle only UDP), then the <TT>ai_socktype</TT> member of the <span class="docEmphasis">hints</span> structure should be specified as either <TT>SOCK_STREAM</TT> or <TT>SOCK_DGRAM</TT>.</P></LI><LI><P class="docList">A typical server specifies the <span class="docEmphasis">service</span> but not the <span class="docEmphasis">hostname</span>, and specifies the <TT>AI_PASSIVE</TT> flag in the <span class="docEmphasis">hints</span> structure. The socket address structures returned should contain an IP address of <TT>INADDR_ANY</TT> (for IPv4) or <TT>IN6ADDR_ANY_INIT</TT> (for IPv6). A TCP server then calls <TT>socket</TT>, <TT>bind</TT>, and <TT>listen</TT>. If the server wants to <TT>malloc</TT> another socket address structure to obtain the client's address from <TT>accept</TT>, the returned <TT>ai_addrlen</TT> value specifies this size.</P></LI><LI><P class="docList">A UDP server would call <TT>socket</TT>, <TT>bind</TT>, and then <TT>recvfrom</TT>. If the server wants to <TT>malloc</TT> another socket address structure to obtain the client's address from <TT>recvfrom</TT>, the returned <TT>ai_addrlen</TT> value specifies this size.</P></LI><LI><P class="docList">As with the typical client code, if the server knows it only handles one type of socket, the <TT>ai_socktype</TT> member of the <span class="docEmphasis">hints</span> structure should be set to either <TT>SOCK_STREAM</TT> or <TT>SOCK_DGRAM</TT>. This avoids having multiple structures returned, possibly with the wrong <TT>ai_socktype</TT> value.</P></LI><LI><P class="docList">The TCP servers that we have shown so far create one listening socket, and the UDP servers create one datagram socket. That is what we assume in the previous item. An alternate server design is for the server to handle multiple sockets using <TT>select</TT> or <TT>poll</TT>. In this scenario, the server would go through the entire list of structures returned by <TT>getaddrinfo</TT>, create one socket per structure, and use <TT>select</TT> or <TT>poll</TT>.</P><BLOCKQUOTE><P><P class="docList">The problem with this technique is that one reason for <TT>getaddrinfo</TT> returning multiple structures is when a service can be handled by IPv4 and IPv6 (<A class="docLink" HREF="0131411551_ch11lev1sec9.html#ch11fig08">Figure 11.8</A>). But, these two protocols are not completely independent, as we will see in <A class="docLink" HREF="0131411551_ch12lev1sec2.html#ch12lev1sec2">Section 12.2</A>. That is, if we create a listening IPv6 socket for a given port, there is no need to also create a listening IPv4 socket for that same port, because connections arriving from IPv4 clients are automatically handled by the protocol stack and by the IPv6 listening socket, assuming that the <TT>IPV6_V6ONLY</TT> socket option is not set.</P></P></BLOCKQUOTE></LI></UL>
<P class="docText">Despite the fact that <TT>getaddrinfo</TT> is "better" than the <TT>gethostbyname</TT> and <TT>getservbyname</TT> functions (it makes it easier to write protocol-independent code; one function handles both the hostname and the service; and all the returned information is dynamically allocated, not statically allocated), it is still not as easy to use as it could be. The problem is that we must allocate a <span class="docEmphasis">hints</span> structure, initialize it to 0, fill in the desired fields, call <TT>getaddrinfo</TT>, and then traverse a linked list trying each one. In the next sections, we will provide some simpler interfaces for the typical TCP and UDP clients and servers that we will write in the remainder of this text.</P>
<P class="docText"><TT>getaddrinfo</TT> solves the problem of converting hostnames and service names into socket address structures. In <A class="docLink" HREF="0131411551_ch11lev1sec17.html#ch11lev1sec17">Section 11.17</A>, we will describe the reverse function, <TT>get nameinfo</TT>, which converts socket address structures into hostnames and service names.</P>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch11lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch11lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
