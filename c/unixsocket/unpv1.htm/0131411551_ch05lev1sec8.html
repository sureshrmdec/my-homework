<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.8 POSIX Signal Handling"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec8"></A>
<H3 class="docSection1Title">5.8 POSIX Signal Handling</H3>
<P class="docText">A <span class="docEmphasis">signal</span> is a notification to a process that an event has occurred. Signals are sometimes called <span class="docEmphasis">software interrupts</span>. Signals usually occur <span class="docEmphasis">asynchronously</span>. By this we mean that a process doesn't know ahead of time exactly when a signal will occur.</P>
<P class="docText">Signals can be sent</P>
<UL><LI><P class="docList">By one process to another process (or to itself)</P></LI><LI><P class="docList">By the kernel to a process</P></LI></UL>
<P class="docText">The <TT>SIGCHLD</TT> signal that we described at the end of the previous section is one that is sent by the kernel whenever a process terminates, to the parent of the terminating process.</P>
<P class="docText">Every signal has a <span class="docEmphasis">disposition</span>, which is also called the <span class="docEmphasis">action</span> associated with the signal. We set the disposition of a signal by calling the <TT>sigaction</TT> function (described shortly) and we have three choices for the disposition:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">We can provide a function that is called whenever a specific signal occurs. This function is called a <span class="docEmphasis">signal handler</span> and this action is called <span class="docEmphasis">catching</span> a signal. The two signals <TT>SIGKILL</TT> and <TT>SIGSTOP</TT> cannot be caught. Our function is called with a single integer argument that is the signal number and the function returns nothing. Its function prototype is therefore</P><pre>

</pre><pre>
void handler (int <span class="docEmphasis">signo</span>);
</pre><pre>
</pre><P class="docList">For most signals, calling <TT>sigaction</TT> and specifying a function to be called when the signal occurs is all that is required to catch a signal. But we will see later that a few signals, <TT>SIGIO</TT>, <TT>SIGPOLL</TT>, and <TT>SIGURG</TT>, all require additional actions on the part of the process to catch the signal.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">We can <span class="docEmphasis">ignore</span> a signal by setting its disposition to <TT>SIG_IGN</TT>. The two signals <TT>SIGKILL</TT> and <TT>SIGSTOP</TT> cannot be ignored.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">We can set the <span class="docEmphasis">default</span> disposition for a signal by setting its disposition to <TT>SIG_DFL</TT>. The default is normally to terminate a process on receipt of a signal, with certain signals also generating a core image of the process in its current working directory. There are a few signals whose default disposition is to be ignored: <TT>SIGCHLD</TT> and <TT>SIGURG</TT> (sent on the arrival of out-of-band data, <A class="docLink" HREF="0131411551_ch24.html#ch24">Chapter 24</A>) are two that we will encounter in this text.</P></span></LI></OL></span>
<A NAME="ch05lev2sec1"></A>
<H4 class="docSection2Title"> <TT>signal</TT> Function</H4>
<P class="docText">The POSIX way to establish the disposition of a signal is to call the <TT>sigaction</TT> function. This gets complicated, however, as one argument to the function is a structure that we must allocate and fill in. An easier way to set the disposition of a signal is to call the <TT>signal</TT> function. The first argument is the signal name and the second argument is either a pointer to a function or one of the constants <TT>SIG_IGN</TT> or <TT>SIG_DFL</TT>. But, <TT>signal</TT> is an historical function that predates POSIX. Different implementations provide different signal semantics when it is called, providing backward compatibility, whereas POSIX explicitly spells out the semantics when <TT>sigaction</TT> is called. The solution is to define our own function named <TT>signal</TT> that just calls the POSIX <TT>sigaction</TT> function. This provides a simple interface with the desired POSIX semantics. We include this function in our own library, along with our <TT>err</TT>_<span class="docEmphasis">XXX</span> functions and our wrapper functions, for example, that we specify when building any of our programs in this text. This function is shown in <A class="docLink" HREF="#ch05fig06">Figure 5.6</A> (the corresponding wrapper function, <TT>Signal</TT>, is not shown here as it would be the same whether it called our function or a vendor-supplied <TT>signal</TT> function).</P>

<H5 class="docExampleTitle"><A NAME="ch05fig06"></A>Figure 5.6 <TT>signal</TT> function that calls the POSIX <TT>sigaction</TT> function.</H5>
<P class="docText"><span class="docEmphasis">lib/signal.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 Sigfunc *
 3 signal (int signo, Sigfunc *func)
 4 {
 5     struct sigaction act, oact;

 6     act.sa_handler = func;
 7     sigemptyset (&amp;act.sa_mask);
 8     act.sa_flags = 0;
 9     if (signo == SIGALRM) {
10 #ifdef  SA_INTERRUPT
11         act.sa_flags |= SA_INTERRUPT;     /* SunOS 4.x */
12 #endif
13     } else {
14 #ifdef  SA_RESTART
15         act.sa_flags |= SA_RESTART; /* SVR4, 4.4BSD */
16 #endif
17     }
18     if (sigaction (signo, &amp;act, &amp;oact) &lt; 0)
19         return (SIG_ERR);
20     return (oact.sa_handler);
21 }
</PRE>

<A NAME="ch05lev3sec10"></A>
<H5 class="docSection3Title"> Simplify function prototype using <TT>typedef</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>2–3</TT></span> The normal function prototype for <TT>signal</TT> is complicated by the level of nested parentheses.</p>
<pre>

</pre><pre>
void (*signal (int <span class="docEmphasis">signo</span>, void (*<span class="docEmphasis">func</span>) (int))) (int);
</pre><pre>
</pre>
<P class="docText">To simplify this, we define the <TT>Sigfunc</TT> type in our <TT>unp.h</TT> header as</P>
<pre>

</pre><pre>
typedef    void    Sigfunc(int);
</pre><pre>
</pre>
<P class="docText">stating that signal handlers are functions with an integer argument and the function returns nothing (<TT>void</TT>). The function prototype then becomes</P>
<pre>

</pre><pre>
Sigfunc *signal (int <span class="docEmphasis">signo</span>, Sigfunc *<span class="docEmphasis">func</span>);
</pre><pre>
</pre>
<P class="docText">A pointer to a signal handling function is the second argument to the function, as well as the return value from the function.</P>

<A NAME="ch05lev3sec11"></A>
<H5 class="docSection3Title"> Set handler</H5>
<p class="docText"><span class="docEmphasis"><TT>6</TT></span> The <TT>sa_handler</TT> member of the <TT>sigaction</TT> structure is set to the <span class="docEmphasis">func</span> argument.</p>

<A NAME="ch05lev3sec12"></A>
<H5 class="docSection3Title"> Set signal mask for handler</H5>
<p class="docText"><span class="docEmphasis"><TT>7</TT></span> POSIX allows us to specify a set of signals that will be <span class="docEmphasis">blocked</span> when our signal handler is called. Any signal that is blocked cannot be <span class="docEmphasis">delivered</span> to a process. We set the <TT>sa_mask</TT> member to the empty set, which means that no additional signals will be blocked while our signal handler is running. POSIX guarantees that the signal being caught is always blocked while its handler is executing.</p>

<A NAME="ch05lev3sec13"></A>
<H5 class="docSection3Title"> Set <TT>SA_RESTART</TT> flag</H5>
<p class="docText"><span class="docEmphasis"><TT>8–17</TT></span> <TT>SA_RESTART</TT> is an optional flag. When the flag is set, a system call interrupted by this signal will be automatically restarted by the kernel. (We will talk more about interrupted system calls in the next section when we continue our example.) If the signal being caught is not <TT>SIGALRM</TT>, we specify the <TT>SA_RESTART</TT> flag, if defined. (The reason for making a special case for <TT>SIGALRM</TT> is that the purpose of generating this signal is normally to place a timeout on an I/O operation, as we will show in <A class="docLink" HREF="0131411551_ch14lev1sec2.html#ch14lev1sec2">Section 14.2</A>, in which case, we want the blocked system call to be interrupted by the signal.) Some older systems, notably SunOS 4.x, automatically restart an interrupted system call by default and then define the complement of this flag as <TT>SA_INTERRUPT</TT>. If this flag is defined, we set it if the signal being caught is <TT>SIGALRM</TT>.</p>

<A NAME="ch05lev3sec14"></A>
<H5 class="docSection3Title"> Call <TT>sigaction</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>18–20</TT></span> We call <TT>sigaction</TT> and then return the old action for the signal as the return value of the <TT>signal</TT> function.</p>
<P class="docText">Throughout this text, we will use the <TT>signal</TT> function from <A class="docLink" HREF="#ch05fig06">Figure 5.6</A>.</P>


<A NAME="ch05lev2sec2"></A>
<H4 class="docSection2Title"> POSIX Signal Semantics</H4>
<P class="docText">We summarize the following points about signal handling on a POSIX-compliant system:</P>
<UL><LI><P class="docList">Once a signal handler is installed, it remains installed. (Older systems removed the signal handler each time it was executed.)</P></LI><LI><P class="docList">While a signal handler is executing, the signal being delivered is blocked. Furthermore, any additional signals that were specified in the <TT>sa_mask</TT> signal set passed to <TT>sigaction</TT> when the handler was installed are also blocked. In <A class="docLink" HREF="#ch05fig06">Figure 5.6</A>, we set <TT>sa_mask</TT> to the empty set, meaning no additional signals are blocked other than the signal being caught.</P></LI><LI><P class="docList">If a signal is generated one or more times while it is blocked, it is normally delivered only one time after the signal is unblocked. That is, by default, Unix signals are not <span class="docEmphasis">queued</span>. We will see an example of this in the next section. The POSIX real-time standard, 1003.1b, defines some reliable signals that are queued, but we do not use them in this text.</P></LI><LI><P class="docList">It is possible to selectively block and unblock a set of signals using the <TT>sigprocmask</TT> function. This lets us protect a critical region of code by preventing certain signals from being caught while that region of code is executing.</P></LI></UL>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
