<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="21.10 Sending and Receiving"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch21lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch21lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch21lev1sec10"></A>
<H3 class="docSection1Title">21.10 Sending and Receiving</H3>
<P class="docText">The IP multicast infrastructure session announcement program in the previous section only received multicast datagrams. We will now develop a simple program that sends and receives multicast datagrams. Our program consists of two parts. The first part sends a multicast datagram to a specific group every five seconds and the datagram contains the sender's hostname and process ID. The second part is an infinite loop that joins the multicast group to which the first part is sending and prints every received datagram (containing the hostname and process ID of the sender). This allows us to start the program on multiple hosts on a LAN and easily see which host is receiving datagrams from which senders.</P>
<P class="docText"><A class="docLink" HREF="#ch21fig17">Figure 21.17</A> shows the <TT>main</TT> function for our program.</P>

<H5 class="docExampleTitle"><A NAME="ch21fig17"></A>Figure 21.17 Create sockets, <TT>fork</TT>, and start sender and receiver.</H5>
<P class="docText"><span class="docEmphasis">mcast/main.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void    recv_all(int, socklen_t);
 3 void    send_all(int, SA *, socklen_t);

 4 int
 5 main(int argc, char **argv)
 6 {
 7     int     sendfd, recvfd;
 8     const int on = 1;
 9     socklen_t salen;
10     struct sockaddr *sasend, *sarecv;

11     if (argc != 3)
12         err_quit("usage: sendrecv &lt;IP-multicast-address&gt; &lt;port#&gt;");

13     sendfd = Udp_client(argv[1], argv[2], (void **) &amp;sasend, &amp;salen);

14     recvfd = Socket(sasend-&gt;sa_family, SOCK_DGRAM, 0);

15     Setsockopt(recvfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));

16     sarecv = Malloc(salen);
17     memcpy(sarecv, sasend, salen);
18     Bind(recvfd, sarecv, salen);

19     Mcast_join(recvfd, sasend, salen, NULL, 0);
20     Mcast_set_loop(sendfd, 0);

21     if (Fork() == 0)
22         recv_all(recvfd, salen);    /* child -&gt; receives */

23     send_all(sendfd, sasend, salen);    /* parent -&gt; sends */
24 }
</PRE>

<P class="docText">We create two sockets, one for sending and one for receiving. We want the receiving socket to <TT>bind</TT> the multicast group and port, say 239.255.1.2 port 8888. (Recall that we could just <TT>bind</TT> the wildcard IP address and port 8888, but binding the multicast address prevents the socket from receiving any other datagrams that might arrive destined for port 8888.) We then want the receiving socket to join the multicast group. The sending socket will send datagrams to this same multicast address and port, say 239.255.1.2 port 8888. But if we try to use a single socket for sending and receiving, the source protocol address is 239.255.1.2:8888 from the <TT>bind</TT> (using <TT>netstat</TT> notation) and the destination protocol address for the <TT>sendto</TT> is also 239.255.1.2:8888. However, now the source protocol address that is bound to the socket becomes the source IP address of the UDP datagram, and RFC 1122 [Braden 1989] forbids an IP datagram from having a source IP address that is a multicast address or a broadcast address (see <A class="docLink" HREF="0131411551_ch21lev1sec13.html#ch21lev1sec13">Exercise 21.2</A> also). Therefore, we must create two sockets: one for sending and one for receiving.</P>
<A NAME="ch21lev3sec16"></A>
<H4 class="docSection2Title"> Create sending socket</H4>
<p class="docText"><span class="docEmphasis"><TT>13</TT></span> Our <TT>udp_client</TT> function creates the sending socket, processing the two command-line arguments that specify the multicast address and port number. This function also returns a socket address structure that is ready for calls to <TT>sendto</TT> along with the length of this socket address structure.</p>

<A NAME="ch21lev3sec17"></A>
<H4 class="docSection2Title"> Create receiving socket and <TT>bind</TT> multicast address and port</H4>
<p class="docText"><span class="docEmphasis"><TT>14–18</TT></span> We create the receiving socket using the same address family that was used for the sending socket. We set the <TT>SO_REUSEADDR</TT> socket option to allow multiple instances of this program to run at the same time on a host. We then allocate room for a socket address structure for this socket, copy its contents from the sending socket address structure (whose address and port were taken from the command-line arguments), and <TT>bind</TT> the multicast address and port to the receiving socket.</p>

<A NAME="ch21lev3sec18"></A>
<H4 class="docSection2Title"> Join multicast group and turn off loopback</H4>
<p class="docText"><span class="docEmphasis"><TT>19–20</TT></span> We call our <TT>mcast_join</TT> function to join the multicast group on the receiving socket and our <TT>mcast_set_loop</TT> function to disable the loopback feature on the sending socket. For the join, we specify the interface name as a null pointer and the interface index as 0, telling the kernel to choose the interface.</p>

<A NAME="ch21lev3sec19"></A>
<H4 class="docSection2Title"> <TT>fork</TT> and call appropriate functions</H4>
<p class="docText"><span class="docEmphasis"><TT>21–23</TT></span> We <TT>fork</TT> and then the child is the receive loop and the parent is the send loop.</p>
<P class="docText">Our <TT>send_all</TT> function, which sends one multicast datagram every five seconds, is shown in <A class="docLink" HREF="#ch21fig18">Figure 21.18</A>. The <TT>main</TT> function passes as arguments the socket descriptor, a pointer to a socket address structure containing the multicast destination and port, and the structure's length.</P>

<A NAME="ch21lev3sec20"></A>
<H4 class="docSection2Title"> Obtain hostname and form datagram contents</H4>
<p class="docText"><span class="docEmphasis"><TT>9–11</TT></span> We obtain the hostname from the <TT>uname</TT> function and build the output line containing it and the process ID.</p>

<A NAME="ch21lev3sec21"></A>
<H4 class="docSection2Title"> Send datagram, then go to sleep</H4>
<p class="docText"><span class="docEmphasis"><TT>12–15</TT></span> We send a datagram and then <TT>sleep</TT> for five seconds.</p>
<P class="docText">The <TT>recv_all</TT> function, which is the infinite receive loop, is shown in <A class="docLink" HREF="#ch21fig19">Figure 21.19</A>.</P>

<A NAME="ch21lev3sec22"></A>
<H4 class="docSection2Title"> Allocate socket address structure</H4>
<p class="docText"><span class="docEmphasis"><TT>9</TT></span> A socket address structure is allocated to receive the sender's protocol address for each call to <TT>recvfrom</TT>.</p>

<A NAME="ch21lev3sec23"></A>
<H4 class="docSection2Title"> Read and print datagrams</H4>
<p class="docText"><span class="docEmphasis"><TT>10–15</TT></span> Each datagram is read by <TT>recvfrom</TT>, null-terminated, and printed.</p>

<H5 class="docExampleTitle"><A NAME="ch21fig18"></A>Figure 21.18 Send a multicast datagram every five seconds.</H5>
<P class="docText"><span class="docEmphasis">mcast/send.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 #include    &lt;sys/utsname.h&gt;

 3 #define SENDRATE     5           /* send one datagram every five seconds */

 4 void
 5 send_all(int sendfd, SA *sadest, socklen_t salen)
 6 {
 7     char    line[MAXLINE];      /* hostname and process ID */
 8     struct utsname myname;

 9     if (uname(&amp;myname) &lt; 0)
10         err_sys("uname error");;
11     snprintf(line, sizeof(line), "%s, %d\n", myname.nodename, getpid());

12     for ( ; ; ) {
13         Sendto(sendfd, line, strlen(line), 0, sadest, salen);

14         sleep(SENDRATE);
15     }
16 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch21fig19"></A>Figure 21.19 Receive all multicast datagrams for a group we have joined.</H5>
<P class="docText"><span class="docEmphasis">mcast/recv.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 recv_all(int recvfd, socklen_t salen)
 4 {
 5     int     n;
 6     char    line[MAXLINE + 1];
 7     socklen_t len;
 8     struct sockaddr *safrom;

 9     safrom = Malloc(salen);

10     for ( ; ; ) {
11         len = salen;
12         n = Recvfrom(recvfd, line, MAXLINE, 0, safrom, &amp;len);

13         line[n] = 0;            /* null terminate */
14         printf("from %s: %s", Sock_ntop(safrom, len), line);
15     }
16 }
</PRE>


<A NAME="ch21lev2sec17"></A>
<H4 class="docSection2Title"> Example</H4>
<P class="docText">We run this program on our two systems, freebsd4 and macosx. We see that each system sees the packets that the other is sending.</P>

<PRE>
freebsd4 % <span class="docEmphStrong">sendrecv 239.255.1.2 8888</span>
from 172.24.37.78:51297: macosx, 21891
from 172.24.37.78:51297: macosx, 21891
from 172.24.37.78:51297: macosx, 21891
from 172.24.37.78:51297: macosx, 21891

macosx % <span class="docEmphStrong">sendrecv 239.255.1.2 8888</span>
from 172.24.37.94.1215: freebsd4, 55372
from 172.24.37.94.1215: freebsd4, 55372
from 172.24.37.94.1215: freebsd4, 55372
from 172.24.37.94.1215: freebsd4, 55372
</PRE>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch21lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch21lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
