<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.2 TCP Echo Server: 'main' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec2"></A>
<H3 class="docSection1Title">5.2 TCP Echo Server: <TT>main</TT> Function</H3>
<P class="docText">Our TCP client and server follow the flow of functions that we diagrammed in <A class="docLink" HREF="0131411551_ch04lev1sec1.html#ch04fig01">Figure 4.1</A>. We show the concurrent server program in <A class="docLink" HREF="#ch05fig02">Figure 5.2</A>.</P>
<A NAME="ch05lev3sec1"></A>
<H4 class="docSection2Title"> Create socket, bind server's well-known port</H4>
<p class="docText"><span class="docEmphasis"><TT>9–15</TT></span> A TCP socket is created. An Internet socket address structure is filled in with the wildcard address (<TT>INADDR_ANY</TT>) and the server's well-known port (<TT>SERV_PORT</TT>, which is defined as 9877 in our <TT>unp.h</TT> header). Binding the wildcard address tells the system that we will accept a connection destined for any local interface, in case the system is multihomed. Our choice of the TCP port number is based on <A class="docLink" HREF="0131411551_ch02lev1sec9.html#ch02fig10">Figure 2.10</A>. It should be greater than 1023 (we do not need a reserved port), greater than 5000 (to avoid conflict with the ephemeral ports allocated by many Berkeley-derived implementations), less than 49152 (to avoid conflict with the "correct" range of ephemeral ports), and it should not conflict with any registered port. The socket is converted into a listening socket by <TT>listen</TT>.</p>

<A NAME="ch05lev3sec2"></A>
<H4 class="docSection2Title"> Wait for client connection to complete</H4>
<p class="docText"><span class="docEmphasis"><TT>17–18</TT></span> The server blocks in the call to <TT>accept</TT>, waiting for a client connection to complete.</p>

<A NAME="ch05lev3sec3"></A>
<H4 class="docSection2Title"> Concurrent server</H4>
<p class="docText"><span class="docEmphasis"><TT>19–24</TT></span> For each client, <TT>fork</TT> spawns a child, and the child handles the new client. As we discussed in <A class="docLink" HREF="0131411551_ch04lev1sec8.html#ch04lev1sec8">Section 4.8</A>, the child closes the listening socket and the parent closes the connected socket. The child then calls <TT>str_echo</TT> (<A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig03">Figure 5.3</A>) to handle the client.</p>

<H5 class="docExampleTitle"><A NAME="ch05fig02"></A>Figure 5.2 TCP echo server (improved in <A class="docLink" HREF="0131411551_ch05lev1sec10.html#ch05fig12">Figure 5.12</A>).</H5>
<P class="docText"><span class="docEmphasis">tcpdiserv/tcpserv01.c</span></P>

<PRE>
 1 #include      "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd;
 6     pid_t   childpid;
 7     socklen_t clilen;
 8     struct sockaddr_in cliaddr, servaddr;

 9     listenfd = Socket (AF_INET, SOCK_STREAM, 0);

10     bzero(&amp;servaddr, sizeof(servaddr));
11     servaddr.sin_family = AF_INET;
12     servaddr.sin_addr.s_addr = htonl (INADDR_ANY);
13     servaddr.sin_port = htons (SERV_PORT);

14     Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));

15     Listen(listenfd, LISTENQ);

16     for ( ; ; )  {
17         clilen = sizeof(cliaddr);
18         connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);

19         if ( (childpid = Fork()) == 0) { /* child process */
20             Close(listenfd);    /* close listening socket */
21             str_echo(connfd);   /* process the request */
22             exit (0);
23         }
24         Close(connfd);          /* parent closes connected socket */
25     }
26 }
</PRE>



<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
