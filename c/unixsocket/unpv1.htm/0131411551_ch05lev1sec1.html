<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.1 Introduction"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec1"></A>
<H3 class="docSection1Title">5.1 Introduction</H3>
<P class="docText">We will now use the elementary functions from the previous chapter to write a complete TCP client/server example. Our simple example is an echo server that performs the following steps:</P>
<A NAME="ch05pro01"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">The client reads a line of text from its standard input and writes the line to the server.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">The server reads the line from its network input and echoes the line back to the client.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">The client reads the echoed line and prints it on its standard output.</P>
</span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="#ch05fig01">Figure 5.1</A> depicts this simple client/server along with the functions used for input and output.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch05fig01"></A>Figure 5.1. Simple echo client and server.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="474" HEIGHT="81" src="FILES/05fig01.gif" ALT="graphics/05fig01.gif"></p>

</CENTER>
<P class="docText">We show two arrows between the client and server, but this is really one full-duplex TCP connection. The <TT>fgets</TT> and <TT>fputs</TT> functions are from the standard I/O library and the <TT>writen</TT> and <TT>readline</TT> functions were shown in <A class="docLink" HREF="0131411551_ch03lev1sec9.html#ch03lev1sec9">Section 3.9</A>.</P>
<P class="docText">While we will develop our own implementation of an echo server, most TCP/IP implementations provide such a server, using both TCP and UDP (<A class="docLink" HREF="0131411551_ch02lev1sec12.html#ch02lev1sec12">Section 2.12</A>). We will also use this server with our own client.</P>
<P class="docText">A client/server that echoes input lines is a valid, yet simple, example of a network application. All the basic steps required to implement any client/server are illustrated by this example. To expand this example into your own application, all you need to do is change what the server does with the input it receives from its clients.</P>
<P class="docText">Besides running our client and server in their normal mode (type in a line and watch it echo), we examine lots of boundary conditions for this example: what happens when the client and server are started; what happens when the client terminates normally; what happens to the client if the server process terminates before the client is done; what happens to the client if the server host crashes; and so on. By looking at all these scenarios and understanding what happens at the network level, and how this appears to the sockets API, we will understand more about what goes on at these levels and how to code our applications to handle these scenarios.</P>
<P class="docText">In all these examples, we have "hard-coded" protocol-specific constants such as addresses and ports. There are two reasons for this. First, we must understand exactly what needs to be stored in the protocol-specific address structures. Second, we have not yet covered the library functions that can make this more portable. These functions will be covered in <A class="docLink" HREF="0131411551_ch11.html#ch11">Chapter 11</A>.</P>
<P class="docText">We note now that we will make many changes to both the client and server in successive chapters as we learn more about network programming (<A class="docLink" HREF="0131411551_ch01lev1sec6.html#ch01fig12">Figures 1.12</A> and <A class="docLink" HREF="0131411551_ch01lev1sec6.html#ch01fig13">1.13</A>).</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
