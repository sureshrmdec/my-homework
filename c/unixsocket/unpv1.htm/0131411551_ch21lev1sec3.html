<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="21.3 Multicasting versus Broadcasting on a LAN"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch21lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch21lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch21lev1sec3"></A>
<H3 class="docSection1Title">21.3 Multicasting versus Broadcasting on a LAN</H3>
<P class="docText">We now return to the examples in <A class="docLink" HREF="0131411551_ch20lev1sec3.html#ch20fig03">Figures 20.3</A> and <A class="docLink" HREF="0131411551_ch20lev1sec3.html#ch20fig04">20.4</A> to show what happens in the case of multicasting. We use IPv4 for the example shown in <A class="docLink" HREF="#ch21fig04">Figure 21.4</A>, but the steps are similar for IPv6.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch21fig04"></A>Figure 21.4. Multicast example of a UDP datagram.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="500" HEIGHT="363" src="FILES/21fig04.gif" ALT="graphics/21fig04.gif"></p>

</CENTER>
<P class="docText">The receiving application on the rightmost host starts and creates a UDP socket, binds port 123 to the socket, and then joins the multicast group 224.0.1.1. We will see shortly that this "join" operation is done by calling <TT>setsockopt</TT>. When this happens, the IPv4 layer saves the information internally and then tells the appropriate datalink to receive Ethernet frames destined to <TT>01:00:5e:00:01:01</TT> (Section 12.11 of TCPv2). This is the Ethernet address corresponding to the multicast address that the application has just joined using the mapping we showed in <A class="docLink" HREF="0131411551_ch21lev1sec2.html#ch21fig01">Figure 21.1</A>.</P>
<P class="docText">The next step is for the sending application on the leftmost host to create a UDP socket and send a datagram to 224.0.1.1, port 123. Nothing special is required to send a multicast datagram: The application does not have to join the multicast group. The sending host converts the IP address into the corresponding Ethernet destination address and the frame is sent. Notice that the frame contains both the destination Ethernet address (which is examined by the interfaces) and the destination IP address (which is examined by the IP layers).</P>
<P class="docText">We assume that the host in the middle is not IPv4 multicast-capable (since support for IPv4 multicasting is optional). This host ignores the frame completely because: (i) the destination Ethernet address does not match the address of the interface; (ii) the destination Ethernet address is not the Ethernet broadcast address; and (iii) the interface has not been told to receive any group addresses (those with the low-order bit of the high-order byte set to 1, as in <A class="docLink" HREF="0131411551_ch21lev1sec2.html#ch21fig01">Figure 21.1</A>).</P>
<P class="docText">The frame is received by the datalink on the right based on what we call <span class="docEmphasis">imperfect filtering</span>, which is done by the interface using the Ethernet destination address. We say this is imperfect because it is normally the case that when the interface is told to receive frames destined to one specific Ethernet multicast address, it can receive frames destined to other Ethernet multicast addresses, too.</P>
<BLOCKQUOTE><P><P class="docList">When told to receive frames destined to a specific Ethernet multicast address, many current Ethernet interface cards apply a hash function to the address, calculating a value between 0 and 511. One of 512 bits in an array is then turned ON. When a frame passes by on the cable destined for a multicast address, the same hash function is applied by the interface to the destination address (which is the first field in the frame), calculating a value between 0 and 511. If the corresponding bit in the array is ON, the frame is received; otherwise, it is ignored. Older interface cards reduce the size of the bit array from 512 to 64, increasing the probability that an interface will receive frames in which it is not interested. Over time, as more and more applications use multicasting, this size will probably increase even more. Some interface cards today already have perfect filtering (the ability to filter out datagrams addressed to all but the desired multicast addresses). Other interface cards have no multicast filtering at all, and when told to receive a specific multicast address, must receive all multicast frames (sometimes called <span class="docEmphasis">multicast promiscuous</span> mode). One popular interface card does perfect filtering for 16 multicast addresses as well as having a 512-bit hash table. Another does perfect filtering for 80 multicast addresses, but then has to enter multicast promiscuous mode. Even if the interface performs perfect filtering, perfect software filtering at the IP layer is still required because the mapping from the IP multicast address to the hardware address is not one-to-one.</P></P></BLOCKQUOTE>
<P class="docText">Assuming that the datalink on the right receives the frame, since the Ethernet frame type is IPv4, the packet is passed to the IP layer. Since the received packet was destined to a multicast IP address, the IP layer compares this address against all the multicast addresses that applications on this host have joined. We call this <span class="docEmphasis">perfect filtering</span> since it is based on the entire 32-bit class D address in the IPv4 header. In this example, the packet is accepted by the IP layer and passed to the UDP layer, which in turn passes the datagram to the socket that is bound to port 123.</P>
<P class="docText">There are three scenarios that we do not show in <A class="docLink" HREF="#ch21fig04">Figure 21.4</A>:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">A host running an application that has joined the multicast address 225.0.1.1. Since the upper five bits of the group address are ignored in the mapping to the Ethernet address, this host's interface will also be receiving frames with a destination Ethernet address of <TT>01:00:5e:00:01:01</TT>. In this case, the packet will be discarded by the perfect filtering in the IP layer.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A host running an application that has joined some multicast group whose corresponding Ethernet address just happens to be one that the interface receives when it is programmed to receive <TT>01:00:5e:00:01:01</TT>. (i.e., the interface card performs imperfect filtering). This frame will be discarded either by the datalink layer or by the IP layer.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A packet destined to the same group, 224.0.1.1, but a different port, say 4000. The rightmost host in <A class="docLink" HREF="#ch21fig04">Figure 21.4</A> still receives the packet, which is accepted by the IP layer, but assuming a socket does not exist that has bound port 4000, the packet will be discarded by the UDP layer.</P><BLOCKQUOTE><P><P class="docList">This demonstrates that for a process to receive a multicast datagram, the process must join the group and bind the port.</P></P></BLOCKQUOTE></span></LI></OL></span>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch21lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch21lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
