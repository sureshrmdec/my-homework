<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="29.2 BSD Packet Filter (BPF)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch29lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch29lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch29lev1sec2"></A>
<H3 class="docSection1Title">29.2 BSD Packet Filter (BPF)</H3>
<P class="docText">4.4BSD and many other Berkeley-derived implementations support BPF, the BSD packet filter. The implementation of BPF is described in Chapter 31 of TCPv2. The history of BPF, a description of the BPF pseudomachine, and a comparison with the SunOS 4.1.x NIT packet filter is provided in [McCanne and Jacobson 1993].</P>
<P class="docText">Each datalink driver calls BPF right before a packet is transmitted and right after a packet is received, as shown in <A class="docLink" HREF="#ch29fig01">Figure 29.1</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch29fig01"></A>Figure 29.1. Packet capture using BPF.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="307" src="FILES/29fig01.gif" ALT="graphics/29fig01.gif"></p>

</CENTER>
<P class="docText">Examples of these calls for an Ethernet interface are in Figures 4.11 and 4.19 of TCPv2. The reason for calling BPF as soon as possible after reception and as late as possible before transmission is to provide accurate timestamps.</P>
<P class="docText">While it is not hard to provide a tap into the datalink to catch all packets, the power of BPF is in its filtering capability. Each application that opens a BPF device can load its own filter, which is then applied by BPF to each packet. While some filters are simple (the filter " <TT>udp or tcp</TT>" receives only UDP or TCP packets), others can examine fields in the packet headers for certain values. For example,</P>
<pre>

</pre><pre>
tcp and port 80 and tcp[13:1] &amp; 0x7 != 0
</pre><pre>
</pre>
<P class="docText">was used in Chapter 14 of TCPv3 to collect only TCP segments to or from port 80 that had either the SYN, FIN, or RST flags on. The expression <TT>tcp[13:1]</TT> refers to the 1-byte value starting at byte offset 13 from the start of the TCP header.</P>
<P class="docText">BPF implements a register-based filter machine that applies application-specific filters to each received packet. While one can write filter programs in the machine language of this pseudomachine (which is described on the BPF man page), the simplest interface is to compile ASCII strings (such as the one beginning with <TT>tcp</TT> that we just showed) into this machine language using the <TT>pcap_compile</TT> function that we will describe in <A class="docLink" HREF="0131411551_ch29lev1sec7.html#ch29lev1sec7">Section 29.7</A>.</P>
<P class="docText">Three techniques are used by BPF to reduce its overhead:</P>
<UL><LI><P class="docList">The BPF filtering is within the kernel, which minimizes the amount of data copied from BPF to the application. This copy, from kernel space to user space, is expensive. If every packet was copied, BPF could have trouble keeping up with fast datalinks.</P></LI><LI><P class="docList">Only a portion of each packet is passed by BPF to the application. This is called the <span class="docEmphasis">snapshot length</span>, or <span class="docEmphasis">snaplen</span>. Most applications need only the packet headers, not the packet data. This also reduces the amount of data copied by BPF to the application. <TT>tcpdump</TT>, for example, defaults this value to 96, which allows room for a 14-byte Ethernet header, a 40-byte IPv6 header, a 20-byte TCP header, and 22 bytes of data. But, to print additional information for other protocols (e.g., DNS and NFS) requires the user to increase this value when <TT>tcpdump</TT> is run.</P></LI><LI><P class="docList">BPF buffers the data destined for an application and this buffer is copied to the application only when the buffer is full, or when the <span class="docEmphasis">read timeout</span> expires. This timeout value can be specified by the application. <TT>tcpdump</TT>, for example, sets the timeout to 1000 ms, while the RARP daemon sets it to 0 (since there are few RARP packets, and the RARP server needs to send a response as soon as it receives the request). The purpose of the buffering is to reduce the number of system calls. The same number of packets are still copied between BPF and the application, but each system call has an overhead, and reducing the number of system calls always reduces the overhead. (Figure 3.1 of APUE compares the overhead of the <TT>read</TT> system call, for example, when reading a given file in different chunk sizes varying between 1 byte and 131,072 bytes.)</P></LI></UL>
<BLOCKQUOTE><P><P class="docList">Although we show only a single buffer in <A class="docLink" HREF="#ch29fig01">Figure 29.1</A>, BPF maintains two buffers for each application and fills one while the other is being copied to the application. This is the standard <span class="docEmphasis">double-buffering</span> technique.</P></P></BLOCKQUOTE>
<P class="docText">In <A class="docLink" HREF="#ch29fig01">Figure 29.1</A>, we show only the BPF reception of packets: packets received by the datalink from below (the network) and packets received by the datalink from above (IP). The application can also write to BPF, causing packets to be sent out the datalink, but most applications only read from BPF. There is no reason to write to BPF to send IP datagrams because the <TT>IP_HDRINCL</TT> socket option allows us to write any type of IP datagram desired, including the IP header. (We show an example of this in <A class="docLink" HREF="0131411551_ch29lev1sec7.html#ch29lev1sec7">Section 29.7</A>.) The only reason to write to BPF is to send our own network packets that are not IP datagrams. The RARP daemon does this, for example, to send its RARP replies, which are not IP datagrams.</P>
<P class="docText">To access BPF, we must <TT>open</TT> a BPF device that is not currently open. For example, we could try <TT>/dev/bpf0</TT>, and if the error return is <TT>EBUSY</TT>, then we could try <TT>/dev/bpf1</TT>, and so on. Once a device is opened, about a dozen <TT>ioctl</TT> commands set the characteristics of the device: load the filter, set the read timeout, set the buffer size, attach a datalink to the BPF device, enable promiscuous mode, and so on. I/O is then performed using <TT>read</TT> and <TT>write</TT>.</P>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch29lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch29lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
