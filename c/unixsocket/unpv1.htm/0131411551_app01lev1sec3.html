<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="A.3 IPv6 Header"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_app01lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_app01lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app01lev1sec3"></A>
<H3 class="docSection1Title">A.3 IPv6 Header</H3>
<P class="docText"><A class="docLink" HREF="#app01fig02">Figure A.2</A> shows the format of an IPv6 header (RFC 2460 [Deering and Hinden 1998]).</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="app01fig02"></A>Figure A.2. Format of the IPv6 header.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="385" src="FILES/xafig02.gif" ALT="graphics/xafig02.gif"></p>

</CENTER>
<UL><LI><P class="docList">The 4-bit <span class="docEmphasis">version</span> field is 6. Since this field occupies the first 4 bits of the first byte of the header (just like the IPv4 version, <A class="docLink" HREF="0131411551_app01lev1sec2.html#app01fig01">Figure A.1</A>), it allows a receiving IP stack to differentiate between the two versions. This differentiation is already done by most link layers by using different encapsulation for IPv4 and IPv6.</P><P class="docList">During the development of IPv6 in the early 1990s, before the version number of 6 was assigned, the protocol was called <span class="docEmphasis">IPng</span>, for "IP next generation." You may still encounter references to IPng.</P></LI><LI><P class="docList">The 6-bit DSCP field (RFC 2474 [Nichols et al. 1998]) and the 2-bit ECN field (RFC 3168 [Ramakrishnan, Floyd, and Black 2001]) replace the historical 8-bit <span class="docEmphasis">traffic class</span> field, which was described in RFC 2460. We can set all 8 bits of this field with the <TT>IPV6_TCLASS</TT> socket option (<A class="docLink" HREF="0131411551_ch22lev1sec8.html#ch22lev1sec8">Section 22.8</A>), although the kernel may overwrite any value we set to enforce Diffserv policy or implement ECN.</P></LI><LI><P class="docList">The 20-bit <span class="docEmphasis">flow label</span> field can be chosen by the application or kernel for a given socket. A <span class="docEmphasis">flow</span> is a sequence of packets from a particular source to a particular destination for which the source desires special handling by intervening routers. For a given flow, once the flow label is chosen by the source, it does not change. A flow label of 0 (the default) identifies packets that do not belong to a flow. The flow label does not change while flowing through the network. [Rajahalme et al. 2003] describes the usage of the flow label more completely.</P><P class="docList">The interface for the flow label is yet to be completely defined. The <TT>sin6_flowinfo</TT> member of the <TT>sockaddr_in6</TT> socket address structure (<A class="docLink" HREF="0131411551_ch03lev1sec2.html#ch03fig04">Figure 3.4</A>) is reserved for future use. Some systems copy the lower 28 bits from the <TT>sin6_flowinfo</TT> directly into the IPv6 packet header, overwriting the DSCP and ECN fields.</P></LI><LI><P class="docList">The 16-bit <span class="docEmphasis">payload length</span> field is the length in bytes of everything following the 40-byte IPv6 header. Note that unlike IPv4, the <span class="docEmphasis">payload length</span> field does not include the IPv6 header. A value of 0 means the length requires more than 16 bits to describe and is contained in a jumbo payload option (<A class="docLink" HREF="0131411551_ch27lev1sec5.html#ch27fig09">Figure 27.9</A>). This is called a <span class="docEmphasis">jumbogram</span>.</P></LI><LI><P class="docList">The 8-bit <span class="docEmphasis">next header</span> field is similar to the IPv4 protocol field. Indeed, when the upper layer protocol is basically unchanged from IPv4 to IPv6, the same values are used, such as 6 for TCP and 17 for UDP. There were so many changes from ICMPv4 to ICMPv6 that the latter was assigned a new value of 58.</P><P class="docList">An IPv6 datagram can have numerous headers following the 40-byte IPv6 header. That is why the field is called the "next header" and not the "protocol."</P></LI><LI><P class="docList">The 8-bit <span class="docEmphasis">hop limit</span> field is similar to the IPv4 TTL field. The hop limit is decremented by 1 each time a router forwards the datagram and the datagram is discarded by any router that decrements the value to 0. The default value for this field can be set and fetched with the <TT>IPV6_UNICAST_HOPS</TT> and <TT>IPV6_MULTICAST_HOPS</TT> (<A class="docLink" HREF="0131411551_ch07lev1sec8.html#ch07lev1sec8">Sections 7.8</A> and <A class="docLink" HREF="0131411551_ch21lev1sec6.html#ch21lev1sec6">21.6</A>) socket options. The <TT>IPV6_HOPLIMIT</TT> socket option also lets us set this field and the <TT>IPV6_RECVHOPLIMIT</TT> socket option lets us obtain its value from a received datagram.</P><BLOCKQUOTE><P><P class="docList">Early specifications of IPv4 had routers decrement the TTL by either one or the number of seconds that the router held the datagram, whichever was greater. Hence the name "time-to-live." In reality, however, the field was always decremented by one. IPv6 calls for its hop limit field to always be decremented by one, hence the name change from IPv4.</P></P></BLOCKQUOTE></LI><LI><P class="docList">The <span class="docEmphasis">source IPv6 address</span> and the <span class="docEmphasis">destination IPv6 address</span> are both 128-bit fields.</P></LI></UL>
<P class="docText">The most significant change from IPv4 to IPv6 is, of course, the larger IPv6 address fields. Another change is simplifying the IPv6 header as follows, to facilitate faster processing as a datagram traverses the network:</P>
<UL><LI><P class="docList">There is no IPv6 header length field since the IPv6 header length is fixed at 40 bytes. Optional headers may follow the fixed 40-byte IPv6 header, but each of these has its own length field.</P></LI><LI><P class="docList">The two IPv6 addresses end up aligned on a 64-bit boundary when the header itself is 64-bit aligned. This can speed up processing on 64-bit architectures. IPv4 addresses are only 32-bit aligned in a 64-bit aligned IPv4 header.</P></LI><LI><P class="docList">There are no fragmentation fields in the IPv6 header because there is a separate fragmentation header for this purpose. This design decision was made because fragmentation is the exception, and exceptions should not slow down normal processing.</P></LI><LI><P class="docList">The IPv6 header does not include its own checksum. This is because all the upper layers—TCP, UDP, and ICMPv6—have their own checksum that includes the upper-layer header, the upper-layer data, and the following fields from the IPv6 header: IPv6 source address, IPv6 destination address, payload length, and next header (RFC 2460 [Deering and Hinden 1998]). By omitting the checksum from the header, routers that forward the datagram need not recalculate a header checksum after they modify the hop limit. Again, speed of forwarding by routers is the key point.</P></LI></UL>
<P class="docText">In case this is your first encounter with IPv6, we also note the following major differences from IPv4 to IPv6:</P>
<UL><LI><P class="docList">There is no broadcasting with IPv6 (<A class="docLink" HREF="0131411551_ch20.html#ch20">Chapter 20</A>). Multicasting (<A class="docLink" HREF="0131411551_ch21.html#ch21">Chapter 21</A>), which is optional with IPv4, is mandatory with IPv6. The case of sending to all systems on a subnet is handled with the all-nodes multicast group.</P></LI><LI><P class="docList">IPv6 routers do not fragment packets they forward. If fragmentation is required, the router drops the packet and sends an ICMPv6 error (<A class="docLink" HREF="0131411551_app01lev1sec6.html#app01lev1sec6">Section A.6</A>). Fragmentation is performed only by the originating host with IPv6.</P></LI><LI><P class="docList">IPv6 requires support for path MTU discovery (<A class="docLink" HREF="0131411551_ch02lev1sec11.html#ch02lev1sec11">Section 2.11</A>). Technically, this support is optional and could be omitted from minimal implementations such as bootstrap loaders, but if a node does not implement this feature, it must not send datagrams larger than the IPv6 minimum link MTU (1280 bytes). <A class="docLink" HREF="0131411551_ch22lev1sec9.html#ch22lev1sec9">Section 22.9</A> describes socket options to control path MTU discovery behavior.</P></LI><LI><P class="docList">IPv6 requires support for authentication and security options. These options appear after the fixed header.</P></LI></UL>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_app01lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_app01lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
