<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="22.2 Receiving Flags, Destination IP Address, and Interface Index"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch22lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch22lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch22lev1sec2"></A>
<H3 class="docSection1Title">22.2 Receiving Flags, Destination IP Address, and Interface Index</H3>
<P class="docText">Historically, <TT>sendmsg</TT> and <TT>recvmsg</TT> have been used only to pass descriptors across Unix domain sockets (<A class="docLink" HREF="0131411551_ch15lev1sec7.html#ch15lev1sec7">Section 15.7</A>), and even this was rare. But the use of these two functions is increasing for two reasons:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">The <TT>msg_flags</TT> member, which was added to the <TT>msghdr</TT> structure with 4.3BSD Reno, returns flags to the application. We summarized these flags in <A class="docLink" HREF="0131411551_ch14lev1sec5.html#ch14fig07">Figure 14.7</A>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Ancillary data is being used to pass more and more information between the application and the kernel. We will see in <A class="docLink" HREF="0131411551_ch27.html#ch27">Chapter 27</A> that IPv6 continues this trend.</P></span></LI></OL></span>
<P class="docText">As an example of <TT>recvmsg</TT>, we will write a function named <TT>recvfrom_flags</TT>, which is similar to <TT>recvfrom</TT> but also returns the following:</P>
<UL><LI><P class="docList">The returned <TT>msg_flags</TT> value</P></LI><LI><P class="docList">The destination address of the received datagram (from the <TT>IP_RECVDSTADDR</TT> socket option)</P></LI><LI><P class="docList">The index of the interface on which the datagram was received (the <TT>IP_RECVIF</TT> socket option)</P></LI></UL>
<P class="docText">To return the last two items, we define the following structure in our <TT>unp.h</TT> header:</P>
<pre>

</pre><pre>
struct unp_in_pktinfo {
  struct in_addr  ipi_addr;     /* destination IPv4 address */
  int             ipi_ifindex;  /* received interface index */
};
</pre><pre>
</pre>
<P class="docText">We have purposely chosen the structure name and member names to be similar to the IPv6 <TT>in6_pktinfo</TT> structure that returns the same two items for an IPv6 socket (<A class="docLink" HREF="0131411551_ch22lev1sec8.html#ch22lev1sec8">Section 22.8</A>). Our <TT>recvfrom_flags</TT> function will take a pointer to an <TT>unp_in_pktinfo</TT> structure as an argument, and if this pointer is non-null, we will return the structure through the pointer.</P>
<P class="docText">A design problem with this structure is what to return if the <TT>IP_RECVDSTADDR</TT> information is not available (i.e., the implementation does not support the socket option). The interface index is easy to handle because a value of 0 can indicate that the index is not known. But all 32-bit values for an IP address are valid. What we have chosen is to return a value of all zeros (0.0.0.0) as the destination address when the actual value is not available. While this is a valid IP address, it is never allowed as the destination IP address (RFC 1122 [Braden 1989]); it is valid only as the source IP address when a host is bootstrapping and does not yet know its IP address.</P>
<BLOCKQUOTE><P><P class="docList">Unfortunately, Berkeley-derived kernels accept IP datagrams destined to 0.0.0.0 (pp. 218–219 of TCPv2). These are obsolete broadcasts generated by 4.2BSD-derived kernels.</P></P></BLOCKQUOTE>
<P class="docText">We now show the first half of our <TT>recvfrom_flags</TT> function in <A class="docLink" HREF="#ch22fig01">Figure 22.1</A>. This function is intended to be used with a UDP socket.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig01"></A>Figure 22.1 <TT>recvfrom_flags</TT> function: calls <TT>recvmsg</TT>.</H5>
<P class="docText"><span class="docEmphasis">advio/recvfromflags.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 #include    &lt;sys/param.h&gt;       /* ALIGN macro for CMSG_NXTHDR() macro */

 3 ssize_t
 4 recvfrom_flags(int fd, void *ptr, size_t nbytes, int *flagsp,
 5                SA *sa, socklen_t *salenptr, struct unp_in_pktinfo *pktp)
 6 {
 7     struct msghdr msg;
 8     struct iovec iov[1];
 9     ssize_t n;

10 #ifdef  HAVE_MSGHDR_MSG_CONTROL
11     struct cmsghdr *cmptr;
12     union {
13         struct cmsghdr cm;
14         char    control[CMSG_SPACE(sizeof(struct in_addr)) +
15                         CMSG_SPACE(sizeof(struct unp_in_pktinfo))];
16     } control_un;

17     msg.msg_control = control_un.control;
18     msg.msg_controllen = sizeof(control_un.control);
19     msg.msg_flags = 0;
20 #else
21     bzero(&amp;msg, sizeof(msg));   /* make certain msg_accrightslen = 0 */
22 #endif

23     msg.msg_name = sa;
24     msg.msg_namelen = *salenptr;
25     iov[0].iov_base = ptr;
26     iov[0].iov_len = nbytes;
27     msg.msg_iov = iov;
28     msg.msg_iovlen = 1;

29     if ( (n = recvmsg(fd, &amp;msg, *flagsp)) &lt; 0)
30         return (n);

31     *salenptr = msg.msg_namelen;    /* pass back results */
32     if (pktp)
33         bzero(pktp, sizeof(struct unp_in_pktinfo)); /* 0.0.0.0, i/f = 0 */
</PRE>

<A NAME="ch22lev3sec1"></A>
<H4 class="docSection2Title"> Include files</H4>
<p class="docText"><span class="docEmphasis"><TT>1–2</TT></span> The <TT>CMSG_NXTHDR</TT> macro requires the <TT>&lt;sys/param.h&gt;</TT> header.</p>

<A NAME="ch22lev3sec2"></A>
<H4 class="docSection2Title"> Function arguments</H4>
<p class="docText"><span class="docEmphasis"><TT>3–5</TT></span> The function arguments are similar to <TT>recvfrom</TT>, except the fourth argument is now a pointer to an integer flag (so that we can return the flags returned by <TT>recvmsg</TT>) and the seventh argument is new: It is a pointer to an <TT>unp_in_pktinfo</TT> structure that will contain the destination IPv4 address of the received datagram and the interface index on which the datagram was received.</p>

<A NAME="ch22lev3sec3"></A>
<H4 class="docSection2Title"> Implemenation differences</H4>
<p class="docText"><span class="docEmphasis"><TT>10–22</TT></span> When dealing with the <TT>msghdr</TT> structure and the various <TT>MSG_</TT><span class="docEmphasis">xxx</span> constants, we encounter lots of differences between various implementations. Our way of handling these differences is to use C's conditional inclusion feature (<TT>#ifdef</TT>). If the implementation supports the <TT>msg_control</TT> member, space is allocated to hold the values returned by both the <TT>IP_RECVDSTADDR</TT> and <TT>IP_RECVIF</TT> socket options, and the appropriate members are initialized.</p>

<A NAME="ch22lev3sec4"></A>
<H4 class="docSection2Title"> Fill in <TT>msghdr</TT> structure and call <TT>recvmsg</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>23–33</TT></span> A <TT>msghdr</TT> structure is filled in and <TT>recvmsg</TT> is called. The values of the <TT>msg_namelen</TT> and <TT>msg_flags</TT> members must be passed back to the caller; they are value-result arguments. We also initialize the caller's <TT>unp_in_pktinfo</TT> structure, setting the IP address to 0.0.0.0 and the interface index to 0.</p>
<P class="docText"><A class="docLink" HREF="#ch22fig02">Figure 22.2</A> shows the second half of our function.</P>
<p class="docText"><span class="docEmphasis"><TT>34–37</TT></span> If the implementation does not support the <TT>msg_control</TT> member, we just set the returned flags to 0 and return. The remainder of the function handles the <TT>msg_control</TT> information.</p>

<A NAME="ch22lev3sec5"></A>
<H4 class="docSection2Title"> Return if no control information</H4>
<p class="docText"><span class="docEmphasis"><TT>38–41</TT></span> We return the <TT>msg_flags</TT> value and then return to the caller if: (i) there is no control information; (ii) the control information was truncated; or (iii) the caller does not want an <TT>unp_in_pktinfo</TT> structure returned.</p>

<A NAME="ch22lev3sec6"></A>
<H4 class="docSection2Title"> Process ancillary data</H4>
<p class="docText"><span class="docEmphasis"><TT>42–43</TT></span> We process any number of ancillary data objects using the <TT>CMSG_FIRSTHDR</TT> and <TT>CMSG_NXTHDR</TT> macros.</p>

<A NAME="ch22lev3sec7"></A>
<H4 class="docSection2Title"> Process <TT>IP_RECVDSTADDR</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>44–51</TT></span> If the destination IP address was returned as control information (<A class="docLink" HREF="0131411551_ch14lev1sec5.html#ch14fig09">Figure 14.9</A>), it is returned to the caller.</p>

<A NAME="ch22lev3sec8"></A>
<H4 class="docSection2Title"> Process <TT>IP_RECVIF</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>52–59</TT></span> If the index of the received interface was returned as control information, it is returned to the caller. <A class="docLink" HREF="#ch22fig03">Figure 22.3</A> shows the contents of the ancillary data object that is returned.</p>

<H5 class="docExampleTitle"><A NAME="ch22fig02"></A>Figure 22.2 <TT>recvfrom_flags</TT> function: returns flags and destination address.</H5>
<P class="docText"><span class="docEmphasis">advio/recvfromflags.c</span></P>

<PRE>
34 #ifndef HAVE_MSGHDR_MSG_CONTROL
35     *flagsp = 0;                /* pass back results */
36     return (n);
37 #else

38     *flagsp = msg.msg_flags;    /* pass back results */
39     if (msg.msg_controllen &lt; sizeof(struct cmsghdr) ||
40         (msg.msg_flags &amp; MSG_CTRUNC) || pktp == NULL)
41         return (n);

42     for (cmptr = CMSG_FIRSTHDR(&amp;msg); cmptr != NULL;
43          cmptr = CMSG_NXTHDR(&amp;msg, cmptr)) {

44 #ifdef  IP_RECVDSTADDR
45         if (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;
46             cmptr-&gt;cmsg_type == IP_RECVDSTADDR) {

47             memcpy(&amp;pktp-&gt;ipi_addr, CMSG_DATA(cmptr),
48                    sizeof(struct in_addr));
49             continue;
50         }
51 #endif

52 #ifdef  IP_RECVIF
53         if (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp; cmptr-&gt;cmsg_type == IP_RECVIF) {
54             struct sockaddr_dl *sdl;

55             sdl = (struct sockaddr_dl *) CMSG_DATA(cmptr);
56             pktp-&gt;ipi_ifindex = sdl-&gt;sdl_index;
57             continue;
58         }
59 #endif
60         err_quit("unknown ancillary data, len = %d, level = %d, type = %d",
61                  cmptr-&gt;cmsg_len, cmptr-&gt;cmsg_level, cmptr-&gt;cmsg_type);
62     }
63     return (n);
64 #endif  /* HAVE_MSGHDR_MSG_CONTROL */
65 }
</PRE>

<CENTER>
<H5 class="docFigureTitle"><A NAME="ch22fig03"></A>Figure 22.3. Ancillary data object returned for <TT>IP_RECVIF</TT>.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="403" HEIGHT="117" src="FILES/22fig03.gif" ALT="graphics/22fig03.gif"></p>

</CENTER>
<P class="docText">Recall the datalink socket address structure in <A class="docLink" HREF="0131411551_ch18lev1sec2.html#ch18fig01">Figure 18.1</A>. The data returned in the ancillary data object is one of these structures, but the three lengths are 0 (name length, address length, and selector length). Therefore, there is no need for any of the data that follows these lengths, so the size of the structure should be 8 bytes, not the 20 that we show in <A class="docLink" HREF="0131411551_ch18lev1sec2.html#ch18fig01">Figure 18.1</A>. The information we return is the interface index.</P>

<A NAME="ch22lev2sec1"></A>
<H4 class="docSection2Title"> Example: Print Destination IP Address and Datagram-Truncated Flag</H4>
<P class="docText">To test our function, we modify our <TT>dg_echo</TT> function (<A class="docLink" HREF="0131411551_ch08lev1sec4.html#ch08fig04">Figure 8.4</A>) to call <TT>recvfrom_flags</TT> instead of <TT>recvfrom</TT>. We show this new version of <TT>dg_echo</TT> in <A class="docLink" HREF="#ch22fig04">Figure 22.4</A>.</P>
<A NAME="ch22lev3sec9"></A>
<H5 class="docSection3Title"> Change <TT>MAXLINE</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>2–3</TT></span> We remove the existing definition of <TT>MAXLINE</TT> that occurs in our <TT>unp.h</TT> header and redefine it to be 20. We do this to see what happens when we receive a UDP datagram that is larger than the buffer that we pass to the input function (<TT>recvmsg</TT> in this case).</p>

<A NAME="ch22lev3sec10"></A>
<H5 class="docSection3Title"> Set <TT>IP_RECVDSTADDR</TT> and <TT>IP_RECVIF</TT> socket options</H5>
<p class="docText"><span class="docEmphasis"><TT>14–21</TT></span> If the <TT>IP_RECVDSTADDR</TT> socket option is defined, it is turned on. Similarly, the <TT>IP_RECVIF</TT> socket option is turned on.</p>

<H5 class="docExampleTitle"><A NAME="ch22fig04"></A>Figure 22.4 <TT>dg_echo</TT> function that calls our <TT>recvfrom_flags</TT> function.</H5>
<P class="docText"><span class="docEmphasis">advio/dgechoaddr.c</span></P>

<PRE>
 1 #include    "unpifi.h"

 2 #undef  MAXLINE
 3 #define MAXLINE 20              /* to see datagram truncation */

 4 void
 5 dg_echo(int sockfd, SA *pcliaddr, socklen_t clilen)
 6 {
 7     int     flags;
 8     const int on = 1;
 9     socklen_t len;
10     ssize_t n;
11     char    mesg[MAXLINE], str[INET6_ADDRSTRLEN], ifname[IFNAMSIZ];
12     struct in_addr in_zero;
13     struct unp_in_pktinfo pktinfo;

14 #ifdef  IP_RECVDSTADDR
15     if (setsockopt(sockfd, IPPROTO_IP, IP_RECVDSTADDR, &amp;on, sizeof(on)) &lt; 0)
16         err_ret("setsockopt of IP_RECVDSTADDR");
17 #endif
18 #ifdef  IP_RECVIF
19     if (setsockopt(sockfd, IPPROTO_IP, IP_RECVIF, &amp;on, sizeof(on)) &lt; 0)
20         err_ret("setsockopt of IP_RECVIF");
21 #endif
22     bzero(&amp;in_zero, sizeof(struct in_addr));     /* all 0 IPv4 address */

23     for ( ; ; ) {
24         len = clilen;
25         flags = 0;
26         n = Recvfrom_flags(sockfd, mesg, MAXLINE, &amp;flags,
27                            pcliaddr, &amp;len, &amp;pktinfo);
28         printf("%d-byte datagram from %s", n, Sock_ntop(pcliaddr, len));
29         if (memcmp(&amp;pktinfo.ipi_addr, &amp;in_zero, sizeof(in_zero)) != 0)
30             printf(", to %s", Inet_ntop(AF_INET, &amp;pktinfo.ipi_addr,
31                                         str, sizeof(str)));
32         if (pktinfo.ipi_ifindex &gt; 0)
33             printf(", recv i/f = %s",
34                    If_indextoname(pktinfo.ipi_ifindex, ifname));
35 #ifdef  MSG_TRUNC
36         if (flags &amp; MSG_TRUNC)
37             printf(" (datagram truncated)");
38 #endif
39 #ifdef  MSG_CTRUNC
40         if (flags &amp; MSG_CTRUNC)
41             printf(" (control info truncated)");
42 #endif
43 #ifdef  MSG_BCAST
44         if (flags &amp; MSG_BCAST)
45             printf(" (broadcast)");
46 #endif
47 #ifdef  MSG_MCAST
48         if (flags &amp; MSG_MCAST)
49             printf(" (multicast)");
50 #endif
51         printf("\n");

52         Sendto(sockfd, mesg, n, 0, pcliaddr, len);
53     }
54 }
</PRE>


<A NAME="ch22lev3sec11"></A>
<H5 class="docSection3Title"> Read datagram, print source IP address and port</H5>
<p class="docText"><span class="docEmphasis"><TT>24–28</TT></span> The datagram is read by calling <TT>recvfrom_flags</TT>. The source IP address and port of the server's reply are converted to presentation format by <TT>sock_ntop</TT>.</p>

<A NAME="ch22lev3sec12"></A>
<H5 class="docSection3Title"> Print destination IP address</H5>
<p class="docText"><span class="docEmphasis"><TT>29–31</TT></span> If the returned IP address is not 0, it is converted to presentation format by <TT>inet_ntop</TT> and printed.</p>

<A NAME="ch22lev3sec13"></A>
<H5 class="docSection3Title"> Print name of received interface</H5>
<p class="docText"><span class="docEmphasis"><TT>32–34</TT></span> If the returned interface index is not 0, its name is obtained by calling <TT>if_indextoname</TT> and it is printed.</p>

<A NAME="ch22lev3sec14"></A>
<H5 class="docSection3Title"> Test various flags</H5>
<p class="docText"><span class="docEmphasis"><TT>35–51</TT></span> We test four additional flags and print a message if any are on.</p>



<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch22lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch22lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
