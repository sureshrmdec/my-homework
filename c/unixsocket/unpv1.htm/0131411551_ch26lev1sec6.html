<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="26.6 Web Client and Simultaneous Connections (Continued)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch26lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch26lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch26lev1sec6"></A>
<H3 class="docSection1Title" id="225793-885">26.6 Web Client and Simultaneous Connections (Continued)</H3>
<P class="docText">We now revisit the Web client example from <A class="docLink" HREF="0131411551_ch16lev1sec5.html#ch16lev1sec5">Section 16.5</A> and recode it using threads instead of nonblocking <TT>connect</TT>s. With threads, we can leave the sockets in their default blocking mode and create one thread per connection. Each thread can block in its call to <TT>connect</TT>, as the kernel will just run some other thread that is ready.</P>
<P class="docText"><A class="docLink" HREF="#ch26fig13">Figure 26.13</A> shows the first part of the program, the globals, and the start of the <TT>main</TT> function.</P>
<A NAME="ch26lev3sec15"></A>
<H4 class="docSection2Title"> Globals</H4>
<p class="docText"><span class="docEmphasis"><TT>1–16</TT></span> We <TT>#include &lt;thread.h&gt;</TT>, in addition to the normal <TT>&lt;pthread.h&gt;</TT>, because we need to use Solaris threads in addition to Pthreads, as we will describe shortly.</p>
<p class="docText"><span class="docEmphasis"><TT>10</TT></span> We have added one member to the <TT>file</TT> structure: <TT>f_tid</TT>, the thread ID. The remainder of this code is similar to <A class="docLink" HREF="0131411551_ch16lev1sec5.html#ch16fig15">Figure 16.15</A>. With this threads version, we do not use <TT>select</TT> and therefore do not need any descriptor sets or the variable <TT>maxfd</TT>.</p>
<p class="docText"><span class="docEmphasis"><TT>36</TT></span> The <TT>home_page</TT> function that is called is unchanged from <A class="docLink" HREF="0131411551_ch16lev1sec5.html#ch16fig16">Figure 16.16</A>.</p>

<H5 class="docExampleTitle"><A NAME="ch26fig13"></A>Figure 26.13 Globals and start of <TT>main</TT> function.</H5>
<P class="docText"><span class="docEmphasis">threads/web01.c</span></P>

<PRE>
 1 #include     "unpthread.h"
 2 #include     &lt;thread.h&gt;           /* Solaris threads */

 3 #define MAXFILES        20
 4 #define SERV            "80"      /* port number or service name */

 5 struct file {
 6     char   *f_name;               /* filename */
 7     char   *f_host;               /* hostname or IP address */
 8     int     f_fd;                 /* descriptor */
 9     int     f_flags;              /* F_xxx below */
10     pthread_t f_tid;              /* thread ID */
11 } file [MAXFILES];
12 #define F_CONNECTING       1      /* connect() in progress */
13 #define F_READING          2      /* connect() complete; now reading */
14 #define F_DONE             4      /* all done */

15 #define GET_CMD       "GET %s HTTP/1.0\r\n\r\n"

16 int     nconn, nfiles, nlefttoconn, nlefttoread;

17 void   *do_get_read(void *);
18 void    home_page(const char *, const char *);
19 void    write_get_cmd(struct file *);

20 int
21 main(int argc, char **argv)
22 {
23     int     i, n, maxnconn;
24     pthread_t tid;
25     struct file *fptr;

26     if (argc &lt; 5)
27         err_quit("usage: web &lt;#conns&gt; &lt;IPaddr&gt; &lt;homepage&gt; file1 ...");
28     maxnconn = atoi(argv[1]);
29     nfiles = min(argc - 4, MAXFILES);
30     for (i = 0; i &lt; nfiles; i++) {
31         file[i].f_name = argv[i + 4];
32         file[i].f_host = argv[2];
33         file[i].f_flags = 0;
34     }
35     printf("nflies = %d\n", nfiles);

36     home_page(argv[2], argv[3]);

37     nlefttoread = nlefttoconn = nfiles;
38     nconn = 0;
</PRE>

<P class="docText"><A class="docLink" HREF="#ch26fig14">Figure 26.14</A> shows the main processing loop of the <TT>main</TT> thread.</P>

<H5 class="docExampleTitle"><A NAME="ch26fig14"></A>Figure 26.14 Main processing loop of <TT>main</TT> function.</H5>
<P class="docText"><span class="docEmphasis">threads/web01.c</span></P>

<PRE>
39     while (nlefttoread &gt; 0) {
40         while (nconn &lt; maxnconn &amp;&amp; nlefttoconn &gt; 0) {
41                 /* find a file to read */
42             for (i = 0; i &lt; nfiles; i++)
43                 if (file[i].f_flags == 0)
44                     break;
45             if (i == nfiles)
46                 err_quit("nlefttoconn = %d but nothing found", nlefttoconn);

47             file[i].f_flags = F_CONNECTING;
48             Pthread_create(&amp;tid, NULL, &amp;do_get_read, &amp;file[i]);
49             file[i].f_tid = tid;
50             nconn++;
51             nlefttoconn--;
52          }

53          if ( (n = thr_join(0, &amp;tid, (void **) &amp;fptr)) != 0)
54              errno = n, err_sys("thr_join error");

55          nconn--;
56          nlefttoread--;
57          printf("thread id %d for %s done\n", tid, fptr-&gt;f_name);
58     }

59     exit(0);
60 }
</PRE>


<A NAME="ch26lev3sec16"></A>
<H4 class="docSection2Title"> If possible, create another thread</H4>
<p class="docText"><span class="docEmphasis"><TT>40–52</TT></span> If we are allowed to create another thread (<TT>nconn</TT> is less than <TT>maxnconn</TT>), we do so. The function that each new thread executes is <TT>do_get_read</TT> and the argument is the pointer to the <TT>file</TT> structure.</p>

<A NAME="ch26lev3sec17"></A>
<H4 class="docSection2Title"> Wait for any thread to terminate</H4>
<p class="docText"><span class="docEmphasis"><TT>53–54</TT></span> We call the Solaris thread function <TT>thr_join</TT> with a first argument of 0 to wait for any one of our threads to terminate. Unfortunately, Pthreads does not provide a way to wait for <span class="docEmphasis">any</span> one of our threads to terminate; the <TT>pthread_join</TT> function makes us specify exactly which thread we want to wait for. We will see in <A class="docLink" HREF="0131411551_ch26lev1sec9.html#ch26lev1sec9">Section 26.9</A> that the Pthreads solution for this problem is more complicated, requiring us to use a condition variable for the terminating thread to notify the main thread when it is done.</p>
<BLOCKQUOTE><P><P class="docList">The solution that we show, using the Solaris thread <TT>thr_join</TT> function, is not portable to all environments. Nevertheless, we want to show this version of our Web client example using threads without having to complicate the discussion with condition variables and mutexes. Fortunately, we can mix Pthreads with Solaris threads under Solaris.</P></P></BLOCKQUOTE>
<P class="docText"><A class="docLink" HREF="#ch26fig15">Figure 26.15</A> shows the <TT>do_get_read</TT> function, which is executed by each thread. This function establishes the TCP connection, sends an HTTP <TT>GET</TT> command to the server, and reads the server's reply.</P>

<H5 class="docExampleTitle"><A NAME="ch26fig15"></A>Figure 26.15 <TT>do_get_read</TT> function.</H5>
<P class="docText"><span class="docEmphasis">threads/web01.c</span></P>

<PRE>
61 void *
62 do_get_read(void *vptr)
63 {
64     int     fd, n;
65     char    line[MAXLINE];
66     struct file *fptr;

67     fptr = (struct file *) vptr;

68     fd = Tcp_connect(fptr-&gt;f_host, SERV);
69     fptr-&gt;f_fd = fd;
70     printf("do_get_read for %s, fd %d, thread %d\n",
71            fptr-&gt;f_name, fd, fptr-&gt;f_tid);

72     write_get_cmd(fptr);         /* write() the GET command */

73         /* Read server's reply  */
74     for ( ; ;) {
75         if ( (n = Read(fd, line, MAXLINE)) == 0)
76             break;              /* server closed connection */

77         printf("read %d bytes from %s\n", n, fptr-&gt;f_name);
78     }
79     printf("end-of-file on %s\n", fptr-&gt;f_name);
80     Close(fd);
81     fptr-&gt;f_flags = F_DONE;  /* clears F_READING */

82     return (fptr);              /* terminate thread */
83 }
</PRE>


<A NAME="ch26lev3sec18"></A>
<H4 class="docSection2Title"> Create TCP socket, establish connection</H4>
<p class="docText"><span class="docEmphasis"><TT>68–71</TT></span> A TCP socket is created and a connection is established by our <TT>tcp_connect</TT> function. The socket is a normal blocking socket, so the thread will block in the call to <TT>connect</TT> until the connection is established.</p>

<A NAME="ch26lev3sec19"></A>
<H4 class="docSection2Title"> Write request to server</H4>
<p class="docText"><span class="docEmphasis"><TT>72</TT></span> <TT>write_get_cmd</TT> builds the HTTP <TT>GET</TT> command and sends it to the server. We do not show this function again as the only difference from <A class="docLink" HREF="0131411551_ch16lev1sec5.html#ch16fig18">Figure 16.18</A> is that the threads version does not call <TT>FD_SET</TT> and does not use <TT>maxfd</TT>.</p>

<A NAME="ch26lev3sec20"></A>
<H4 class="docSection2Title"> Read server's reply</H4>
<p class="docText"><span class="docEmphasis"><TT>73–82</TT></span> The server's reply is then read. When the connection is closed by the server, the <TT>F_DONE</TT> flag is set and the function returns, terminating the thread.</p>
<P class="docText">We also do not show the <TT>home_page</TT> function, as it is identical to the version shown in <A class="docLink" HREF="0131411551_ch16lev1sec5.html#ch16fig16">Figure 16.16</A>.</P>
<P class="docText">We will return to this example, replacing the Solaris <TT>thr_join</TT> function with the more portable Pthreads solution, but we must first discuss mutexes and condition variables.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch26lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch26lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
