<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.6 Normal Startup"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec6"></A>
<H3 class="docSection1Title">5.6 Normal Startup</H3>
<P class="docText">Although our TCP example is small (about 150 lines of code for the two <TT>main</TT> functions, <TT>str_echo</TT>, <TT>str_cli</TT>, <TT>readline</TT>, and <TT>writen</TT>), it is essential that we understand how the client and server start, how they end, and most importantly, what happens when something goes wrong: the client host crashes, the client process crashes, network connectivity is lost, and so on. Only by understanding these boundary conditions, and their interaction with the TCP/IP protocols, can we write robust clients and servers that can handle these conditions.</P>
<P class="docText">We first start the server in the background on the host <TT>linux</TT>.</P>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">tcpserv01 &amp;</span>
[1] 17870
</pre><pre>
</pre>
<P class="docText">When the server starts, it calls <TT>socket</TT>, <TT>bind</TT>, <TT>listen</TT>, and <TT>accept</TT>, blocking in the call to <TT>accept</TT>. (We have not started the client yet.) Before starting the client, we run the <TT>netstat</TT> program to verify the state of the server's listening socket.</P>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">netstat -a</span>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address       Foreign Address      State
tcp        0      0 *:9877              *:*                  LISTEN
</pre><pre>
</pre>
<P class="docText">Here we show only the first line of output (the heading), plus the line that we are interested in. This command shows the status of <span class="docEmphasis">all</span> sockets on the system, which can be lots of output. We must specify the <TT>-a</TT> flag to see listening sockets.</P>
<P class="docText">The output is what we expect. A socket is in the LISTEN state with a wildcard for the local IP address and a local port of 9877. <TT>netstat</TT> prints an asterisk for an IP address of 0 (<TT>INADDR_ANY</TT>, the wildcard) or for a port of 0.</P>
<P class="docText">We then start the client on the same host, specifying the server's IP address of 127.0.0.1 (the loopback address). We could have also specified the server's normal (nonloopback) IP address.</P>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">tcpcli01 127.0.0.1</span>
</pre><pre>
</pre>
<P class="docText">The client calls <TT>socket</TT> and <TT>connect</TT>, the latter causing TCP's three-way handshake to take place. When the three-way handshake completes, <TT>connect</TT> returns in the client and <TT>accept</TT> returns in the server. The connection is established. The following steps then take place:</P>
<A NAME="ch05pro02"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">The client calls <TT>str_cli</TT>, which will block in the call to <TT>fgets</TT>, because we have not typed a line of input yet.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">When <TT>accept</TT> returns in the server, it calls <TT>fork</TT> and the child calls <TT>str_echo</TT>. This function calls <TT>readline</TT>, which calls <TT>read</TT>, which blocks while waiting for a line to be sent from the client.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">The server parent, on the other hand, calls <TT>accept</TT> again, and blocks while waiting for the next client connection.</P>
</span></LI></OL></span>
<P class="docText">We have three processes, and all three are asleep (blocked): client, server parent, and server child.</P>
<BLOCKQUOTE><P><P class="docList">When the three-way handshake completes, we purposely list the client step first, and then the server steps. The reason can be seen in <A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig05">Figure 2.5</A>: <TT>connect</TT> returns when the second segment of the handshake is received by the client, but <TT>accept</TT> does not return until the third segment of the handshake is received by the server, one-half of the RTT after <TT>connect</TT> returns.</P></P></BLOCKQUOTE>
<P class="docText">We purposely run the client and server on the same host because this is the easiest way to experiment with client/server applications. Since we are running the client and server on the same host, <TT>netstat</TT> now shows two additional lines of output, corresponding to the TCP connection:</P>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">netstat -a</span>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address          State
tcp        0      0 local host:9877         localhost:42758          ESTABLISHED
tcp        0      0 local host:42758        localhost:9877           ESTABLISHED
tcp        0      0 *:9877                  *:*                      LISTEN
</pre><pre>
</pre>
<P class="docText">The first of the ESTABLISHED lines corresponds to the server child's socket, since the local port is 9877. The second of the ESTABLISHED lines is the client's socket, since the local port is 42758. If we were running the client and server on different hosts, the client host would display only the client's socket, and the server host would display only the two server sockets.</P>
<P class="docText">We can also use the <TT>ps</TT> command to check the status and relationship of these processes.</P>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">ps -t pts/6 -o pid,ppid,tty,stat,args,wchan</span>
  PID  PPID TT       STAT COMMAND          WCHAN
22038 22036 pts/6    S    -bash            wait4
17870 22038 pts/6    S    ./tcpserv01      wait_for_connect
19315 17870 pts/6    S    ./tcpserv01      tcp_data_wait
19314 22038 pts/6    S    ./tcpcli01 127.0 read_chan
</pre><pre>
</pre>
<P class="docText">(We have used very specific arguments to <TT>ps</TT> to only show us the information that pertains to this discussion.) In this output, we ran the client and server from the same window (<TT>pts/6</TT>, which stands for pseudo-terminal number 6). The PID and PPID columns show the parent and child relationships. We can tell that the first <TT>tcpserv01</TT> line is the parent and the second <TT>tcpserv01</TT> line is the child since the PPID of the child is the parent's PID. Also, the PPID of the parent is the shell (<TT>bash</TT>).</P>
<P class="docText">The STAT column for all three of our network processes is "S," meaning the process is sleeping (waiting for something). When a process is asleep, the WCHAN column specifies the condition. Linux prints <TT>wait_for_connect</TT> when a process is blocked in either <TT>accept</TT> or <TT>connect</TT>, <TT>tcp_data_wait</TT> when a process is blocked on socket input or output, or <TT>read_chan</TT> when a process is blocked on terminal I/O. The WCHAN values for our three network processes therefore make sense.</P>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
