<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="16.1 Introduction"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch16.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch16lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch16lev1sec1"></A>
<H3 class="docSection1Title">16.1 Introduction</H3>
<P class="docText">By default, sockets are blocking. This means that when we issue a socket call that cannot be completed immediately, our process is put to sleep, waiting for the condition to be true. We can divide the socket calls that may block into four categories:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Input operations—</span> These include the <TT>read</TT>, <TT>readv</TT>, <TT>recv</TT>, <TT>recvfrom</TT>, and <TT>recvmsg</TT> functions. If we call one of these input functions for a blocking TCP socket (the default), and there is no data available in the socket receive buffer, we are put to sleep until some data arrives. Since TCP is a byte stream, we will be awakened when "some" data arrives: It could be a single byte of data, or it could be a full TCP segment of data. If we want to wait until some fixed amount of data is available, we can call our own function <TT>readn</TT> (<A class="docLink" HREF="0131411551_ch03lev1sec9.html#ch03fig15">Figure 3.15</A>) or specify the <TT>MSG_WAITALL</TT> flag (<A class="docLink" HREF="0131411551_ch14lev1sec3.html#ch14fig06">Figure 14.6</A>).</p><P class="docList">Since UDP is a datagram protocol, if the socket receive buffer is empty for a blocking UDP socket, we are put to sleep until a UDP datagram arrives.</P><P class="docList">With a nonblocking socket, if the input operation cannot be satisfied (at least one byte of data for a TCP socket or a complete datagram for a UDP socket), we see an immediate return with an error of <TT>EWOULDBLOCK</TT>.</P></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Output operations—</span> These include the <TT>write</TT>, <TT>writev</TT>, <TT>send</TT>, <TT>sendto</TT>, and <TT>sendmsg</TT> functions. For a TCP socket, we said in <A class="docLink" HREF="0131411551_ch02lev1sec11.html#ch02lev1sec11">Section 2.11</A> that the kernel copies data from the application's buffer into the socket send buffer. If there is no room in the socket send buffer for a blocking socket, the process is put to sleep until there is room.</p><P class="docList">With a nonblocking TCP socket, if there is no room at all in the socket send buffer, we return immediately with an error of <TT>EWOULDBLOCK</TT>. If there is some room in the socket send buffer, the return value will be the number of bytes the kernel was able to copy into the buffer. (This is called a <span class="docEmphasis">short count</span>.)</P><P class="docList">We also said in <A class="docLink" HREF="0131411551_ch02lev1sec11.html#ch02lev1sec11">Section 2.11</A> that there is no actual UDP socket send buffer. The kernel just copies the application data and moves it down the stack, prepending the UDP and IP headers. Therefore, an output operation on a blocking UDP socket (the default) will not block for the same reason as a TCP socket, but it is possible for output operations to block on some systems due to the buffering and flow control that happens within the networking code in the kernel.</P></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Accepting incoming connections—</span> This is the <TT>accept</TT> function. If <TT>accept</TT> is called for a blocking socket and a new connection is not available, the process is put to sleep.</p><P class="docList">If <TT>accept</TT> is called for a nonblocking socket and a new connection is not available, the error <TT>EWOULDBLOCK</TT> is returned instead.</P></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Initiating outgoing connections—</span> This is the <TT>connect</TT> function for TCP. (Recall that <TT>connect</TT> can be used with UDP, but it does not cause a "real" connection to be established; it just causes the kernel to store the peer's IP address and port number.) We showed in <A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02lev1sec6">Section 2.6</A> that the establishment of a TCP connection involves a three-way handshake and the <TT>connect</TT> function does not return until the client receives the ACK of its SYN. This means that a TCP <TT>connect</TT> always blocks the calling process for at least the RTT to the server.</p><P class="docList">If <TT>connect</TT> is called for a nonblocking TCP socket and the connection cannot be established immediately, the connection establishment is initiated (e.g., the first packet of TCP's three-way handshake is sent), but the error <TT>EINPROGRESS</TT> is returned. Notice that this error differs from the error returned in the previous three scenarios. Also notice that some connections can be established immediately, normally when the server is on the same host as the client. So, even with a nonblocking <TT>connect</TT>, we must be prepared for <TT>connect</TT> to return successfully. We will show an example of a nonblocking <TT>connect</TT> in <A class="docLink" HREF="0131411551_ch16lev1sec3.html#ch16lev1sec3">Section 16.3</A>.</P><BLOCKQUOTE><P><P class="docList">Traditionally, System V has returned the error <TT>EAGAIN</TT> for a nonblocking I/O operation that cannot be satisfied, while Berkeley-derived implementations have returned the error <TT>EWOULDBLOCK</TT>. Because of this history, the POSIX specification says either may be returned for this case. Fortunately, most current systems define these two error codes to be the same (check your system's <TT>&lt;sys/errno.h&gt;</TT> header), so it doesn't matter which one we use. In this text, we use <TT>EWOULDBLOCK</TT>.</P></P></BLOCKQUOTE></span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="0131411551_ch06lev1sec2.html#ch06lev1sec2">Section 6.2</A> summarized the different models available for I/O and compared nonblocking I/O to other models. In this chapter, we will provide examples of all four types of operations and develop a new type of client, similar to a Web client, that initiates multiple TCP connections at the same time using a nonblocking <TT>connect</TT>.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch16.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch16lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
