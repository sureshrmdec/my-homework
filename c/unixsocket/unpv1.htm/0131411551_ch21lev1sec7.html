<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="21.7 'mcast_join' and Related Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch21lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch21lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch21lev1sec7"></A>
<H3 class="docSection1Title">21.7 <TT>mcast_join</TT> and Related Functions</H3>
<P class="docText">Although the multicast socket options for IPv4 are similar to the multicast socket options for IPv6, there are enough differences that protocol-independent code using multicasting becomes complicated with lots of <TT>#ifdef</TT>s. A better solution is to hide the differences within the following eight functions:</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include "unp.h"</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_join(int</TT> <span class="docEmphasis">sockfd</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">grp</span><TT>, socklen_t</TT> <span class="docEmphasis">grplen</span><TT>, const char *</TT><span class="docEmphasis">ifname</span><TT>, u_int</TT> <span class="docEmphasis">ifindex</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_leave(int</TT> <span class="docEmphasis">sockfd</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">grp</span><TT>, socklen_t</TT> <span class="docEmphasis">grplen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_block_source(int</TT> <span class="docEmphasis">sockfd</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">src</span><TT>, socklen_t</TT> <span class="docEmphasis">srclen</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">grp</span><TT>, socklen_t</TT> <span class="docEmphasis">grplen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_unblock_source(int</TT> <span class="docEmphasis">sockfd</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">src</span><TT>, socklen_t</TT> <span class="docEmphasis">srclen</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">grp</span><TT>, socklen_t</TT> <span class="docEmphasis">grplen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_join_source_group(int</TT> <span class="docEmphasis">sockfd</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">src</span><TT>, socklen_t</TT> <span class="docEmphasis">srclen</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">grp</span><TT>, socklen_t</TT> <span class="docEmphasis">grplen</span><TT>, const char *</TT><span class="docEmphasis">ifname</span><TT>, u_int</TT> <span class="docEmphasis">ifindex</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_leave_source_group(int</TT> <span class="docEmphasis">sockfd</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">src</span><TT>, socklen_t</TT> <span class="docEmphasis">srclen</span><TT>, const struct sockaddr *</TT><span class="docEmphasis">grp</span><TT>, socklen_t</TT> <span class="docEmphasis">grplen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_set_if(int</TT> <span class="docEmphasis">sockfd</span><TT>, const char *</TT><span class="docEmphasis">ifname</span><TT>, u_int</TT> <span class="docEmphasis">ifindex</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_set_loop(int</TT> <span class="docEmphasis">sockfd</span><TT>, int</TT> <span class="docEmphasis">flag</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_set_ttl(int</TT> <span class="docEmphasis">sockfd</span><TT>, int</TT> <span class="docEmphasis">ttl</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">All above return: 0 if OK, –1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_get_if(int</TT> <span class="docEmphasis">sockfd</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: non-negative interface index if OK, –1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_get_loop(int</TT> <span class="docEmphasis">sockfd</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: current loopback flag if OK, –1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int mcast_get_ttl(int</TT> <span class="docEmphasis">sockfd</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: current TTL or hop limit if OK, –1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>mcast_join</TT> joins the any-source multicast group whose IP address is contained within the socket address structure pointed to by <span class="docEmphasis">grp</span>, and whose length is specified by <span class="docEmphasis">grplen</span>. We can specify the interface on which to join the group by either the interface name (a non-null <span class="docEmphasis">ifname</span>) or a nonzero interface index (<span class="docEmphasis">ifindex</span>). If neither is specified, the kernel chooses the interface on which the group is joined. Recall that with IPv6, the interface is specified to the socket option by its index. If a name is specified for an IPv6 socket, we call <TT>if_nametoindex</TT> to obtain the index. With the IPv4 socket option, the interface is specified by its unicast IP address. If a name is specified for an IPv4 socket, we call <TT>ioctl</TT> with a request of <TT>SIOCGIFADDR</TT> to obtain the unicast IP address for the interface. If an index is specified for an IPv4 socket, we first call <TT>if_indextoname</TT> to obtain the name and then process the name as just described.</P>
<BLOCKQUOTE><P><P class="docList">An interface name, such as <TT>le0</TT> or <TT>ether0</TT>, is normally the way users specify interfaces, and not with either the IP address or the index. <TT>tcpdump</TT>, for example, is one of the few programs that lets the user specify an interface, and its <TT>-i</TT> option takes an interface name as the argument.</P></P></BLOCKQUOTE>
<P class="docText"><TT>mcast_leave</TT> leaves the multicast group whose IP address is contained within the socket address structure pointed to by <span class="docEmphasis">grp</span>. Note that <TT>mcast_leave</TT> does not take an interface specification; it always deletes the first matching membership. This simplifies the library API, but means that programs that require direct control of per-interface membership need to use the <TT>setsockopt</TT> API directly.</P>
<P class="docText"><TT>mcast_block_source</TT> blocks reception on the given socket of the source and group whose IP addresses are contained within the socket address structures pointed to by <span class="docEmphasis">src</span> and <span class="docEmphasis">grp</span>, respectively, and whose lengths are specified by <span class="docEmphasis">srclen</span> and <span class="docEmphasis">grplen</span>. <TT>mcast_join</TT> must have already been called on this socket for the given group.</P>
<P class="docText"><TT>mcast_unblock_source</TT> unblocks reception of traffic from the given source to the given group. The <span class="docEmphasis">src, srclen, grp</span>, and <span class="docEmphasis">grplen</span> arguments must be the same as a previous call to <TT>mcast_block_source</TT>.</P>
<P class="docText"><TT>mcast_join_source_group</TT> joins the source-specific group where the source and group IP addresses are contained within the socket address structures pointed to by <span class="docEmphasis">src</span> and <span class="docEmphasis">grp</span>, respectively, and whose lengths are specified by <span class="docEmphasis">srclen</span> and <span class="docEmphasis">grplen</span>. We can specify the interface on which to join the group by either the interface name (a non-null <span class="docEmphasis">ifname</span>) or a nonzero interface index (<span class="docEmphasis">ifindex</span>). If neither is specified, the kernel chooses the interface on which the group is joined.</P>
<P class="docText"><TT>mcast_leave_source_group</TT> leaves the source-specific multicast group whose source and group IP addresses are contained within the socket address structures pointed to by <span class="docEmphasis">src</span> and <span class="docEmphasis">grp</span>, respectively, and whose lengths are specified by <span class="docEmphasis">srclen</span> and <span class="docEmphasis">grplen</span>. As with <TT>mcast_leave</TT>, <TT>mcast_leave_source_group</TT> does not take an interface specification; it always deletes the first matching membership.</P>
<P class="docText"><TT>mcast_set_if</TT> sets the default interface index for outgoing multicast datagrams. If <span class="docEmphasis">ifindex</span> is greater than 0, then it specifies the interface index; otherwise, if <span class="docEmphasis">ifname</span> is nonnull, then it specifies the interface name. For IPv6, the name is mapped to an index using <TT>if_nametoindex</TT>. For IPv4, the mapping from either a name or an index into the interface's unicast IP address is done as described for <TT>mcast_join</TT>.</P>
<P class="docText"><TT>mcast_set_loop</TT> sets the loopback option to either 0 or 1, and <TT>mcast_set_ttl</TT> sets either the IPv4 TTL or the IPv6 hop limit. The three <TT>mcast_get_</TT><span class="docEmphasis">XXX</span> functions return the corresponding value.</P>
<A NAME="ch21lev2sec14"></A>
<H4 class="docSection2Title"> Example: <TT>mcast_join</TT> Function</H4>
<P class="docText"><A class="docLink" HREF="#ch21fig10">Figure 21.10</A> shows the first third of our <TT>mcast_join</TT> function. This third shows how straightforward the protocol-independent API can be.</P>
<A NAME="ch21lev3sec1"></A>
<H5 class="docSection3Title"> Handle index</H5>
<p class="docText"><span class="docEmphasis"><TT>9–17</TT></span> If the caller supplied an index, then we just use it directly. Otherwise, if the caller supplied an interface name, the index is obtained by calling <TT>if_nametoindex</TT>. Otherwise, the interface is set to 0, telling the kernel to choose the interface.</p>

<A NAME="ch21lev3sec2"></A>
<H5 class="docSection3Title"> Copy address and call setsockopt</H5>
<p class="docText"><span class="docEmphasis"><TT>18–22</TT></span> The caller's socket address is copied directly into the request's group field. Recall that the group field is a <TT>sockaddr_storage</TT>, so it is big enough to handle any socket address type the system supports. However, to guard against buffer overruns caused by sloppy coding, we check the <TT>sockaddr</TT> size and return <TT>EINVAL</TT> if it is too large.</p>
<p class="docText"><span class="docEmphasis"><TT>23–24</TT></span> <TT>setsockopt</TT> performs the join. The <span class="docEmphasis">level</span> argument to <TT>setsockopt</TT> is determined using the family of the group address and our <TT>family_to_level</TT> function. Some systems support a mismatch between <span class="docEmphasis">level</span> and the socket's address family, for instance, using <TT>IPPROTO_IP</TT> with <TT>MCAST_JOIN_GROUP</TT>, even with an <TT>AF_INET6</TT> socket, but not all do, so we turn the address family into the appropriate level. We do not show this trivial function, but the source code is freely available (see the Preface).</p>

<H5 class="docExampleTitle"><A NAME="ch21fig10"></A>Figure 21.10 Join a multicast group: IP version-independent.</H5>
<P class="docText"><span class="docEmphasis">lib/mcast_join.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 #include    &lt;net/if.h&gt;

 3 int
 4 mcast_join(int sockfd, const SA *grp, socklen_t grplen,
 5            const char *ifname, u_int ifindex)
 6 {
 7 #ifdef MCAST_JOIN_GROUP
 8     struct group_req req;
 9     if (ifindex &gt; 0) {
10         req.gr_interface = ifindex;
11     } else if (ifname != NULL) {
12         if ( (req.gr_interface = if_nametoindex(ifname)) == 0) {
13             errno = ENXIO;      /* i/f name not found */
14             return (-1);
15         }
16     } else
17         req.gr_interface = 0;
18     if (grplen &gt; sizeof(req.gr_group)) {
19         errno = EINVAL;
20         return -1;
21     }
22     memcpy(&amp;req.gr_group, grp, grplen);
23     return (setsockopt(sockfd, family_to_level(grp-&gt;sa_family),
24                        MCAST_JOIN_GROUP, &amp;req, sizeof(req)));
25 #else
</PRE>

<P class="docText"><A class="docLink" HREF="#ch21fig11">Figure 21.11</A> shows the second third of <TT>mcast_join</TT>, which handles IPv4 sockets.</P>

<A NAME="ch21lev3sec3"></A>
<H5 class="docSection3Title"> Handle index</H5>
<p class="docText"><span class="docEmphasis"><TT>33–38</TT></span> The IPv4 multicast address in the socket address structure is copied into an <TT>ip_mreq</TT> structure. If an index was specified, <TT>if_indextoname</TT> is called, storing the name into our <TT>ifreq</TT> structure. If this succeeds, we branch ahead to issue the <TT>ioctl</TT>.</p>

<A NAME="ch21lev3sec4"></A>
<H5 class="docSection3Title"> Handle name</H5>
<p class="docText"><span class="docEmphasis"><TT>39–46</TT></span> The caller's name is copied into an <TT>ifreq</TT> structure, and an <TT>ioctl</TT> of <TT>SIOCGIFADDR</TT> returns the unicast address associated with this name. Upon success the IPv4 address is copied into the <TT>imr_interface</TT> member of the <TT>ip_mreq</TT> structure.</p>

<A NAME="ch21lev3sec5"></A>
<H5 class="docSection3Title"> Specify default</H5>
<p class="docText"><span class="docEmphasis"><TT>47–48</TT></span> If an index was not specified and a name was not specified, the interface is set to the wildcard address, telling the kernel to choose the interface.</p>
<p class="docText"><span class="docEmphasis"><TT>49–50</TT></span> <TT>setsockopt</TT> performs the join.</p>

<H5 class="docExampleTitle"><A NAME="ch21fig11"></A>Figure 21.11 Join a multicast group: IPv4 socket.</H5>
<P class="docText"><span class="docEmphasis">lib/mcast_join.c</span></P>

<PRE>
26   switch (grp-&gt;sa_family) {
27   case AF_INET:{
28           struct ip_mreq mreq;
29           struct ifreq ifreq;

30           memcpy(&amp;mreq.imr_multiaddr,
31                  &amp;((const struct sockaddr_in *) grp)-&gt;sin_addr,
32                  sizeof(struct in_addr));

33           if (ifindex &gt; 0) {
34               if (if_indextoname(ifindex, ifreq.ifr_name) == NULL) {
35                   errno = ENXIO; /*  i/f index not found */
36                   return (-1);
37               }
38               goto doioctl;
39           } else if (ifname != NULL) {
40               strncpy(ifreq.ifr_name, ifname, IFNAMSIZ);
41             doioctl:
42               if (ioctl(sockfd, SIOCGIFADDR, &amp;ifreq) &lt; 0)
43                   return (-1);
44               memcpy(&amp;mreq.imr_interface,
45                      &amp;((struct sockaddr_in *) &amp;ifreq.ifr_addr)-&gt;sin_addr,
46                      sizeof(struct in_addr));
47           } else
48               mreq.imr_interface.s_addr = htonl(INADDR_ANY);

49           return (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
50                              &amp;mreq, sizeof(mreq)));
51      }
</PRE>

<P class="docText">The final portion of the function, which handles IPv6 sockets, is shown in <A class="docLink" HREF="#ch21fig12">Figure 21.12</A>.</P>

<A NAME="ch21lev3sec6"></A>
<H5 class="docSection3Title"> Copy address</H5>
<p class="docText"><span class="docEmphasis"><TT>55–57</TT></span> First the IPv6 multicast address is copied from the socket address structure into the <TT>ipv6_mreq</TT> structure.</p>

<A NAME="ch21lev3sec7"></A>
<H5 class="docSection3Title"> Handle index, name, or default</H5>
<p class="docText"><span class="docEmphasis"><TT>58–66</TT></span> If an index was specified, it is stored in the <TT>ipv6mr_interface</TT> member; if a name was specified, the index is obtained by calling <TT>if_nametoindex</TT>; otherwise, the interface index is set to 0 for <TT>setsockopt</TT>, telling the kernel to choose the interface.</p>
<p class="docText"><span class="docEmphasis"><TT>67–68</TT></span> The group is joined.</p>

<H5 class="docExampleTitle"><A NAME="ch21fig12"></A>Figure 21.12 Join a multicast group: IPv6 socket.</H5>
<P class="docText"><span class="docEmphasis">lib/mcast_join.c</span></P>

<PRE>
52 #ifdef  IPV6
53     case AF_INET6:{
54             struct ipv6_mreq mreq6;

55             memcpy(&amp;mreq6.ipv6mr_multiaddr,
56                    &amp;((const struct sockaddr_in6 *) grp) -&gt;sin6_addr,
57                    sizeof(struct in6_addr));

58             if (ifindex &gt; 0) {
59                 mreq6.ipv6mr_interface = ifindex;
60             } else if (ifname != NULL) {
61                 if ( (mreq6.ipv6mr_interface = if_nametoindex(ifname)) == 0) {
62                     errno = ENXIO;  /* i/f name not found */
63                     return (-1);
64                 }
65             } else
66                 mreq6.ipv6mr_interface = 0;

67             return (setsockopt(sockfd, IPPROTO_IPV6, IPV6_JOIN_GROUP,
68                                &amp;mreq6, sizeof(mreq6)));
69         }
70 #endif

71     default:
72         errno = EAFNOSUPPORT;
73         return (-1);
74     }
75 #endif
76 }
</PRE>



<A NAME="ch21lev2sec15"></A>
<H4 class="docSection2Title"> Example: <TT>mcast_set_loop</TT> Function</H4>
<P class="docText"><A class="docLink" HREF="#ch21fig13">Figure 21.13</A> shows our <TT>mcast_set_loop</TT> function.</P>
<P class="docText">Since the argument is a socket descriptor and not a socket address structure, we call our <TT>sockfd_to_family</TT> function to obtain the address family of the socket. The appropriate socket option is set.</P>
<P class="docText">We do not show the source code for all remaining <TT>mcast_</TT><span class="docEmphasis">XXX</span> functions, but it is freely available (see the Preface).</P>

<H5 class="docExampleTitle"><A NAME="ch21fig13"></A>Figure 21.13 Set the multicast loopback option.</H5>
<P class="docText"><span class="docEmphasis">lib/mcast_set_loop.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 mcast_set_loop(int sockfd, int onoff)
 4 {
 5     switch (sockfd_to_family(sockfd)) {
 6     case AF_INET:{
 7             u_char  flag;

 8             flag = onoff;
 9             return (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_LOOP,
10                                &amp;flag, sizeof(flag)));
11         }

12 #ifdef  IPV6
13     case AF_INET6:{
14             u_int   flag;

15             flag = onoff;
16             return (setsockopt(sockfd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
17                                &amp;flag, sizeof(flag)));
18         }
19 #endif

20     default:
21         errno = EAFNOSUPPORT;
22         return (-1);
23     }
24 }
</PRE>



<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch21lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch21lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
