<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="23.6 Binding a Subset of Addresses"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch23lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch23lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch23lev1sec6"></A>
<H3 class="docSection1Title">23.6 Binding a Subset of Addresses</H3>
<P class="docText">Some applications may want to bind a proper subset of the IP addresses of a machine to a single socket. In TCP and UDP, traditionally, it was not possible to bind a subset of addresses. The <TT>bind</TT> system call allows an application to bind a single address or the wildcard address. Due to this restriction, the new function call <TT>sctp_bindx</TT> is provided to allow an application to bind to more than one address. Note that all the addresses must use the same port number, and if <TT>bind</TT> was called, the port number must be the same as that provided to <TT>bind</TT>. The <TT>sctp_bindx</TT> call will fail if a different port is provided. <A class="docLink" HREF="#ch23fig07">Figure 23.7</A> shows a utility we will add to our server that will bind an argument list.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig07"></A>Figure 23.7 Function to bind a subset of addresses.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctp_bindargs.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 sctp_bind_arg_list(int sock_fd, char **argv, int argc)
 4 {
 5     struct addrinfo *addr;
 6     char     *bindbuf, *p, portbuf[10];
 7     int       addrcnt = 0;
 8     int       i;

 9     bindbuf = (char *) Calloc(argc, sizeof(struct sockaddr_storage));
10     p = bindbuf;
11     sprintf(portbuf, "%d", SERV_PORT);
12     for (i = 0; i &lt; argc; i++) {
13         addr = Host_serv(argv[i], portbuf, AF_UNSPEC, SOCK_SEQPACKET);
14         memcpy(p, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
15         freeaddrinfo(addr);
16         addrcnt++;
17         p += addr-&gt;ai_addrlen;
18     }
19     Sctp_bindx(sock_fd, (SA *) bindbuf, addrcnt, SCTP_BINDX_ADD_ADDR);
20     free(bindbuf);
21     return (0);
22 }
</PRE>

<A NAME="ch23lev3sec24"></A>
<H4 class="docSection2Title"> Allocate space for bind arguments</H4>
<p class="docText"><span class="docEmphasis"><TT>9–10</TT></span> Our <TT>sctp_bind_arg_list</TT> function starts off by allocating space for the bind arguments. Note that the <TT>sctp_bindx</TT> function can accept a mix of IPv6 and IPv4 addresses. We allocate enough space for a <TT>sockaddr_storage</TT> for each address, even though the address list argument to <TT>sctp_bindx</TT> is a packed list of addresses (<A class="docLink" HREF="0131411551_ch09lev1sec4.html#ch09fig04">Figure 9.4</A>). This results in some memory waste but is simpler than calculating the exact space required by processing the argument list twice.</p>

<A NAME="ch23lev3sec25"></A>
<H4 class="docSection2Title"> Process arguments</H4>
<p class="docText"><span class="docEmphasis"><TT>11–18</TT></span> We set up the <span class="docEmphasis">portbuf</span> to be an ASCII representation of the port number, to prepare to call our <TT>getaddrinfo</TT> wrapper function, <TT>host_serv</TT>. We pass each address and the port number to <TT>host_serv</TT>, along with <TT>AF_UNSPEC</TT> to allow IPv4 or IPv6, and <TT>SOCK_SEQPACKET</TT> to specify that we're using SCTP. We copy the first <TT>sockaddr</TT> that is returned and ignore any others. Since the arguments to this function are meant to be literal address strings, as opposed to names that could have multiple addresses associated with them, this is safe. We free the return value from <TT>getaddrinfo</TT>, increment our count of addresses, and move the pointer to the next element in our packed array of <TT>sockaddr</TT> structures.</p>

<A NAME="ch23lev3sec26"></A>
<H4 class="docSection2Title"> Call binding function</H4>
<p class="docText"><span class="docEmphasis"><TT>19</TT></span> The function now resets its pointer to the top of the bind buffer and calls <TT>sctp_bindx</TT> with the subset of addresses decoded earlier.</p>

<A NAME="ch23lev3sec27"></A>
<H4 class="docSection2Title"> Return success</H4>
<p class="docText"><span class="docEmphasis"><TT>20–21</TT></span> If the function reaches here, we are successful, so clean up and return.</p>
<P class="docText"><A class="docLink" HREF="#ch23fig08">Figure 23.8</A> illustrates our modified echo server that now binds a list of addresses passed on the command line. Note that we have modified the server slightly so it always returns any echoed message on the stream on which it arrived.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig08"></A>Figure 23.8 Server using a variable set of addresses.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctpserv07.c</span></P>

<PRE>
12     if (argc &lt; 2)
13         err_quit("Error, use %s [list of addresses to bind]\n", argv[0]);
14     sock_fd = Socket(AF_INET6, SOCK_SEQPACKET, IPPROTO_SCTP);

15     if (sctp_bind_arg_list(sock_fd, argv + 1, argc - 1))
16         err_sys("Can't bind the address set");

17     bzero(&amp;evnts, sizeof(evnts));
18     evnts.sctp_data_io_event = 1;
</PRE>


<A NAME="ch23lev3sec28"></A>
<H4 class="docSection2Title"> Server code using IPv6</H4>
<p class="docText"><span class="docEmphasis"><TT>14</TT></span> Here we see the server we have been working on throughout this chapter, but with a slight modification. The server creates an <TT>AF_INET6</TT> socket. This way, the server can use both IPv4 and IPv6.</p>

<A NAME="ch23lev3sec29"></A>
<H4 class="docSection2Title"> Use the new <TT>sctp_bind_arg_list</TT> function</H4>
<p class="docText"><span class="docEmphasis"><TT>15–16</TT></span> The server calls the new <TT>sctp_bind_arg_list</TT> function, passing the argument list to it for processing.</p>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch23lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch23lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
