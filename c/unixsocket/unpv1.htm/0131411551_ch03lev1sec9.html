<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="3.9 'readn', 'writen', and 'readline' Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch03lev1sec8.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch03lev1sec10.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch03lev1sec9"></A>
<H3 class="docSection1Title">3.9 <TT>readn</TT>, <TT>writen</TT>, and <TT>readline</TT> Functions</H3>
<P class="docText">Stream sockets (e.g., TCP sockets) exhibit a behavior with the <TT>read</TT> and <TT>write</TT> functions that differs from normal file I/O. A <TT>read</TT> or <TT>write</TT> on a stream socket might input or output fewer bytes than requested, but this is not an error condition. The reason is that buffer limits might be reached for the socket in the kernel. All that is required to input or output the remaining bytes is for the caller to invoke the <TT>read</TT> or <TT>write</TT> function again. Some versions of Unix also exhibit this behavior when writing more than 4,096 bytes to a pipe. This scenario is always a possibility on a stream socket with <TT>read</TT>, but is normally seen with <TT>write</TT> only if the socket is nonblocking. Nevertheless, we always call our <TT>writen</TT> function instead of <TT>write</TT>, in case the implementation returns a short count.</P>
<P class="docText">We provide the following three functions that we use whenever we read from or write to a stream socket:</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include "unp.h"</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>ssize_t readn(int</TT> <span class="docEmphasis">filedes</span>, <TT>void *</TT><span class="docEmphasis">buff</span>, <TT>size_t</TT> <span class="docEmphasis">nbytes</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>ssize_t writen(int</TT> <span class="docEmphasis">filedes</span>, <TT>const void *</TT><span class="docEmphasis">buff</span>, <TT>size_t</TT> <span class="docEmphasis">nbytes</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>ssize_t readline(int</TT> <span class="docEmphasis">filedes</span>, <TT>void *</TT><span class="docEmphasis">buff</span>, <TT>size_t</TT> <span class="docEmphasis">maxlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">All return: number of bytes read or written, –1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><A class="docLink" HREF="#ch03fig15">Figure 3.15</A> shows the <TT>readn</TT> function, <A class="docLink" HREF="#ch03fig16">Figure 3.16</A> shows the <TT>writen</TT> function, and <A class="docLink" HREF="#ch03fig17">Figure 3.17</A> shows the <TT>readline</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch03fig15"></A>Figure 3.15 <TT>readn</TT> function: Read <span class="docEmphasis">n</span> bytes from a descriptor.</H5>
<P class="docText"><span class="docEmphasis">lib/readn.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 ssize_t                         /* Read "n" bytes from a descriptor. */
 3 readn(int fd, void *vptr, size_t n)
 4 {
 5     size_t  nleft;
 6     ssize_t nread;
 7     char   *ptr;

 8     ptr = vptr;
 9     nleft = n;
10     while (nleft &gt; 0) {
11         if ( (nread = read(fd, ptr, nleft)) &lt; 0) {
12             if (errno == EINTR)
13                 nread = 0;      /* and call read() again */
14             else
15                 return (-1);
16         } else if (nread == 0)
17             break;              /* EOF */

18         nleft -= nread;
19         ptr += nread;
20     }
21     return (n - nleft);         /* return &gt;= 0 */
22 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch03fig16"></A>Figure 3.16 <TT>writen</TT> function: Write <span class="docEmphasis">n</span> bytes to a descriptor.</H5>
<P class="docText"><span class="docEmphasis">lib/writen.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 ssize_t                         /* Write "n" bytes to a descriptor. */
 3 writen(int fd, const void *vptr, size_t n)
 4 {
 5     size_t nleft;
 6     ssize_t nwritten;
 7     const char *ptr;

 8     ptr = vptr;
 9     nleft = n;
10     while (nleft &gt; 0) {
11         if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) {
12             if (nwritten &lt; 0 &amp;&amp; errno == EINTR)
13                 nwritten = 0;   /* and call write() again */
14             else
15                 return (-1);    /* error */
16          }

17          nleft -= nwritten;
18          ptr += nwritten;
19     }
20     return (n);
21 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch03fig17"></A>Figure 3.17 <TT>readline</TT> function: Read a text line from a descriptor, one byte at a time.</H5>
<P class="docText"><span class="docEmphasis">test/readline1.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 /* PAINFULLY SLOW VERSION -- example only */
 3 ssize_t
 4 readline(int fd, void *vptr, size_t maxlen)
 5 {
 6     ssize_t n, rc;
 7     char    c, *ptr;

 8     ptr = vptr;
 9     for (n = 1; n &lt; maxlen; n++) {
10       again:
11         if ( (rc = read(fd, &amp;c, 1)) == 1) {
12             *ptr++ = c;
13             if (c == '\n')
14                 break;          /* newline is stored, like fgets() */
15         } else if (rc == 0) {
16             *ptr = 0;
17             return (n - 1);     /* EOF, n - 1 bytes were read */
18         } else {
19             if (errno == EINTR)
20                 goto again;
21             return (-1);        /* error, errno set by read() */
22         }
23     }

24     *ptr = 0;                   /* null terminate like fgets() */
25     return (n);
26 }
</PRE>

<P class="docText">Our three functions look for the error <TT>EINTR</TT> (the system call was interrupted by a caught signal, which we will discuss in more detail in <A class="docLink" HREF="0131411551_ch05lev1sec9.html#ch05lev1sec9">Section 5.9</A>) and continue reading or writing if the error occurs. We handle the error here, instead of forcing the caller to call <TT>readn</TT> or <TT>writen</TT> again, since the purpose of these three functions is to prevent the caller from having to handle a short count.</P>
<P class="docText">In <A class="docLink" HREF="0131411551_ch14lev1sec3.html#ch14lev1sec3">Section 14.3</A>, we will mention that the <TT>MSG_WAITALL</TT> flag can be used with the <TT>recv</TT> function to replace the need for a separate <TT>readn</TT> function.</P>
<P class="docText">Note that our <TT>readline</TT> function calls the system's <TT>read</TT> function once for every byte of data. This is very inefficient, and why we've commented the code to state it is "PAINFULLY SLOW." When faced with the desire to read lines from a socket, it is quite tempting to turn to the standard I/O library (referred to as "stdio"). We will discuss this approach at length in <A class="docLink" HREF="0131411551_ch14lev1sec8.html#ch14lev1sec8">Section 14.8</A>, but it can be a dangerous path. The same stdio buffering that solves this performance problem creates numerous logistical problems that can lead to well-hidden bugs in your application. The reason is that the state of the stdio buffers is not exposed. To explain this further, consider a line-based protocol between a client and a server, where several clients and servers using that protocol may be implemented over time (really quite common; for example, there are many Web browsers and Web servers independently written to the HTTP specification). Good "defensive programming" techniques require these programs to not only expect their counterparts to follow the network protocol, but to check for unexpected network traffic as well. Such protocol violations should be reported as errors so that bugs are noticed and fixed (and malicious attempts are detected as well), and also so that network applications can recover from problem traffic and continue working if possible. Using stdio to buffer data for performance flies in the face of these goals since the application has no way to tell if unexpected data is being held in the stdio buffers at any given time.</P>
<P class="docText">There are many line-based network protocols such as SMTP, HTTP, the FTP control connection protocol, and finger. So, the desire to operate on lines comes up again and again. But our advice is to think in terms of buffers and not lines. Write your code to read buffers of data, and if a line is expected, check the buffer to see if it contains that line.</P>
<P class="docText"><A class="docLink" HREF="#ch03fig18">Figure 3.18</A> shows a faster version of the <TT>readline</TT> function, which uses its own buffering rather than stdio buffering. Most importantly, the state of <TT>readline</TT>'s internal buffer is exposed, so callers have visibility into exactly what has been received. Even with this feature, <TT>readline</TT> can be problematic, as we'll see in <A class="docLink" HREF="0131411551_ch06lev1sec3.html#ch06lev1sec3">Section 6.3</A>. System functions like <TT>select</TT> still won't know about <TT>readline</TT>'s internal buffer, so a carelessly written program could easily find itself waiting in <TT>select</TT> for data already received and stored in <TT>readline</TT>'s buffers. For that matter, mixing <TT>readn</TT> and <TT>readline</TT> calls will not work as expected unless <TT>readn</TT> is modified to check the internal buffer as well.</P>

<H5 class="docExampleTitle"><A NAME="ch03fig18"></A>Figure 3.18 Better version of <TT>readline</TT> function.</H5>
<P class="docText"><span class="docEmphasis">lib/readline.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 static int read_cnt;
 3 static char *read_ptr;
 4 static char read_buf[MAXLINE];

 5 static ssize_t
 6 my_read(int fd, char *ptr)
 7 {

 8     if (read_cnt &lt;= 0) {
 9       again:
10         if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) {
11             if (errno == EINTR)
12                 goto again;
13             return (-1);
14         } else if (read_cnt == 0)
15             return (0);
16         read_ptr = read_buf;
17     }

18     read_cnt--;
19     *ptr = *read_ptr++;
20     return (1);
21 }
22 ssize_t
23 readline(int fd, void *vptr, size_t maxlen)
24 {
25     ssize_t n, rc;
26     char    c, *ptr;

27     ptr = vptr;
28     for (n = 1; n &lt; maxlen; n++) {
29         if ( (rc = my_read(fd, &amp;c)) == 1) {
30             *ptr++ = c;
31             if (c  == '\n')
32                 break;          /* newline is stored, like fgets() */
33         } else if (rc == 0) {
34             *ptr = 0;
35             return (n - 1);     /* EOF, n - 1 bytes were read */
36         } else
37             return (-1);        /* error, errno set by read() */
38     }

39     *ptr  = 0;                  /* null terminate like fgets() */
40     return (n);
41 }

42 ssize_t
43 readlinebuf(void **vptrptr)
44 {
45     if (read_cnt)
46         *vptrptr = read_ptr;
47     return (read_cnt);
48 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>2–21</TT></span> The internal function <TT>my_read</TT> reads up to <TT>MAXLINE</TT> characters at a time and then returns them, one at a time.</p>
<p class="docText"><span class="docEmphasis"><TT>29</TT></span> The only change to the <TT>readline</TT> function itself is to call <TT>my_read</TT> instead of <TT>read</TT>.</p>
<p class="docText"><span class="docEmphasis"><TT>42–48</TT></span> A new function, <TT>readlinebuf</TT>, exposes the internal buffer state so that callers can check and see if more data was received beyond a single line.</p>
<BLOCKQUOTE><P><P class="docList">Unfortunately, by using <TT>static</TT> variables in <TT>readline.c</TT> to maintain the state information across successive calls, the functions are not <span class="docEmphasis">re-entrant</span> or <span class="docEmphasis">thread-safe</span>. We will discuss this in <A class="docLink" HREF="0131411551_ch11lev1sec18.html#ch11lev1sec18">Sections 11.18</A> and <A class="docLink" HREF="0131411551_ch26lev1sec5.html#ch26lev1sec5">26.5</A>. We will develop a thread-safe version using thread-specific data in <A class="docLink" HREF="0131411551_ch26lev1sec5.html#ch26fig11">Figure 26.11</A>.</P></P></BLOCKQUOTE>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch03lev1sec8.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch03lev1sec10.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
