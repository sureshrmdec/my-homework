<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="18.1 Introduction"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch18.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch18lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch18lev1sec1"></A>
<H3 class="docSection1Title">18.1 Introduction</H3>
<P class="docText">Traditionally, the Unix routing table within the kernel has been accessed using <TT>ioctl</TT> commands. In <A class="docLink" HREF="0131411551_ch17lev1sec9.html#ch17lev1sec9">Section 17.9</A>, we described the two commands that are provided, <TT>SIOCADDRT</TT> and <TT>SIOCDELRT</TT>, to add or delete a route. We also mentioned that no command exists to dump the entire routing table, and instead programs such as <TT>netstat</TT> read the kernel memory to obtain the contents of the routing table. One additional piece to this hodgepodge is that routing daemons such as <TT>gated</TT> need to monitor ICMP redirect messages that are received by the kernel, and they often do this by creating a raw ICMP socket (<A class="docLink" HREF="0131411551_ch28.html#ch28">Chapter 28</A>) and listening on this socket to all received ICMP messages.</P>
<P class="docText">4.3BSD Reno cleaned up the interface to the kernel's routing subsystem by creating the <TT>AF_ROUTE</TT> domain. The only type of socket supported in the route domain is a raw socket. Three types of operations are supported on a routing socket:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">A process can send a message to the kernel by writing to a routing socket. For example, this is how routes are added and deleted.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A process can read a message from the kernel on a routing socket. This is how the kernel notifies a process that an ICMP redirect has been received and processed, or how it requests a route resolution from an external routing process.</P><P class="docList">Some operations involve both steps. For example, the process sends a message to the kernel on a routing socket asking for all the information on a given route, and the process reads back the response from the kernel on the routing socket.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A process can use the <TT>sysctl</TT> function (<A class="docLink" HREF="0131411551_ch18lev1sec4.html#ch18lev1sec4">Section 18.4</A>) to either dump the routing table or list all configured interfaces.</P></span></LI></OL></span>
<P class="docText">The first two operations require superuser privileges on most systems, while the last operation can be performed by any process.</P>
<BLOCKQUOTE><P><P class="docList">Some newer releases have relaxed the superuser requirement for opening a routing socket and instead restrict only routing socket messages that change the table. This allows any process to use, for instance, <TT>RTM_GET</TT> to look up a route without being the superuser.</P></P><P><P class="docList">Technically, the third operation is not performed using a routing socket but invokes the generic <TT>sysctl</TT> function. We will see that one of the input parameters is the address family, which is <TT>AF_ROUTE</TT> for the operations we describe in this chapter, and the information returned is in the same format as the information returned by the kernel on a routing socket. Indeed, the <TT>sysctl</TT> processing for the <TT>AF_ROUTE</TT> family is part of the routing socket code in a 4.4BSD kernel (pp.632–643 of TCPv2).</P></P><P><P class="docList">The <TT>sysctl</TT> utility appeared in 4.4BSD. Unfortunately, not all implementations that support routing sockets provide <TT>sysctl</TT>. For example, AIX 5.1 and Solaris 9 support routing sockets, but neither supports <TT>sysctl</TT>.</P></P></BLOCKQUOTE>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch18.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch18lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
