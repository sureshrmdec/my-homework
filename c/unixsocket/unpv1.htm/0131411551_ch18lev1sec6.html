<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="18.6 Interface Name and Index Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch18lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch18lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch18lev1sec6"></A>
<H3 class="docSection1Title">18.6 Interface Name and Index Functions</H3>
<P class="docText">RFC 3493 [Gilligan et al. 2003] defines four functions that deal with interface names and indexes. These four functions are used in many places where it is necessary to describe an interface. They were introduced for use with the IPv6 API, as we will describe in <A class="docLink" HREF="0131411551_ch21.html#ch21">Chapters 21</A> and <A class="docLink" HREF="0131411551_ch27.html#ch27">27</A>, but we find interface indexes in the IPv4 API as well (e.g., in the <TT>IP_RECVIF</TT> call, or in <TT>AF_LINK</TT> sockaddrs seen on the routing socket). The basic concept is that each interface has a unique name and a unique positive index (0 is never used as an index).</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;net/if.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>unsigned int if_nametoindex (const char *</TT><span class="docEmphasis">ifname</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: positive interface index if OK, 0 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>char *if_indextoname (unsigned int</TT> <span class="docEmphasis">ifindex</span><TT>, char *</TT><span class="docEmphasis">ifname</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: <TT>pointer to interface name if OK</TT>, <TT>NULL on error</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>struct if_nameindex *if_nameindex (void);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: <TT>non-null pointer if OK</TT>, <TT>NULL on error</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void if_freenameindex(struct if_nameindex *</TT><span class="docEmphasis">ptr</span><TT>);</TT></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>if_nametoindex</TT> returns the index of the interface whose name is <span class="docEmphasis">ifname</span>. <TT>if_indextoname</TT> returns a pointer to the interface name given its <span class="docEmphasis">ifindex</span>. The <span class="docEmphasis">ifname</span> argument points to a buffer of size <TT>IFNAMSIZ</TT> (defined by including the <TT>&lt;net/if.h&gt;</TT> header; also shown in <A class="docLink" HREF="0131411551_ch17lev1sec5.html#ch17fig02">Figure 17.2</A>) that the caller must allocate to hold the result, and this pointer is also the return value upon success.</P>
<P class="docText"><TT>if_nameindex</TT> returns a pointer to an array of <TT>if_nameindex</TT> structures as follows:</P>
<pre>

</pre><pre>
struct if_nameindex {
  unsigned int   if_index;     /* 1, 2, ... */
  char          *if_name;      /* null-terminated name: "le0", ... */
};
</pre><pre>
</pre>
<P class="docText">The final entry in this array contains a structure with an <TT>if_index</TT> of 0 and an <TT>if_name</TT> that is a null pointer. The memory for this array, along with the names pointed to by the array members, is dynamically obtained and is returned by calling <TT>if_freenameindex</TT>.</P>
<P class="docText">We now provide an implementation of these four functions using routing sockets.</P>
<A NAME="ch18lev2sec3"></A>
<H4 class="docSection2Title"> <TT>if_nametoindex</TT> Function</H4>
<P class="docText"><A class="docLink" HREF="#ch18fig18">Figure 18.18</A> shows the <TT>if_nametoindex</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig18"></A>Figure 18.18 Return an interface index given its name.</H5>
<P class="docText"><span class="docEmphasis">libroute/if_nametoindex.c</span></P>

<PRE>
 1 #include     "unpifi.h"
 2 #include     "unproute.h"

 3 unsigned int
 4 if_nametoindex(const char *name)
 5 {
 6     unsigned int idx, namelen;
 7     char     *buf, *next, *lim;
 8     size_t     len;
 9     struct if_msghdr *ifm;
10     struct sockaddr *sa, *rti_info[RTAX_MAX];
11     struct sockaddr_dl *sdl;

12     if ( (buf = net_rt_iflist(0, 0, &amp;len)) == NULL)
13         return (0);

14     namelen = strlen(name);
15     lim = buf + len;
16     for (next = buf; next &lt; lim; next += ifm-&gt;ifm_msglen) {
17         ifm = (struct if_msghdr *) next;
18         if (ifm-&gt;ifm_type == RTM_IFINFO) {
19             sa = (struct sockaddr *) (ifm + 1);
20             get_rtaddrs (ifm-&gt;ifm_addrs, sa, rti_info);
21             if ( (sa = rti_info[RTAX_IFP]) != NULL) {
22                 if (sa-&gt;sa_family == AF_LINK) {
23                     sdl = (struct sockaddr_dl *) sa;
24                     if (sdl-&gt;sdl_nlen == namelen
25                         &amp;&amp; strncmp (&amp;sdl-&gt;sdl_data [0], name,
26                                             sdl-&gt;sdl_nlen) == 0) {
27                         idx = sdl-&gt;sdl_index;     /* save before free() */
28                         free(buf);
29                         return (idx);
30                     }
31                 } 
32             }

33         }
34     }
35     free(buf);
36     return (0);     /* no match for name */
37 }
</PRE>

<A NAME="ch18lev3sec14"></A>
<H5 class="docSection3Title"> Get interface list</H5>
<p class="docText"><span class="docEmphasis"><TT>12–13</TT></span> Our <TT>net_rt_iflist</TT> function returns the interface list.</p>

<A NAME="ch18lev3sec15"></A>
<H5 class="docSection3Title"> Process only <TT>RTM_IFINFO</TT> messages</H5>
<p class="docText"><span class="docEmphasis"><TT>17–30</TT></span> We process the messages in the buffer (<A class="docLink" HREF="0131411551_ch18lev1sec4.html#ch18fig14">Figure 18.14</A>), looking only for the <TT>RTM_IFINFO</TT> messages. When we find one, we call our <TT>get_rtaddrs</TT> function to set up the pointers to the socket address structures, and if an interface name structure is present (the <TT>RTAX_IFP</TT> element of the <TT>rti_info</TT> array), the interface name is compared to the argument.</p>


<A NAME="ch18lev2sec4"></A>
<H4 class="docSection2Title"> <TT>if_indextoname</TT> Function</H4>
<P class="docText">The next function, <TT>if_indextoname</TT>, is shown in <A class="docLink" HREF="#ch18fig19">Figure 18.19</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig19"></A>Figure 18.19 Return an interface name given its index.</H5>
<P class="docText"><span class="docEmphasis">libroute/if_indextoname.c</span></P>

<PRE>
 1 #include     "unpifi.h"
 2 #include     "unproute.h"

 3 char *
 4 if_indextoname(unsigned int idx, char *name)
 5 {
 6     char *buf, *next, *lim;
 7     size_t len;
 8     struct if_msghdr *ifm;
 9     struct sockaddr *sa, *rti_info [RTAX_MAX];
10     struct sockaddr_dl *sdl;

11     if ( (buf = net_rt_iflist(0, idx, &amp;len)) == NULL)
12         return (NULL);

13     lim = buf + len;
14     for (next = buf; next &lt; lim; next += ifm-&gt;ifm_msglen) {
15         ifm = (struct if_msghdr *) next;
16         if (ifm-&gt;ifm_type == RTM_IFINFO) {
17             sa = (struct sockaddr *) (ifm + 1);
18             get_rtaddrs(ifm-&gt;ifm_addrs, sa, rti_info);
19             if ( (sa = rti_info[RTAX_IFP]) != NULL) {
20                 if (sa-&gt;sa_family == AF_LINK) {
21                     sdl = (struct sockaddr_dl *) sa;
22                     if (sdl-&gt;sdl_index == idx) {
23                         int     slen = min(IFNAMSIZ - 1, sdl-&gt;sdl_nlen);
24                         strncpy(name, sdl-&gt;sdl_data, slen);
25                         name[slen] = 0; /* null terminate */
26                         free(buf);
27                         return (name);
28                     }
29                 } 
30             }

31         }
32     }
33     free(buf);
34     return (NULL);     /* no match for index */
35  }
</PRE>

<P class="docText">This function is nearly identical to the previous function, but instead of looking for an interface name, we compare the interface index against the caller's argument. Also, the second argument to our <TT>net_rt_iflist</TT> function is the desired index, so the result should contain the information for only the desired interface. When a match is found, the interface name is returned and it is also null-terminated.</P>

<A NAME="ch18lev2sec5"></A>
<H4 class="docSection2Title"> <TT>if_nameindex</TT> Function</H4>
<P class="docText">The next function, <TT>if_nameindex</TT>, returns an array of <TT>if_nameindex</TT> structures containing all the interface names and indexes. It is shown in <A class="docLink" HREF="#ch18fig20">Figure 18.20</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig20"></A>Figure 18.20 Return all the interface names and indexes.</H5>
<P class="docText"><span class="docEmphasis">libroute/if_nameindex.c</span></P>

<PRE>
 1 #include     "unpifi.h"
 2 #include     "unproute.h"

 3 struct if_nameindex *
 4 if_nameindex (void)
 5 {
 6     char *buf, *next, *lim;
 7     size_t len;
 8     struct if_msghdr *ifm;
 9     struct sockaddr *sa, *rti_info [RTAX_MAX];
10     struct sockaddr_dl *sdl;
11     struct if_nameindex *result, *ifptr;
12     char *namptr;

13     if ( (buf = net_rt_iflist (0, 0, &amp;len) ) == NULL)
14         return (NULL);

15     if ( (result = malloc (len) ) == NULL) /* overestimate */
16         return (NULL);
17     ifptr = result;
18     namptr = (char *) result + len; /* names start at end of buffer */

19     lim = buf + len;
20     for (next = buf; next &lt; lim; next += ifm-&gt;ifm_msglen) {
21         ifm = (struct if_msghdr *) next;
22         if (ifm-&gt;ifm_type == RTM_IFINFO) {
23             sa = (struct sockaddr *) (ifm + 1);
24             get_rtaddrs (ifm-&gt;ifm_addrs, sa, rti_info);
25             if ( (sa = rti_info[RTAX_IFP]) != NULL) {
26                 if (sa-&gt;sa_family == AF_LINK) {
27                     sdl = (struct sockaddr_dl *) sa;
28                     namptr -= sdl-&gt;sdl_nlen + 1;
29                     strncpy (namptr, &amp;sdl-&gt;sdl_data[0], sdl-&gt;sdl_nlen);
30                     namptr [sdl-&gt;sdl_nlen] = 0; /* null terminate */
31                     ifptr-&gt;if_name = namptr;
32                     ifptr-&gt;if_index = sdl-&gt;sdl_index;
33                     ifptr++;
34                 } 
35             }

36         }
37     }
38     ifptr-&gt;if_name = NULL;     /* mark end of array of structs */
39     ifptr-&gt;if_index = 0;
40     free (buf);
41     return (result);              /* caller must free() this when done */
42 }
</PRE>

<A NAME="ch18lev3sec16"></A>
<H5 class="docSection3Title"> Get interface list, allocate room for result</H5>
<p class="docText"><span class="docEmphasis"><TT>13–18</TT></span> We call our <TT>net_rt_iflist</TT> function to return the interface list. We also use the returned size as the size of the buffer that we allocate to contain the array of <TT>if_nameindex</TT> structures we return. This is an overestimate, but it is simpler than making two passes through the interface list: one to count the number of interfaces and the total sizes of the names and another to fill in the information. We create the <TT>if_nameindex</TT> array at the beginning of this buffer and store the interface names starting at the end of the buffer.</p>

<A NAME="ch18lev3sec17"></A>
<H5 class="docSection3Title"> Process only <TT>RTM_IFINFO</TT> messages</H5>
<p class="docText"><span class="docEmphasis"><TT>23–36</TT></span> We process all the messages looking for <TT>RTM_IFINFO</TT> messages and the datalink socket address structures that follow. The interface name and index are stored in the array we are building.</p>

<A NAME="ch18lev3sec18"></A>
<H5 class="docSection3Title"> Terminate array</H5>
<p class="docText"><span class="docEmphasis"><TT>38–39</TT></span> The final entry in the array has a null <TT>if_name</TT> and an index of 0.</p>


<A NAME="ch18lev2sec6"></A>
<H4 class="docSection2Title"> <TT>if_freenameindex</TT> Function</H4>
<P class="docText">The final function, shown in <A class="docLink" HREF="#ch18fig21">Figure 18.21</A>, frees the memory that was allocated for the array of <TT>if_nameindex</TT> structures and the names contained therein.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig21"></A>Figure 18.21 Free the memory allocated by <TT>if_nameindex</TT>.</H5>
<P class="docText"><span class="docEmphasis">libroute/if_nameindex.c</span></P>

<PRE>
43 void
44 if_freenameindex(struct if_nameindex *ptr)
45 {
46     free(ptr);
47 }
</PRE>

<P class="docText">This function is trivial because we stored both the array of structures and the names in the same buffer. If we had called <TT>malloc</TT> for each name, to free the memory, we would have to go through the entire array, <TT>free</TT> the memory for each name, and then free the array.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch18lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch18lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
