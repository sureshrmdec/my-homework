<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.11 'connect' Function with UDP"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch08lev1sec10.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch08lev1sec12.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec11"></A>
<H3 class="docSection1Title">8.11 <TT>connect</TT> Function with UDP</H3>
<P class="docText">We mentioned at the end of <A class="docLink" HREF="0131411551_ch08lev1sec9.html#ch08lev1sec9">Section 8.9</A> that an asynchronous error is not returned on a UDP socket unless the socket has been connected. Indeed, we are able to call <TT>connect</TT> (<A class="docLink" HREF="0131411551_ch04lev1sec3.html#ch04lev1sec3">Section 4.3</A>) for a UDP socket. But this does not result in anything like a TCP connection: There is no three-way handshake. Instead, the kernel just checks for any immediate errors (e.g., an obviously unreachable destination), records the IP address and port number of the peer (from the socket address structure passed to <TT>connect</TT>), and returns immediately to the calling process.</P>
<BLOCKQUOTE><P><P class="docList">Overloading the <TT>connect</TT> function with this capability for UDP sockets is confusing. If the convention that <TT>sockname</TT> is the local protocol address and <TT>peername</TT> is the foreign protocol address is used, then a better name would have been <TT>setpeername</TT>. Similarly, a better name for the <TT>bind</TT> function would be <TT>setsockname</TT>.</P></P></BLOCKQUOTE>
<P class="docText">With this capability, we must now distinguish between</P>
<UL><LI><P class="docList">An <span class="docEmphasis">unconnected UDP socket</span>, the default when we create a UDP socket</P></LI><LI><P class="docList">A <span class="docEmphasis">connected UDP socket</span>, the result of calling <TT>connect</TT> on a UDP socket</P></LI></UL>
<P class="docText">With a connected UDP socket, three things change, compared to the default unconnected UDP socket:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">We can no longer specify the destination IP address and port for an output operation. That is, we do not use <TT>sendto</TT>, but <TT>write</TT> or <TT>send</TT> instead. Anything written to a connected UDP socket is automatically sent to the protocol address (e.g., IP address and port) specified by <TT>connect</TT>.</P><BLOCKQUOTE><P><P class="docList">Similar to TCP, we can call <TT>sendto</TT> for a connected UDP socket, but we cannot specify a destination address. The fifth argument to <TT>sendto</TT> (the pointer to the socket address structure) must be a null pointer, and the sixth argument (the size of the socket address structure) should be 0. The POSIX specification states that when the fifth argument is a null pointer, the sixth argument is ignored.</P></P></BLOCKQUOTE></span></LI><LI><span style="font-weight:normal"><P class="docList">We do not need to use <TT>recvfrom</TT> to learn the sender of a datagram, but <TT>read</TT>, <TT>recv</TT>, or <TT>recvmsg</TT> instead. The only datagrams returned by the kernel for an input operation on a connected UDP socket are those arriving from the protocol address specified in <TT>connect</TT>. Datagrams destined to the connected UDP socket's local protocol address (e.g., IP address and port) but arriving from a protocol address other than the one to which the socket was connected are not passed to the connected socket. This limits a connected UDP socket to exchanging datagrams with one and only one peer.</P><BLOCKQUOTE><P><P class="docList">Technically, a connected UDP socket exchanges datagrams with only one IP address, because it is possible to <TT>connect</TT> to a multicast or broadcast address.</P></P></BLOCKQUOTE></span></LI><LI><span style="font-weight:normal"><P class="docList">Asynchronous errors are returned to the process for connected UDP sockets.</P><P class="docList">The corollary, as we previously described, is that unconnected UDP sockets do not receive asynchronous errors.</P></span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="#ch08fig14">Figure 8.14</A> summarizes the first point in the list with respect to 4.4BSD.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch08fig14"></A>Figure 8.14. TCP and UDP sockets: can a destination protocol address be specified?</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="498" HEIGHT="112" src="FILES/08fig14.gif" ALT="graphics/08fig14.gif"></p>

</CENTER>
<BLOCKQUOTE><P><P class="docList">The POSIX specification states that an output operation that does not specify a destination address on an unconnected UDP socket should return <TT>ENOTCONN</TT>, not <TT>EDESTADDRREQ</TT>.</P></P></BLOCKQUOTE>
<P class="docText"><A class="docLink" HREF="#ch08fig15">Figure 8.15</A> summarizes the three points that we made about a connected UDP socket.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch08fig15"></A>Figure 8.15. Connected UDP socket.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="202" src="FILES/08fig15.gif" ALT="graphics/08fig15.gif"></p>

</CENTER>
<P class="docText">The application calls <TT>connect</TT>, specifying the IP address and port number of its peer. It then uses <TT>read</TT> and <TT>write</TT> to exchange data with the peer.</P>
<P class="docText">Datagrams arriving from any other IP address or port (which we show as "???" in <A class="docLink" HREF="#ch08fig15">Figure 8.15</A>) are not passed to the connected socket because either the source IP address or source UDP port does not match the protocol address to which the socket is <TT>connected</TT>. These datagrams could be delivered to some other UDP socket on the host. If there is no other matching socket for the arriving datagram, UDP will discard it and generate an ICMP "port unreachable" error.</P>
<P class="docText">In summary, we can say that a UDP client or server can call <TT>connect</TT> only if that process uses the UDP socket to communicate with exactly one peer. Normally, it is a UDP client that calls <TT>connect</TT>, but there are applications in which the UDP server communicates with a single client for a long duration (e.g., TFTP); in this case, both the client and server can call <TT>connect</TT>.</P>
<P class="docText">The DNS provides another example, as shown in <A class="docLink" HREF="#ch08fig16">Figure 8.16</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch08fig16"></A>Figure 8.16. Example of DNS clients and servers and the <TT>connect</TT> function.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="102" src="FILES/08fig16.gif" ALT="graphics/08fig16.gif"></p>

</CENTER>
<P class="docText">A DNS client can be configured to use one or more servers, normally by listing the IP addresses of the servers in the file <TT>/etc/resolv.conf</TT>. If a single server is listed (the leftmost box in the figure), the client can call <TT>connect</TT>, but if multiple servers are listed (the second box from the right in the figure), the client cannot call <TT>connect</TT>. Also, a DNS server normally handles any client request, so the servers cannot call <TT>connect</TT>.</P>
<A NAME="ch08lev2sec1"></A>
<H4 class="docSection2Title"> Calling <TT>connect</TT> Multiple Times for a UDP Socket</H4>
<P class="docText">A process with a connected UDP socket can call <TT>connect</TT> again for that socket for one of two reasons:</P>
<UL><LI><P class="docList">To specify a new IP address and port</P></LI><LI><P class="docList">To unconnect the socket</P></LI></UL>
<P class="docText">The first case, specifying a new peer for a connected UDP socket, differs from the use of <TT>connect</TT> with a TCP socket: <TT>connect</TT> can be called only one time for a TCP socket.</P>
<P class="docText">To unconnect a UDP socket, we call <TT>connect</TT> but set the family member of the socket address structure (<TT>sin_family</TT> for IPv4 or <TT>sin6_family</TT> for IPv6) to <TT>AF_UNSPEC</TT>. This might return an error of <TT>EAFNOSUPPORT</TT> (p. 736 of TCPv2), but that is acceptable. It is the process of calling <TT>connect</TT> on an already connected UDP socket that causes the socket to become unconnected (pp. 787–788 of TCPv2).</P>
<BLOCKQUOTE><P><P class="docList">The Unix variants seem to differ on exactly how to unconnect a socket, and you may encounter approaches that work on some systems and not others. For example, calling <TT>connect</TT> with <TT>NULL</TT> for the address works only on some systems (and on some, it only works if the third argument, the length, is nonzero). The POSIX specification and BSD man pages are not much help here, only mentioning that a <span class="docEmphasis">null address</span> should be used and not mentioning the error return (even on success) at all. The most portable solution is to zero out an address structure, set the family to <TT>AF_UNSPEC</TT> as mentioned above, and pass it to <TT>connect</TT>.</P></P><P><P class="docList">Another area of disagreement is around the local binding of a socket during the unconnect process. AIX keeps both the chosen local IP address and the port, even from an implicit bind. FreeBSD and Linux set the local IP address back to all zeros, even if you previously called <TT>bind</TT>, but leave the port number intact. Solaris sets the local IP address back to all zeros if it was assigned by an implicit bind; but if the program called <TT>bind</TT> explicitly, then the IP address remains unchanged.</P></P></BLOCKQUOTE>

<A NAME="ch08lev2sec2"></A>
<H4 class="docSection2Title"> Performance</H4>
<P class="docText">When an application calls <TT>sendto</TT> on an unconnected UDP socket, Berkeley-derived kernels temporarily connect the socket, send the datagram, and then unconnect the socket (pp. 762–763 of TCPv2). Calling <TT>sendto</TT> for two datagrams on an unconnected UDP socket then involves the following six steps by the kernel:</P>
<UL><LI><P class="docList">Connect the socket</P></LI><LI><P class="docList">Output the first datagram</P></LI><LI><P class="docList">Unconnect the socket</P></LI><LI><P class="docList">Connect the socket</P></LI><LI><P class="docList">Output the second datagram</P></LI><LI><P class="docList">Unconnect the socket</P></LI></UL>
<BLOCKQUOTE><P><P class="docList">Another consideration is the number of searches of the routing table. The first temporary connect searches the routing table for the destination IP address and saves (caches) that information. The second temporary connect notices that the destination address equals the destination of the cached routing table information (we are assuming two <TT>sendtos</TT> to the same destination) and we do not need to search the routing table again (pp. 737–738 of TCPv2).</P></P></BLOCKQUOTE>
<P class="docText">When the application knows it will be sending multiple datagrams to the same peer, it is more efficient to connect the socket explicitly. Calling <TT>connect</TT> and then calling <TT>write</TT> two times involves the following steps by the kernel:</P>
<UL><LI><P class="docList">Connect the socket</P></LI><LI><P class="docList">Output first datagram</P></LI><LI><P class="docList">Output second datagram</P></LI></UL>
<P class="docText">In this case, the kernel copies only the socket address structure containing the destination IP address and port one time, versus two times when <TT>sendto</TT> is called twice. [Partridge and Pink 1993] note that the temporary connecting of an unconnected UDP socket accounts for nearly one-third of the cost of each UDP transmission.</P>


<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch08lev1sec10.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch08lev1sec12.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
