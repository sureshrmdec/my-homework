<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.19 'gethostbyname_r' and 'gethostbyaddr_r' Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch11lev1sec18.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch11lev1sec20.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch11lev1sec19"></A>
<H3 class="docSection1Title">11.19 <TT>gethostbyname_r</TT> and <TT>gethostbyaddr_r</TT> Functions</H3>
<P class="docText">There are two ways to make a nonre-entrant function such as <TT>gethostbyname</TT> re-entrant.</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Instead of filling in and returning a static structure, the caller allocates the structure and the re-entrant function fills in the caller's structure. This is the technique used in going from the nonre-entrant <TT>gethostbyname</TT> to the re-entrant <TT>gethostbyname_r</TT>. But, this solution gets more complicated because not only must the caller provide the <TT>hostent</TT> structure to fill in, but this structure also points to other information: the canonical name, the array of alias pointers, the alias strings, the array of address pointers, and the addresses (e.g., <A class="docLink" HREF="0131411551_ch11lev1sec3.html#ch11fig02">Figure 11.2</A>). The caller must provide one large buffer that is used for this additional information and the <TT>hostent</TT> structure that is filled in then contains numerous pointers into this other buffer. This adds at least three arguments to the function: a pointer to the <TT>hostent</TT> structure to fill in, a pointer to the buffer to use for all the other information, and the size of this buffer. A fourth additional argument is also required: a pointer to an integer in which an error code can be stored, since the global integer <TT>h_errno</TT> can no longer be used. (The global integer <TT>h_errno</TT> presents the same re-entrancy problem that we described with <TT>errno</TT>.)</P><P class="docList">This technique is also used by <TT>getnameinfo</TT> and <TT>inet_ntop</TT>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The re-entrant function calls <TT>malloc</TT> and dynamically allocates the memory. This is the technique used by <TT>getaddrinfo</TT>. The problem with this approach is that the application calling this function must also call <TT>freeaddrinfo</TT> to free the dynamic memory. If the free function is not called, a <span class="docEmphasis">memory leak</span> occurs: Each time the process calls the function that allocates the memory, the memory use of the process increases. If the process runs for a long time (a common trait of network servers), the memory usage just grows and grows over time.</P></span></LI></OL></span>
<P class="docText">We will now discuss the Solaris 2.x re-entrant functions for name-to-address and address-to-name resolution.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;netdb.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>struct hostent *gethostbyname_r (const char</TT> *<span class="docEmphasis">hostname</span>, <TT>struct hostent</TT> *<span class="docEmphasis">result</span>, <TT>char</TT> *<span class="docEmphasis">buf</span>, <TT>int</TT> <span class="docEmphasis">buflen</span>, <TT>int</TT> *<span class="docEmphasis">h_errnop</span>) ;</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>struct hostent *gethostbyaddr_r (const char</TT> *<span class="docEmphasis">addr</span>, <TT>int</TT> <span class="docEmphasis">len</span>, <TT>int</TT> <span class="docEmphasis">type</span>, <TT>struct hostent</TT> *<span class="docEmphasis">result</span>, <TT>char</TT> *<span class="docEmphasis">buf</span>, <TT>int</TT> <span class="docEmphasis">buflen</span>, <TT>int</TT> *<span class="docEmphasis">h_errnop</span>) ;</P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Both return: non-null pointer if OK, NULL on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">Four additional arguments are required for each function. <span class="docEmphasis">result</span> is a <TT>hostent</TT> structure allocated by the caller. It is filled in by the function. On success, this pointer is also the return value of the function.</P>
<P class="docText"><span class="docEmphasis">buf</span> is a buffer allocated by the caller and <span class="docEmphasis">buflen</span> is its size. This buffer will contain the c&agrave;nonical hostname, the alias pointers, the alias strings, the address pointers, and the actual addresses. All the pointers in the structure pointed to by <span class="docEmphasis">result</span> point into this buffer. How big should this buffer be? Unfortunately, all that most man pages say is something vague like, "The buffer must be large enough to hold all of the data associated with the host entry." Current implementations of <TT>gethostbyname</TT> can return up to 35 alias pointers and 35 address pointers, and internally use an 8192-byte buffer to hold alias names and addresses. So, a buffer size of 8192 bytes should be adequate.</P>
<P class="docText">If an error occurs, the error code is returned through the <span class="docEmphasis">h_errnop</span> pointer, not through the global <TT>h_errno</TT>.</P>
<BLOCKQUOTE><P><P class="docList">Unfortunately, this problem of re-entrancy is even worse than it appears. First, there is no standard regarding re-entrancy and <TT>gethostbyname</TT> and <TT>gethostbyaddr</TT>. The POSIX specification says that <TT>gethostbyname</TT> and <TT>gethostbyaddr</TT> need not be re-entrant. Unix 98 just says that these two functions need not be thread-safe.</P></P><P><P class="docList">Second, there is no standard for the <TT>_r</TT> functions. What we have shown in this section (for example purposes) are two of the <TT>_r</TT> functions provided by Solaris 2.x. Linux provides similar <TT>_r</TT> functions, except that instead of returning the <TT>hostent</TT> as the return value of the function, the <TT>hostent</TT> is returned using a value-result parameter as the next to last function argument. It returns the success of the lookup as the return value from the function as well as in the <TT>h_errno</TT> argument. Digital Unix 4.0 and HP-UX 10.30 have versions of these functions with different arguments. The first two arguments for <TT>gethostbyname_r</TT> are the same as the Solaris version, but the remaining three arguments for the Solaris version are combined into a new <TT>hostent_data</TT> structure (which must be allocated by the caller), and a pointer to this structure is the third and final argument. The normal functions <TT>gethostbyname</TT> and <TT>gethostbyaddr</TT> in Digital Unix 4.0 and HP-UX 10.30 are re-entrant by using thread-specific data (<A class="docLink" HREF="0131411551_ch26lev1sec5.html#ch26lev1sec5">Section 26.5</A>). An interesting history of the development of the Solaris 2.x <TT>_r</TT> functions is in [Maslen 1997].</P></P><P><P class="docList">Lastly, while a re-entrant version of <TT>gethostbyname</TT> may provide safety from different threads calling it at the same time, this says nothing about the re-entrancy of the underlying resolver functions.</P></P></BLOCKQUOTE>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch11lev1sec18.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch11lev1sec20.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
