<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.12 'dg_cli' Function (Revisited)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch08lev1sec11.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch08lev1sec13.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec12"></A>
<H3 class="docSection1Title">8.12 <TT>dg_cli</TT> Function (Revisited)</H3>
<P class="docText">We now return to the <TT>dg_cli</TT> function from <A class="docLink" HREF="0131411551_ch08lev1sec6.html#ch08fig08">Figure 8.8</A> and recode it to call <TT>connect</TT>. <A class="docLink" HREF="#ch08fig17">Figure 8.17</A> shows the new function.</P>

<H5 class="docExampleTitle"><A NAME="ch08fig17"></A>Figure 8.17 <TT>dg_cli</TT> function that calls <TT>connect</TT>.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/dgcliconnect.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 void
 3 dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
 4 {
 5     int     n;
 6     char    sendline[MAXLINE], recvline[MAXLINE + 1];

 7     Connect(sockfd, (SA *) pservaddr, servlen);

 8     while (Fgets(sendline, MAXLINE, fp) != NULL) {

 9         Write(sockfd, sendline, strlen(sendline));

10         n = Read(sockfd, recvline, MAXLINE);

11         recvline[n] = 0;        /* null terminate */
12         Fputs(recvline, stdout);
13     }
14 }
</PRE>

<P class="docText">The changes are the new call to <TT>connect</TT> and replacing the calls to <TT>sendto</TT> and <TT>recvfrom</TT> with calls to <TT>write</TT> and <TT>read</TT>. This function is still protocol-independent since it doesn't look inside the socket address structure that is passed to <TT>connect</TT>. Our client <TT>main</TT> function, <A class="docLink" HREF="0131411551_ch08lev1sec5.html#ch08fig07">Figure 8.7</A>, remains the same.</P>
<P class="docText">If we run this program on the host <TT>macosx</TT>, specifying the IP address of the host <TT>freebsd4</TT> (which is not running our server on port 9877), we have the following output:</P>
<pre>

</pre><pre>
macosx % <span class="docEmphStrong">udpcli04 172.24.37.94</span>
<span class="docEmphStrong">hello, world</span>
read error: Connection refused
</pre><pre>
</pre>
<P class="docText">The first point we notice is that we do <span class="docEmphasis">not</span> receive the error when we start the client process. The error occurs only after we send the first datagram to the server. It is sending this datagram that elicits the ICMP error from the server host. But when a TCP client calls <TT>connect</TT>, specifying a server host that is not running the server process, <TT>connect</TT> returns the error because the call to <TT>connect</TT> causes the TCP three-way handshake to happen, and the first packet of that handshake elicits an RST from the server TCP (<A class="docLink" HREF="0131411551_ch04lev1sec3.html#ch04lev1sec3">Section 4.3</A>).</P>
<P class="docText"><A class="docLink" HREF="#ch08fig18">Figure 8.18</A> shows the <TT>tcpdump</TT> output.</P>

<H5 class="docExampleTitle"><A NAME="ch08fig18"></A>Figure 8.18 <TT>tcpdump</TT> output when running <A class="docLink" HREF="#ch08fig17">Figure 8.17</A>.</H5>

<PRE>
macosx % <span class="docEmphStrong">tcpdump</span>
<span class="docEmphasis">1</span>  0.0                    macosx.51139 &gt; freebsd4.9877: udp 13
<span class="docEmphasis">2</span>  0.006180 ( 0.0062)     freebsd4 &gt; macosx: icmp: freebsd4 udp port 9877 unreachable
</PRE>

<P class="docText">We also see in <A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig15">Figure A.15</A> that this ICMP error is mapped by the kernel into the error <TT>ECONNREFUSED</TT>, which corresponds to the message string output by our <TT>err_sys</TT> function: "Connection refused."</P>
<BLOCKQUOTE><P><P class="docList">Unfortunately, not all kernels return ICMP messages to a connected UDP socket, as we have shown in this section. Normally, Berkeley-derived kernels return the error, while System V kernels do not. For example, if we run the same client on a Solaris 2.4 host and <TT>connect</TT> to a host that is not running our server, we can watch with <TT>tcpdump</TT> and verify that the ICMP "port unreachable" error is returned by the server host, but the client's call to <TT>read</TT> never returns. This bug was fixed in Solaris 2.5. UnixWare does not return the error, while AIX, Digital Unix, HP-UX, and Linux all return the error.</P></P></BLOCKQUOTE>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch08lev1sec11.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch08lev1sec13.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
