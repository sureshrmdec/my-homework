<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.16 'udp_server' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch11lev1sec15.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch11lev1sec17.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch11lev1sec16"></A>
<H3 class="docSection1Title">11.16 <TT>udp_server</TT> Function</H3>
<P class="docText">Our final UDP function that provides a simpler interface to <TT>getaddrinfo</TT> is <TT>udp_server</TT>.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include "unp.h"</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int udp_server (const char</TT> *<span class="docEmphasis">hostname</span>, <TT>const char</TT> *<span class="docEmphasis">service</span>, <TT>socklen_t</TT> *<span class="docEmphasis">lenptr</span>);</P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: unconnected socket descriptor if OK, no return on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">The arguments are the same as for <TT>tcp_listen</TT>: an optional <span class="docEmphasis">hostname</span>, a required <span class="docEmphasis">service</span> (so its port number can be bound), and an optional pointer to a variable in which the size of the socket address structure is returned.</P>
<P class="docText"><A class="docLink" HREF="#ch11fig18">Figure 11.18</A> shows the source code.</P>

<H5 class="docExampleTitle"><A NAME="ch11fig18"></A>Figure 11.18 <TT>udp_server</TT> function: creates an unconnected socket for a UDP server.</H5>
<P class="docText"><span class="docEmphasis">lib/udp_server.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 udp_server(const char *host, const char *serv, socklen_t *addrlenp)
 4 {
 5     int     sockfd, n;
 6     struct addrinfo hints, *res, *ressave;

 7     bzero(&amp;hints, sizeof(struct addrinfo));
 8     hints.ai_flags = AI_PASSIVE;
 9     hints.ai_family = AF_UNSPEC;
10     hints.ai_socktype = SOCK_DGRAM;

11     if ( (n = getaddrinfo (host, serv, &amp;hints, &amp;res)) != 0)
12         err_quit ("udp_server error for %s, %s: %s",
13                   host, serv, gai_strerror(n));
14     ressave = res;

15     do {
16         sockfd = socket (res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
17         if (sockfd &lt; 0)
18             continue;          /* error - try next one */

19         if (bind (sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == 0)
20             break;             /* success */

21         Close (sockfd);        /* bind error - close and try next one */
22     } while ( (res = res-&gt;ai_next) != NULL);

23     if (res == NULL)           /* errno from final socket() or bind() */
24         err_sys ("udp_server error for %s, %s", host, serv);

25     if (addrlenp)
26         *addrlenp = res-&gt;ai_addrlen     * return size of protocol address */

27     freeaddrinfo (ressave) ;

28     return (sockfd);
29 }
</PRE>

<P class="docText">This function is nearly identical to <TT>tcp_listen</TT>, but without the call to <TT>listen</TT>. We set the address family to <TT>AF_UNSPEC</TT>, but the caller can use the same technique that we described with <A class="docLink" HREF="0131411551_ch11lev1sec13.html#ch11fig14">Figure 11.14</A> to force a particular protocol (IPv4 or IPv6).</P>
<P class="docText">We do not set the <TT>SO_REUSEADDR</TT> socket option for the UDP socket because this socket option can allow multiple sockets to bind the same UDP port on hosts that support multicasting, as we described in <A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A>. Since there is nothing like TCP's TIME_WAIT state for a UDP socket, there is no need to set this socket option when the server is started.</P>
<A NAME="ch11lev2sec10"></A>
<H4 class="docSection2Title"> Example: Protocol-Independent Daytime Server</H4>
<P class="docText"><A class="docLink" HREF="#ch11fig19">Figure 11.19</A> shows our daytime server, modified from <A class="docLink" HREF="0131411551_ch11lev1sec13.html#ch11fig14">Figure 11.14</A> to use UDP.</P>

<H5 class="docExampleTitle"><A NAME="ch11fig19"></A>Figure 11.19 Protocol-independent UDP daytime server.</H5>
<P class="docText"><span class="docEmphasis">names/daytimeudpsrv2.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     &lt;time.h&gt;

 3 int
 4 main (int argc, char **argv)
 5 {
 6     int     sockfd;
 7     ssize_t n;
 8     char     buff[MAXLINE];
 9     time_t ticks;
10     socklen_t len;
11     struct sockaddr_storage cliaddr;

12     if (argc == 2)
13         sockfd = Udp_server (NULL, argv [1] NULL);
14     else if (argc == 3)
15         sockfd = Udp_server (argv [1], argv [2], NULL);
16     else
17         err_quit ("usage: daytimeudpsrv [ &lt;host&gt; ] &lt;service or port&gt;");

18     for ( ; ; ) {
19         len = sizeof (cliaddr) ;
20         n = Recvfrom (sockfd, buff, MAXLINE, 0, (SA *) &amp;cliaddr, &amp;len);
21         printf ("datagram from %s\n", Sock_ntop ((SA *) &amp;cliaddr, len));

22         ticks = time (NULL) ;
23         snprintf (buff, sizeof (buff), "%.24s\r\n", ctime (&amp;ticks) ) ;
24         Sendto (sockfd, buff, strlen (buff), 0, (SA *) &amp;cliaddr, len) ;
25     }
26 }
</PRE>



<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch11lev1sec15.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch11lev1sec17.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
