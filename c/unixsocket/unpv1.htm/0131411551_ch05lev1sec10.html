<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.10 'wait' and 'waitpid' Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec10"></A>
<H3 class="docSection1Title">5.10 <TT>wait</TT> and <TT>waitpid</TT> Functions</H3>
<P class="docText">In <A class="docLink" HREF="0131411551_ch05lev1sec9.html#ch05fig07">Figure 5.7</A>, we called the <TT>wait</TT> function to handle the terminated child.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/wait.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>pid_t wait</TT> (<TT>int</TT> *<span class="docEmphasis">statloc</span>);</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>pid_t waitpid</TT> (<TT>pid_t</TT> <span class="docEmphasis">pid</span>, <TT>int</TT> *<span class="docEmphasis">statloc</span>, <TT>int</TT> <span class="docEmphasis">options</span>);</P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Both return: process ID if OK, 0 or–1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>wait</TT> and <TT>waitpid</TT> both return two values: the return value of the function is the process ID of the terminated child, and the termination status of the child (an integer) is returned through the <span class="docEmphasis">statloc</span> pointer. There are three macros that we can call that examine the termination status and tell us if the child terminated normally, was killed by a signal, or was just stopped by job control. Additional macros let us then fetch the exit status of the child, or the value of the signal that killed the child, or the value of the job-control signal that stopped the child. We will use the <TT>WIFEXITED</TT> and <TT>WEXITSTATUS</TT> macros in <A class="docLink" HREF="0131411551_ch15lev1sec7.html#ch15fig10">Figure 15.10</A> for this purpose.</P>
<P class="docText">If there are no terminated children for the process calling <TT>wait</TT>, but the process has one or more children that are still executing, then <TT>wait</TT> blocks until the first of the existing children terminates.</P>
<P class="docText"><TT>waitpid</TT> gives us more control over which process to wait for and whether or not to block. First, the <span class="docEmphasis">pid</span> argument lets us specify the process ID that we want to wait for. A value of -1 says to wait for the first of our children to terminate. (There are other options, dealing with process group IDs, but we do not need them in this text.) The <span class="docEmphasis">options</span> argument lets us specify additional options. The most common option is <TT>WNOHANG</TT>. This option tells the kernel not to block if there are no terminated children.</P>
<A NAME="ch05lev2sec5"></A>
<H4 class="docSection2Title"> Difference between <TT>wait</TT> and <TT>waitpid</TT></H4>
<P class="docText">We now illustrate the difference between the <TT>wait</TT> and <TT>waitpid</TT> functions when used to clean up terminated children. To do this, we modify our TCP client as shown in <A class="docLink" HREF="#ch05fig09">Figure 5.9</A>. The client establishes five connections with the server and then uses only the first one (<TT>sockfd[0]</TT>) in the call to <TT>str_cli</TT>. The purpose of establishing multiple connections is to spawn multiple children from the concurrent server, as shown in <A class="docLink" HREF="#ch05fig08">Figure 5.8</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch05fig08"></A>Figure 5.8. Client with five established connections to same concurrent server.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="133" src="FILES/05fig08.gif" ALT="graphics/05fig08.gif"></p>

</CENTER>

<H5 class="docExampleTitle"><A NAME="ch05fig09"></A>Figure 5.9 TCP client that establishes five connections with server.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/tcpcli04.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 main (int argc, char **argv)
 4 {
 5      int     i, sockfd[5];
 6      struct sockaddr_in servaddr;

 7      if (argc != 2)
 8          err_quit ("usage: tcpcli &lt;IPaddress&gt;";

 9      for (i = 0; i &lt; 5; i++) {
10          sockfd[i] = Socket (AF_INET, SOCK_STREAM, 0);

11          bzero (&amp;servaddr, sizeof (servaddr));
12          servaddr.sin_family = AF_INET;
13          servaddr.sin_port = htons (SERV_PORT);
14          Inet_pton (AF_INET, argv[1], &amp;servaddr.sin_addr);

15          Connect (sockfd[i], (SA *) &amp;servaddr, sizeof (servaddr));
16     }

17     str_cli (stdin, sockfd[0]);  /* do it all */

18     exit(0);
19 }
</PRE>

<P class="docText">When the client terminates, all open descriptors are closed automatically by the kernel (we do not call <TT>close</TT>, only <TT>exit</TT>), and all five connections are terminated at about the same time. This causes five FINs to be sent, one on each connection, which in turn causes all five server children to terminate at about the same time. This causes five <TT>SIGCHLD</TT> signals to be delivered to the parent at about the same time, which we show in <A class="docLink" HREF="#ch05fig10">Figure 5.10</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch05fig10"></A>Figure 5.10. Client terminates, closing all five connections, terminating all five children.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="199" src="FILES/05fig10.gif" ALT="graphics/05fig10.gif"></p>

</CENTER>
<P class="docText">It is this delivery of multiple occurrences of the same signal that causes the problem we are about to see.</P>
<P class="docText">We first run the server in the background and then our new client. Our server is <A class="docLink" HREF="0131411551_ch05lev1sec2.html#ch05fig02">Figure 5.2</A>, modified to call <TT>signal</TT> to establish <A class="docLink" HREF="0131411551_ch05lev1sec9.html#ch05fig07">Figure 5.7</A> as a signal handler for <TT>SIGCHLD</TT>.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>linux %</TT> <span class="docEmphStrong"><TT>tcpserv03 &amp;</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>[1] 20419</TT></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>linux %</TT> <span class="docEmphStrong"><TT>tcpcli04 127.0.0.1</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>hello</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we type this</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>hello</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and it is echoed</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>^D</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we then type our EOF character</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>child 20426 terminated</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">output by server</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">The first thing we notice is that only one <TT>printf</TT> is output, when we expect all five children to have terminated. If we execute <TT>ps</TT>, we see that the other four children still exist as zombies.</P>
<pre>

</pre><pre>
        PID TTY          TIME CMD
        20419 pts/6     00:00:00 tcpserv03
        20421 pts/6     00:00:00 tcpserv03 &lt;defunct&gt;
        20422 pts/6     00:00:00 tcpserv03 &lt;defunct&gt;
        20423 pts/6     00:00:00 tcpserv03 &lt;defunct&gt;
</pre><pre>
</pre>
<P class="docText">Establishing a signal handler and calling <TT>wait</TT> from that handler are insufficient for preventing zombies. The problem is that all five signals are generated before the signal handler is executed, and the signal handler is executed only one time because Unix signals are normally not <span class="docEmphasis">queued</span>. Furthermore, this problem is nondeterministic. In the example we just ran, with the client and server on the same host, the signal handler is executed once, leaving four zombies. But if we run the client and server on different hosts, the signal handler is normally executed two times: once as a result of the first signal being generated, and since the other four signals occur while the signal handler is executing, the handler is called only one more time. This leaves three zombies. But sometimes, probably dependent on the timing of the FINs arriving at the server host, the signal handler is executed three or even four times.</P>
<P class="docText">The correct solution is to call <TT>waitpid</TT> instead of <TT>wait</TT>. <A class="docLink" HREF="#ch05fig11">Figure 5.11</A> shows the version of our <TT>sig_chld</TT> function that handles <TT>SIGCHLD</TT> correctly. This version works because we call <TT>waitpid</TT> within a loop, fetching the status of any of our children that have terminated. We must specify the <TT>WNOHANG</TT> option: This tells <TT>waitpid</TT> not to block if there are running children that have not yet terminated. In <A class="docLink" HREF="0131411551_ch05lev1sec9.html#ch05fig07">Figure 5.7</A>, we cannot call <TT>wait</TT> in a loop, because there is no way to prevent <TT>wait</TT> from blocking if there are running children that have not yet terminated.</P>
<P class="docText"><A class="docLink" HREF="#ch05fig12">Figure 5.12</A> shows the final version of our server. It correctly handles a return of <TT>EINTR</TT> from <TT>accept</TT> and it establishes a signal handler (<A class="docLink" HREF="#ch05fig11">Figure 5.11</A>) that calls <TT>waitpid</TT> for all terminated children.</P>

<H5 class="docExampleTitle"><A NAME="ch05fig11"></A>Figure 5.11 Final (correct) version of <TT>sig_chld</TT> function that calls <TT>waitpid</TT>.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/sigchldwaitpid.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 sig_chld(int signo)
 4 {
 5     pid_t    pid;
 6     int      stat;

 7     while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0)
 8         printf("child %d terminated\n", pid);
 9     return;
10 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch05fig12"></A>Figure 5.12 Final (correct) version of TCP server that handles an error of <TT>EINTR</TT> from <TT>accept</TT>.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/tcpserv04.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd;
 6     pid_t   childpid;
 7     socklen_t clilen;
 8     struct sockaddr_in cliaddr, servaddr;
 9     void    sig_chld(int);

10     listenfd = Socket (AF_INET, SOCK_STREAM, 0);

11     bzero (&amp;servaddr, sizeof(servaddr));
12     servaddr.sin_family = AF_INET;
13     servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
14     servaddr.sin_port = htons(SERV_PORT);

15     Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));

16     Listen(listenfd, LISTENQ);

17     Signal (SIGCHLD, sig_chld); /* must call waitpid() */

18     for ( ; ; ) {
19         clilen = sizeof(cliaddr);
20         if ( (connfd = accept (listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) {
21             if (errno == EINTR)
22                 continue;          /* back to for() */
23             else
24                 err_sys("accept error");
25         }

26         if ( (childpid = Fork()) == 0) { /* child process */
27             Close(listenfd);    /* close listening socket */
28             str_echo(connfd);   /* process the request */
29             exit(0);
30         }
31         Close (connfd);         /* parent closes connected socket */
32     }
33 }
</PRE>

<P class="docText">The purpose of this section has been to demonstrate three scenarios that we can encounter with network programming:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">We must catch the <TT>SIGCHLD</TT> signal when <TT>forking</TT> child processes.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">We must handle interrupted system calls when we catch signals.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A <TT>SIGCHLD</TT> handler must be coded correctly using <TT>waitpid</TT> to prevent any zombies from being left around.</P></span></LI></OL></span>
<P class="docText">The final version of our TCP server (<A class="docLink" HREF="#ch05fig12">Figure 5.12</A>), along with the <TT>SIGCHLD</TT> handler in <A class="docLink" HREF="#ch05fig11">Figure 5.11</A>, handles all three scenarios.</P>


<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
