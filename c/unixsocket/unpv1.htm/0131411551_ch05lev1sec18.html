<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.18 Data Format"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec17.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec19.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec18"></A>
<H3 class="docSection1Title">5.18 Data Format</H3>
<P class="docText">In our example, the server never examines the request that it receives from the client. The server just reads all the data up through and including the newline and sends it back to the client, looking for only the newline. This is an exception, not the rule, and normally we must worry about the format of the data exchanged between the client and server.</P>
<A NAME="ch05lev2sec6"></A>
<H4 class="docSection2Title"> Example: Passing Text Strings between Client and Server</H4>
<P class="docText">Let's modify our server so that it still reads a line of text from the client, but the server now expects that line to contain two integers separated by white space, and the server returns the sum of those two integers. Our client and server <TT>main</TT> functions remain the same, as does our <TT>str_cli</TT> function. All that changes is our <TT>str_echo</TT> function, which we show in <A class="docLink" HREF="#ch05fig17">Figure 5.17</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch05fig17"></A>Figure 5.17 <TT>str_echo</TT> function that adds two numbers.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/str_ech08.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 void
 3 str_echo(int sockfd)
 4 {
 5     long     arg1,     arg2;
 6     ssize_t n;
 7     char    line[MAXLINE];

 8     for ( ; ; ) {
 9         if ( (n = Readline(sockfd, line, MAXLINE)) == 0)
10             return;             /* connection closed by other end */

11         if (sscanf(line, "%ld%ld", &amp;arg1, &amp;arg2) == 2)
12             snprintf(line, sizeof(line), "%ld\n", arg1 + arg2);
13         else
14             snprintf(line, sizeof(line), "input error\n");

15         n = strlen(line);
16         Writen(sockfd, line, n);
17     }
18 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>11–14</TT></span> We call <TT>sscanf</TT> to convert the two arguments from text strings to long integers, and then <TT>snprintf</TT> is called to convert the result into a text string.</p>
<P class="docText">This new client and server work fine, regardless of the byte ordering of the client and server hosts.</P>

<A NAME="ch05lev2sec7"></A>
<H4 class="docSection2Title"> Example: Passing Binary Structures between Client and Server</H4>
<P class="docText">We now modify our client and server to pass binary values across the socket, instead of text strings. We will see that this does not work when the client and server are run on hosts with different byte orders, or on hosts that do not agree on the size of a long integer (<A class="docLink" HREF="0131411551_ch01lev1sec11.html#ch01fig17">Figure 1.17</A>).</P>
<P class="docText">Our client and server <TT>main</TT> functions do not change. We define one structure for the two arguments, another structure for the result, and place both definitions in our <TT>sum.h</TT> header, shown in <A class="docLink" HREF="#ch05fig18">Figure 5.18</A>. <A class="docLink" HREF="#ch05fig19">Figure 5.19</A> shows the <TT>str_cli</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch05fig18"></A>Figure 5.18 <TT>sum.h</TT> header.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/sum.h</span></P>

<PRE>
1 struct args {
2     long    arg1;
3     long    arg2;
4 };

5 struct result {
6     long    sum;
7 };
</PRE>


<H5 class="docExampleTitle"><A NAME="ch05fig19"></A>Figure 5.19 <TT>str_cli</TT> function which sends two binary integers to server.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/str_cli09.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     "sum.h"

 3 void
 4 str_cli(FILE *fp, int sockfd)
 5 {
 6     char     sendline[MAXLINE];
 7     struct args args;
 8     struct result result;

 9     while  (Fgets(sendline, MAXLINE, fp) != NULL) {

10         if  (sscanf(sendline, "%ld%ld", &amp;args.arg1, &amp;args.arg2) != 2) {
11             printf("invalid input: %s", sendline);
12             continue;
13        }
14        Writen(sockfd, &amp;args, sizeof(args));

15        if (Readn(sockfd, &amp;result, sizeof(result)) == 0)
16            err_quit("str_cli: server terminated prematurely");

17        printf("%ld\n", result.sum);
18     }
19 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>10–14</TT></span> <TT>sscanf</TT> converts the two arguments from text strings to binary, and we call <TT>writen</TT> to send the structure to the server.</p>
<p class="docText"><span class="docEmphasis"><TT>15–17</TT></span> We call <TT>readn</TT> to read the reply, and print the result using <TT>printf</TT>.</p>
<P class="docText"><A class="docLink" HREF="#ch05fig20">Figure 5.20</A> shows our <TT>str_echo</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch05fig20"></A>Figure 5.20 <TT>str_echo</TT> function that adds two binary integers.</H5>
<P class="docText"><span class="docEmphasis">tcpcliserv/str_ech09.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     "sum.h"

 3 void
 4 str_echo(int sockfd)
 5 {
 6     ssize_t n;
 7     struct args args;
 8     struct result result;

 9     for ( ; ; ) {
10         if ( (n = Readn(sockfd, &amp;args, sizeof(args))) == 0)
11             return;             /* connection closed by other end */

12         result.sum = args.arg1 + args.arg2;
13         Writen(sockfd, &amp;result, sizeof (result));
14     }
15 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>9–14</TT></span> We read the arguments by calling <TT>readn</TT>, calculate and store the sum, and call <TT>writen</TT> to send back the result structure.</p>
<P class="docText">If we run the client and server on two machines of the same architecture, say two SPARC machines, everything works fine. Here is the client interaction:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>solaris %</TT> <span class="docEmphStrong"><TT>:tcpcli09 12.106.32.254</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>11 22</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we type this</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>33</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">this is the server's reply</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>-11 -44</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>-55</TT></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">But when the client and server are on two machines of different architectures (say the server is on the big-endian SPARC system <TT>freebsd</TT> and the client is on the little endian Intel system <TT>linux</TT>), it does not work.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top" colspan="2"><P class="docText"><TT>linux %</TT> <span class="docEmphStrong"><TT>tcpcli09 206.168.112.96</TT></span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>1 2</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we type this</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>3</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and it works</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>-22 -77</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">then we type this</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>-16777314</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and it does not work</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">The problem is that the two binary integers are sent across the socket in little-endian format by the client, but interpreted as big-endian integers by the server. We see that it appears to work for positive integers but fails for negative integers (see <A class="docLink" HREF="0131411551_ch05lev1sec20.html#ch05lev1sec20">Exercise 5.8</A>). There are really three potential problems with this example:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Different implementations store binary numbers in different formats. The most common formats are big-endian and little-endian, as we described in <A class="docLink" HREF="0131411551_ch03lev1sec4.html#ch03lev1sec4">Section 3.4</A>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Different implementations can store the same C datatype differently. For example, most 32-bit Unix systems use 32 bits for a <TT>long</TT> but 64-bit systems typically use 64 bits for the same datatype (<A class="docLink" HREF="0131411551_ch01lev1sec11.html#ch01fig17">Figure 1.17</A>). There is no guarantee that a <TT>short</TT>, <TT>int</TT>, or <TT>long</TT> is of any certain size.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Different implementations pack structures differently, depending on the number of bits used for the various datatypes and the alignment restrictions of the machine. Therefore, it is never wise to send binary structures across a socket.</P></span></LI></OL></span>
<P class="docText">There are two common solutions to this data format problem:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Pass all numeric data as text strings. This is what we did in <A class="docLink" HREF="#ch05fig17">Figure 5.17</A>. This assumes that both hosts have the same character set.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Explicitly define the binary formats of the supported datatypes (number of bits, big- or little-endian) and pass all data between the client and server in this format. RPC packages normally use this technique. RFC 1832 [Srinivasan 1995] describes the <span class="docEmphasis">External Data Representation</span> (XDR) standard that is used with the Sun RPC package.</P></span></LI></OL></span>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec17.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec19.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
