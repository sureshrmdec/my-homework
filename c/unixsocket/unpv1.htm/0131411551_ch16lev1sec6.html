<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="16.6 Nonblocking 'accept'"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch16lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch16lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch16lev1sec6"></A>
<H3 class="docSection1Title">16.6 Nonblocking <TT>accept</TT></H3>
<P class="docText">We stated in <A class="docLink" HREF="0131411551_ch06.html#ch06">Chapter 6</A> that a listening socket is returned as readable by <TT>select</TT> when a completed connection is ready to be <TT>accepted</TT>. Therefore, if we are using <TT>select</TT> to wait for incoming connections, we should not need to set the listening socket to nonblocking because if <TT>select</TT> tells us that the connection is ready, <TT>accept</TT> should not block.</P>
<P class="docText">Unfortunately, there is a timing problem that can trip us up here [Gierth 1996]. To see this problem, we modify our TCP echo client (<A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig04">Figure 5.4</A>) to establish the connection and then send an RST to the server. <A class="docLink" HREF="#ch16fig21">Figure 16.21</A> shows this new version.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig21"></A>Figure 16.21 TCP echo client that creates connection and sends an RST.</H5>
<P class="docText"><span class="docEmphasis">nonblock/tcpcli03.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;
 6     struct linger ling;
 7     struct sockaddr_in servaddr;

 8     if (argc != 2)
 9         err_quit("usage: tcpcli &lt;IPaddress&gt;");

10     sockfd = Socket(AF_INET, SOCK_STREAM, 0);

11     bzero(&amp;servaddr, sizeof(servaddr));
12     servaddr.sin_family = AF_INET;
13     servaddr.sin_port = htons(SERV_PORT);
14     Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr);

15     Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));

16     ling.l_onoff = 1;          /* cause RST to be sent on close() */
17     ling.l_linger = 0;
18     Setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &amp;ling, sizeof(ling));
19     Close(sockfd);

20     exit(0);
21 }
</PRE>

<A NAME="ch16lev3sec37"></A>
<H4 class="docSection2Title"> Set SO_LINGER socket option</H4>
<p class="docText"><span class="docEmphasis"><TT>16–19</TT></span> Once the connection is established, we set the <TT>SO_LINGER</TT> socket option, setting the <TT>l_onoff</TT> flag to 1 and the <TT>l_linger</TT> time to 0. As stated in <A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A>, this causes an RST to be sent on a TCP socket when the connection is closed. We then <TT>close</TT> the socket.</p>
<P class="docText">Next, we modify our TCP server from <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig21">Figures 6.21</A> and <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig22">6.22</A> to pause after <TT>select</TT> returns that the listening socket is readable, but before calling <TT>accept</TT>. In the following code from the beginning of <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig22">Figure 6.22</A>, the two lines preceded by a plus sign are new:</P>
<pre>

</pre><pre>
     if (FD_ISSET(listenfd, &amp;rset)) {    /* new client connection */
+        printf("listening socket readable\n");
+        sleep(5);
         clilen = sizeof(cliaddr);
         connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);
</pre><pre>
</pre>
<P class="docText">What we are simulating here is a busy server that cannot call <TT>accept</TT> as soon as <TT>select</TT> returns that the listening socket is readable. Normally, this slowness on the part of the server is not a problem (indeed, this is why a queue of completed connections is maintained), but when combined with the RST from the client, after the connection is established, we can have a problem.</P>
<P class="docText">In <A class="docLink" HREF="0131411551_ch05lev1sec11.html#ch05lev1sec11">Section 5.11</A>, we noted that when the client aborts the connection before the server calls <TT>accept</TT>, Berkeley-derived implementations do not return the aborted connection to the server, while other implementations should return <TT>ECONNABORTED</TT> but often return <TT>EPROTO</TT> instead. Consider the following example of a Berkeley-derived implementation:</P>
<UL><LI><P class="docList">The client establishes the connection and then aborts it as in <A class="docLink" HREF="#ch16fig21">Figure 16.21</A>.</P></LI><LI><P class="docList"><TT>select</TT> returns readable to the server process, but it takes the server a short time to call <TT>accept</TT>.</P></LI><LI><P class="docList">Between the server's return from <TT>select</TT> and its calling <TT>accept</TT>, the RST is received from the client.</P></LI><LI><P class="docList">The completed connection is removed from the queue and we assume that no other completed connections exist.</P></LI><LI><P class="docList">The server calls <TT>accept</TT>, but since there are no completed connections, it blocks.</P></LI></UL>
<P class="docText">The server will remain blocked in the call to <TT>accept</TT> until some other client establishes a connection. But in the meantime, assuming a server like <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06fig22">Figure 6.22</A>, the server is blocked in the call to <TT>accept</TT> and will not handle any other ready descriptors.</P>
<BLOCKQUOTE><P><P class="docList">This problem is somewhat similar to the denial-of-service attack described in <A class="docLink" HREF="0131411551_ch06lev1sec8.html#ch06lev1sec8">Section 6.8</A>, but with this new bug, the server breaks out of the blocked <TT>accept</TT> as soon as another client establishes a connection.</P></P></BLOCKQUOTE>
<P class="docText">The fix for this problem is as follows:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Always set a listening socket to nonblocking when you use <TT>select</TT> to indicate when a connection is ready to be <TT>accepted</TT>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Ignore the following errors on the subsequent call to <TT>accept</TT>: <TT>EWOULDBLOCK</TT> (for Berkeley-derived implementations, when the client aborts the connection), <TT>ECONNABORTED</TT> (for POSIX implementations, when the client aborts the connection), <TT>EPROTO</TT> (for SVR4 implementations, when the client aborts the connection), and <TT>EINTR</TT> (if signals are being caught).</P></span></LI></OL></span>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch16lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch16lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
