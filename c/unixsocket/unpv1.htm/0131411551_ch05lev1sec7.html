<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.7 Normal Termination"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch05lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch05lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec7"></A>
<H3 class="docSection1Title">5.7 Normal Termination</H3>
<P class="docText">At this point, the connection is established and whatever we type to the client is echoed back.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>linux %</TT> <span class="docEmphStrong"><TT>tcpcli01 127.0.0.1</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we showed this line earlier</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>hello, world</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">we now type this</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>hello</TT>, <TT>world</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">and the line is echoed</span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>good bye</TT></span></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>good bye</TT></P></TD><TD class="docTableCell" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>^D</TT></span></P></TD><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphasis">Control-D is our terminal EOF character</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">We type in two lines, each one is echoed, and then we type our terminal EOF character (Control-D), which terminates the client. If we immediately execute <TT>netstat</TT>, we have</P>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">netstat -a</span> | <span class="docEmphStrong">grep 9877</span>
tcp        0      0 *:9877               *:*               LISTEN
tcp        0      0 localhost:42758      localhost:9877    TIME_WAIT
</pre><pre>
</pre>
<P class="docText">The client's side of the connection (since the local port is 42758) enters the TIME_WAIT state (<A class="docLink" HREF="0131411551_ch02lev1sec7.html#ch02lev1sec7">Section 2.7</A>), and the listening server is still waiting for another client connection. (This time we pipe the output of <TT>netstat</TT> into <TT>grep</TT>, printing only the lines with our server's well-known port. Doing this also removes the heading line.)</P>
<P class="docText">We can follow through the steps involved in the normal termination of our client and server:</P>
<A NAME="ch05pro03"></A>







<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">When we type our EOF character, <TT>fgets</TT> returns a null pointer and the function <TT>str_cli</TT> (<A class="docLink" HREF="0131411551_ch05lev1sec5.html#ch05fig05">Figure 5.5</A>) returns.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">When <TT>str_cli</TT> returns to the client <TT>main</TT> function (<A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig04">Figure 5.4</A>), the latter terminates by calling <TT>exit</TT>.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">Part of process termination is the closing of all open descriptors, so the client socket is closed by the kernel. This sends a FIN to the server, to which the server TCP responds with an ACK. This is the first half of the TCP connection termination sequence. At this point, the server socket is in the CLOSE_WAIT state and the client socket is in the FIN_WAIT_2 state (<A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig04">Figures 2.4</A> and <A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig05">2.5</A>).</P>
</span></LI><LI><span style="font-weight:normal" value="4"><P class="docText">When the server TCP receives the FIN, the server child is blocked in a call to <TT>readline</TT> (<A class="docLink" HREF="0131411551_ch05lev1sec4.html#ch05fig03">Figure 5.3</A>), and <TT>readline</TT> then returns 0. This causes the <TT>str_echo</TT> function to return to the server child <TT>main</TT>.</P>
</span></LI><LI><span style="font-weight:normal" value="5"><P class="docText">The server child terminates by calling <TT>exit</TT> (<A class="docLink" HREF="0131411551_ch05lev1sec2.html#ch05fig02">Figure 5.2</A>).</P>
</span></LI><LI><span style="font-weight:normal" value="6"><P class="docText">All open descriptors in the server child are closed. The closing of the connected socket by the child causes the final two segments of the TCP connection termination to take place: a FIN from the server to the client, and an ACK from the client (<A class="docLink" HREF="0131411551_ch02lev1sec6.html#ch02fig05">Figure 2.5</A>). At this point, the connection is completely terminated. The client socket enters the TIME_WAIT state.</P>
</span></LI><LI><span style="font-weight:normal" value="7"><P class="docText">Finally, the <TT>SIGCHLD</TT> signal is sent to the parent when the server child terminates. This occurs in this example, but we do not catch the signal in our code, and the default action of the signal is to be ignored. Thus, the child enters the zombie state. We can verify this with the <TT>ps</TT> command.</P>
</span></LI></OL></span>
<pre>

</pre><pre>
linux % <span class="docEmphStrong">ps -t pts/6 -o pid,ppid,tty,stat,args,wchan</span>
  PID  PPID TT       STAT COMMAND          WCHAN
22038 22036 pts/6    S    -bash            read_chan
17870 22038 pts/6    S    ./tcpserv01      wait_for_connect
19315 17870 pts/6    Z    [tcpserv01 &lt;defu do_exit
</pre><pre>
</pre>
<P class="docText">The STAT of the child is now <TT>Z</TT> (for zombie).</P>
<P class="docText">We need to clean up our zombie processes and doing this requires dealing with Unix signals. In the next section, we will give an overview of signal handling.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch05lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch05lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
