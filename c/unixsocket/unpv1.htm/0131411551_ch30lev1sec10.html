<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="30.10 TCP Concurrent Server, One Thread per Client"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch30lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch30lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch30lev1sec10"></A>
<H3 class="docSection1Title">30.10 TCP Concurrent Server, One Thread per Client</H3>
<P class="docText">The last five sections have focused on one process per client, both one <TT>fork</TT> per client and preforking some number of children. If the server supports threads, we can use threads instead of child processes.</P>
<P class="docText">Our first threaded version is shown in <A class="docLink" HREF="#ch30fig26">Figure 30.26</A>. It is a modification of <A class="docLink" HREF="0131411551_ch30lev1sec5.html#ch30fig04">Figure 30.4</A> that creates one thread per client, instead of one process per client. This version is very similar to <A class="docLink" HREF="0131411551_ch26lev1sec4.html#ch26fig03">Figure 26.3</A>.</P>
<A NAME="ch30lev3sec6"></A>
<H4 class="docSection2Title"> Main thread loop</H4>
<p class="docText"><span class="docEmphasis"><TT>19–23</TT></span> The main thread blocks in a call to <TT>accept</TT> and each time a client connection is returned, a new thread is created by <TT>pthread_create</TT>. The function executed by the new thread is <TT>doit</TT> and its argument is the connected socket.</p>

<A NAME="ch30lev3sec7"></A>
<H4 class="docSection2Title"> Per-thread function</H4>
<p class="docText"><span class="docEmphasis"><TT>25–33</TT></span> The <TT>doit</TT> function detaches itself so the main thread does not have to wait for it and calls our <TT>web_client</TT> function (<A class="docLink" HREF="0131411551_ch30lev1sec3.html#ch30fig03">Figure 30.3</A>). When that function returns, the connected socket is closed.</p>

<H5 class="docExampleTitle"><A NAME="ch30fig26"></A>Figure 30.26 <TT>main</TT> function for TCP threaded server.</H5>
<P class="docText"><span class="docEmphasis">server/serv06.c</span></P>

<PRE>
 1 #include    "unpthread.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd;
 6     void    sig_int(int);
 7     void   *doit(void *);
 8     pthread_t tid;
 9     socklen_t clilen, addrlen;
10     struct sockaddr *cliaddr;

11     if (argc == 2)
12         listenfd = Tcp_listen(NULL, argv[1], &amp;addrlen);
13     else if (argc == 3)
14         listenfd = Tcp_listen(argv[1], argv[2], &amp;addrlen);
15     else
16         err_quit("usage: serv06 [ &lt;host&gt; ] &lt;port#&gt;");
17     cliaddr = Malloc(addrlen);

18     Signal(SIGINT, sig_int);

19     for ( ; ; ) {
20         clilen = addrlen;
21         connfd = Accept(listenfd, cliaddr, &amp;clilen);

22         Pthread_create(&amp;tid, NULL, &amp;doit, (void *) connfd);
23     }
24 }

25 void *
26 doit(void *arg)
27 {
28     void    web_child(int);

29     Pthread_detach(pthread_self());
30     web_child((int) arg);
31     Close((int) arg);
32     return (NULL);
33 }
</PRE>

<P class="docText">We note from <A class="docLink" HREF="0131411551_ch30lev1sec1.html#ch30fig01">Figure 30.1</A> that this simple threaded version is faster than even the fastest of the preforked versions. This one-thread-per-client version is also many times faster than the one-child-per-client version (row 1).</P>
<BLOCKQUOTE><P><P class="docList">In <A class="docLink" HREF="0131411551_ch26lev1sec5.html#ch26lev1sec5">Section 26.5</A> we noted three alternatives for converting a function that is not thread-safe into one that is thread-safe. Our <TT>web_child</TT> function calls our <TT>readline</TT> function, and the version shown in <A class="docLink" HREF="0131411551_ch03lev1sec9.html#ch03fig18">Figure 3.18</A> is not thread-safe. Alternatives 2 and 3 from <A class="docLink" HREF="0131411551_ch26lev1sec5.html#ch26lev1sec5">Section 26.5</A> were timed with the example in <A class="docLink" HREF="#ch30fig26">Figure 30.26</A>. The speedup from alternative 3 to alternative 2 was less than one percent, probably because <TT>readline</TT> is used only to read the five-character count from the client. Therefore, for simplicity we use the less efficient version from <A class="docLink" HREF="0131411551_ch03lev1sec9.html#ch03fig17">Figure 3.17</A> for the threaded server examples in this chapter.</P></P></BLOCKQUOTE>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch30lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch30lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
