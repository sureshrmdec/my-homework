<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.6 Unix Domain Datagram Client/Server"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch15lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch15lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec6"></A>
<H3 class="docSection1Title">15.6 Unix Domain Datagram Client/Server</H3>
<P class="docText">We now recode our UDP client/server from <A class="docLink" HREF="0131411551_ch08lev1sec3.html#ch08lev1sec3">Sections 8.3</A> and <A class="docLink" HREF="0131411551_ch08lev1sec5.html#ch08lev1sec5">8.5</A> to use Unix domain datagram sockets. <A class="docLink" HREF="#ch15fig05">Figure 15.5</A> shows the server, which is a modification of <A class="docLink" HREF="0131411551_ch08lev1sec3.html#ch08fig03">Figure 8.3</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig04"></A>Figure 15.4 Unix domain stream protocol echo client.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/unixstrcli01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;
 6     struct sockaddr_un servaddr;

 7     sockfd = Socket(AF_LOCAL, SOCK_STREAM, 0);

 8     bzero(&amp;servaddr, sizeof(servaddr));
 9     servaddr.sun_family = AF_LOCAL;
10     strcpy(servaddr.sun_path, UNIXSTR_PATH);

11     Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));

12     str_cli(stdin, sockfd);     /* do it all */

13     exit(0);
14 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch15fig05"></A>Figure 15.5 Unix domain datagram protocol echo server.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/unixdgserv01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;
 6     struct sockaddr_un servaddr, cliaddr;

 7     sockfd = Socket(AF_LOCAL, SOCK_DGRAM, 0);

 8     unlink(UNIXDG_PATH);
 9     bzero(&amp;servaddr, sizeof(servaddr));
10     servaddr.sun_family = AF_LOCAL;
11     strcpy(servaddr.sun_path, UNIXDG_PATH);

12     Bind(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));

13     dg_echo(sockfd, (SA *) &amp;cliaddr, sizeof(cliaddr));
14 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>6</TT></span> The datatype of the two socket address structures is now <TT>sockaddr_un</TT>.</p>
<p class="docText"><span class="docEmphasis"><TT>7</TT></span> The first argument to <TT>socket</TT> is <TT>AF_LOCAL</TT>, to create a Unix domain datagram socket.</p>
<p class="docText"><span class="docEmphasis"><TT>8–12</TT></span> The constant <TT>UNIXDG_PATH</TT> is defined in <TT>unp.h</TT> to be <TT>/tmp/unix.dg</TT>. We first <TT>unlink</TT> the pathname, in case it exists from an earlier run of the server, and then initialize the socket address structure before calling <TT>bind</TT>. An error from <TT>unlink</TT> is acceptable.</p>
<p class="docText"><span class="docEmphasis"><TT>13</TT></span> The same <TT>dg_echo</TT> function is used (<A class="docLink" HREF="0131411551_ch08lev1sec4.html#ch08fig04">Figure 8.4</A>).</p>
<P class="docText"><A class="docLink" HREF="#ch15fig06">Figure 15.6</A> is the Unix domain datagram protocol echo client. It is a modification of <A class="docLink" HREF="0131411551_ch08lev1sec5.html#ch08fig07">Figure 8.7</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig06"></A>Figure 15.6 Unix domain datagram protocol echo client.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/unixdgcli01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;
 6     struct sockaddr_un cliaddr, servaddr;

 7     sockfd = Socket(AF_LOCAL, SOCK_DGRAM, 0);

 8     bzero(&amp;cliaddr, sizeof(cliaddr));   /* bind an address for us */
 9     cliaddr.sun_family = AF_LOCAL;
10     strcpy(cliaddr.sun_path, tmpnam(NULL));

11     Bind(sockfd, (SA *) &amp;cliaddr, sizeof(cliaddr));

12     bzero(&amp;servaddr, sizeof(servaddr)); /* fill in server's address */
13     servaddr.sun_family = AF_LOCAL;
14     strcpy(servaddr.sun_path, UNIXDG_PATH);

15     dg_cli(stdin, sockfd, (SA *) &amp;servaddr, sizeof(servaddr));

16     exit(0);
17 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>6</TT></span> The socket address structure to contain the server's address is now a <TT>sockaddr_un</TT> structure. We also allocate one of these structures to contain the client's address, which we will talk about shortly.</p>
<p class="docText"><span class="docEmphasis"><TT>7</TT></span> The first argument to <TT>socket</TT> is <TT>AF_LOCAL</TT>.</p>
<p class="docText"><span class="docEmphasis"><TT>8–11</TT></span> Unlike our UDP client, when using the Unix domain datagram protocol, we must explicitly <TT>bind</TT> a pathname to our socket so that the server has a pathname to which it can send its reply. We call <TT>tmpnam</TT> to assign a unique pathname that we then <TT>bind</TT> to our socket. Recall from <A class="docLink" HREF="0131411551_ch15lev1sec4.html#ch15lev1sec4">Section 15.4</A> that sending a datagram on an unbound Unix domain datagram socket does not implicitly bind a pathname to the socket. Therefore, if we omit this step, the server's call to <TT>recvfrom</TT> in the <TT>dg_echo</TT> function returns a null pathname, which then causes an error when the server calls <TT>sendto</TT>.</p>
<p class="docText"><span class="docEmphasis"><TT>12–14</TT></span> The code to fill in the socket address structure with the server's well-known pathname is identical to the code shown earlier for the server.</p>
<p class="docText"><span class="docEmphasis"><TT>15</TT></span> The function <TT>dg_cli</TT> is the same as that shown in <A class="docLink" HREF="0131411551_ch08lev1sec6.html#ch08fig08">Figure 8.8</A>.</p>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch15lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch15lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
