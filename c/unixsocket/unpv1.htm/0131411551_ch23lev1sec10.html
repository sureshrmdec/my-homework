<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="23.10 Peeling Off an Association"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch23lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch23lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch23lev1sec10"></A>
<H3 class="docSection1Title">23.10 Peeling Off an Association</H3>
<P class="docText">We have been focusing on the one-to-many-style interface provided by SCTP. This interface has several advantages over the more classic one-to-one style:</P>
<UL><LI><P class="docList">There is only one file descriptor to maintain.</P></LI><LI><P class="docList">It allows us to write a simple iterative server.</P></LI><LI><P class="docList">It lets an application send data on the third and fourth packet of the four-way handshake by using <TT>sendmsg</TT> or <TT>sctp_sendmsg</TT> to implicitly establish the connection.</P></LI><LI><P class="docList">There is no need to track transport state. In other words, the application just does a receive call on the socket descriptor and does not need to do any of the traditional <TT>connect</TT> or <TT>accept</TT> function calls before receiving messages.</P></LI></UL>
<P class="docText">However, there is one major drawback to this style. It makes it difficult to build a concurrent server (either using threads or by forking children). This drawback has brought about the addition of the <TT>sctp_peeloff</TT> function. <TT>sctp_peeloff</TT> takes a one-to-many socket descriptor and an association ID and returns a new socket descriptor with just that association (plus any queued notifications and data on that association) attached in a one-to-one style. The original socket remains open, and any other associations represented by the one-to-many socket are left unaffected.</P>
<P class="docText">This socket can then be handed off to either a thread or a child process to execute a concurrent server. <A class="docLink" HREF="#ch23fig15">Figure 23.15</A> illustrates a further modification to our server that processes the first message of a client, extracts the client socket descriptor using <TT>sctp_peeloff</TT>, forks a child, and calls our original TCP <TT>str_echo</TT> function introduced in <A class="docLink" HREF="0131411551_ch05lev1sec3.html#ch05lev1sec3">Section 5.3</A>. We use the address of the received message to call our function that gets us the association ID (<A class="docLink" HREF="0131411551_ch23lev1sec8.html#ch23lev1sec8">Section 23.8</A>). The association ID is also available in <TT>sri.sinfo_assoc_id;</TT> we show this method of determining the association ID from the IP address to illustrate another method. After forking the child, our server loops back to process the next message.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig15"></A>Figure 23.15 A concurrent SCTP server.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctpserv_fork.c</span></P>

<PRE>
23     for ( ; ; ) {
24         len = sizeof(struct sockaddr_in);
25         rd_sz = Sctp_recvmsg(sock_fd, readbuf, sizeof(readbuf),
26                              (SA *) &amp;cliaddr, &amp;len, &amp;sri, &amp;msg_flags);
27         Sctp_sendmsg(sock_fd, readbuf, rd_sz,
28                      (SA *) &amp;cliaddr, len,
29                      sri.sinfo_ppid,
30                      sri.sinfo_flags, sri.sinfo_stream, 0, 0);
31         assoc = sctp_address_to_associd(sock_fd, (SA *) &amp;cliaddr, len);
32         if ((int) assoc == 0) {
33             err_ret("Can't get association id");
34             continue;
35         }
36         connfd = sctp_peeloff(sock_fd, assoc);
37         if (connfd == -1) {
38             err_ret("sctp_peeloff fails");
39             continue;
40         }
41         if ( (childpid = fork()) == 0) {
42             Close(sock_fd);
43             str_echo(connfd);
44             exit(0);
45         } else {
46             Close(connfd);
47         }
48   }
</PRE>

<A NAME="ch23lev3sec48"></A>
<H4 class="docSection2Title"> Receive and process first message from client</H4>
<p class="docText"><span class="docEmphasis"><TT>26–30</TT></span> The server receives and processes the first message a client sends.</p>

<A NAME="ch23lev3sec49"></A>
<H4 class="docSection2Title"> Translate address to association ID</H4>
<p class="docText"><span class="docEmphasis"><TT>31–35</TT></span> The server next uses our function from <A class="docLink" HREF="0131411551_ch23lev1sec8.html#ch23fig13">Figure 23.13</A> to translate the address to an association ID. If for some reason the server cannot get an association ID, it skips this attempt to fork a child and instead will try with the next message.</p>

<A NAME="ch23lev3sec50"></A>
<H4 class="docSection2Title"> Extract association</H4>
<p class="docText"><span class="docEmphasis"><TT>36–40</TT></span> The server extracts the association into its own socket descriptor with <TT>sctp_peeloff</TT>. This results in a one-to-one socket that can be passed to our earlier TCP version of <TT>str_echo</TT>.</p>

<A NAME="ch23lev3sec51"></A>
<H4 class="docSection2Title"> Delegate work to child</H4>
<p class="docText"><span class="docEmphasis"><TT>41–47</TT></span> The server forks a child and lets the child perform all future work on this new socket descriptor.</p>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch23lev1sec9.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch23lev1sec11.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
