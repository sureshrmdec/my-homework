<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="14.9 Advanced Polling"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch14lev1sec8.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch14lev1sec10.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch14lev1sec9"></A>
<H3 class="docSection1Title" id="162666-823">14.9 Advanced Polling</H3>
<P class="docText">Earlier in this chapter, we discussed several ways to set a time limit on a socket operation. Many operating systems now offer another alternative, and provide the features of <TT>select</TT> and <TT>poll</TT> we described in <A class="docLink" HREF="0131411551_ch06.html#ch06">Chapter 6</A> as well. Since none of these methods have been adopted by POSIX yet, and each implementation seems to be slightly different, code that uses these mechanisms should be considered nonportable. We'll describe two mechanisms here; other available mechanisms are similar.</P>
<A NAME="ch14lev2sec6"></A>
<H4 class="docSection2Title"> <TT>/dev/poll</TT> Interface</H4>
<P class="docText">Solaris provides a special file called <TT>/dev/poll</TT>, which provides a more scalable way to poll large numbers of file descriptors. The problem with <TT>select</TT> and <TT>poll</TT> is that the file descriptors of interest must be passed in with each call. The poll device maintains state between calls so that a program can set up the list of descriptors to poll and then loop, waiting for events, without setting up the list again each time around the loop.</P>
<P class="docText">After opening <TT>/dev/poll</TT>, the polling program must initialize an array of <TT>pollfd</TT> structures (the same structure used by the <TT>poll</TT> function, but the <TT>revents</TT> field is unused in this case). The array is then passed to the kernel by calling <TT>write</TT> to write the structured directly to the <TT>/dev/poll</TT> device. The program then uses an <TT>ioctl</TT> call, <TT>DO_POLL</TT>, to block, waiting for events. The following structure is passed into the <TT>ioctl</TT> call:</P>
<pre>

</pre><pre>
struct dvpoll {
    struct pollfd* dp_fds;
    int            dp_nfds;
    int            dp_timeout;
}
</pre><pre>
</pre>
<P class="docText">The field <TT>dp_fds</TT> points to a buffer that is used to hold an array of <TT>pollfd</TT> structures returned from the <TT>ioctl</TT> call. The field <TT>dp_nfds</TT> field specifies the size of the buffer. The <TT>ioctl</TT> call blocks until there are interesting events on any of the polled file descriptors, or until <TT>dp_timeout</TT> milliseconds have passed. Using a value of zero for <TT>dp_timeout</TT> will cause the <TT>ioctl</TT> to return immediately, which provides a nonblocking way to use this interface. Passing in <TT>-1</TT> for the timeout indicates that no timeout is desired.</P>
<P class="docText">We modify our <TT>str_cli</TT> function, which used <TT>select</TT> in <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>, to use <TT>/dev/poll</TT> in <A class="docLink" HREF="#ch14fig15">Figure 14.15</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch14fig15"></A>Figure 14.15 <TT>str_cli</TT> function using <TT>/dev/poll</TT>.</H5>
<P class="docText"><span class="docEmphasis">advio/str_cli_poll03.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 #include    &lt;sys/devpoll.h&gt;

 3 void
 4 str_cli(FILE *fp, int sockfd)
 5 {
 6     int     stdineof;
 7     char    buf[MAXLINE];
 8     int     n;
 9     int     wfd;
10     struct pollfd pollfd[2];
11     struct dvpoll dopoll;
12     int     i;
13     int     result;

14     wfd = Open("/dev/poll", O_RDWR, 0);

15     pollfd[0].fd = fileno(fp);
16     pollfd[0].events = POLLIN;
17     pollfd[0].revents = 0;

18     pollfd[1].fd = sockfd;
19     pollfd[1].events = POLLIN;
20     pollfd[1].revents = 0;

21     Write(wfd, pollfd, sizeof(struct pollfd) * 2);

22     stdineof = 0;
23     for ( ; ; ) {
24         /* block until /dev/poll says something is ready */
25         dopoll.dp_timeout = -1;
26         dopoll.dp_nfds = 2;
27         dopoll.dp_fds = pollfd;
28         result = Ioctl(wfd, DP_POLL, &amp;dopoll);

29         /* loop through ready file descriptors */
30         for (i = 0; i &lt; result; i++) {
31             if (dopoll.dp_fds[i].fd == sockfd) {
32                 /* socket is readable */
33                 if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {
34                     if (stdineof == 1)
35                         return; /* normal termination */
36                     else
37                         err_quit("str_cli: server terminated prematurely");
38                 }

39                 Write(fileno(stdout), buf, n);
40             } else {
41                 /* input is readable */
42                 if ( (n = Read(fileno(fp), buf, MAXLINE)) == 0) {
43                     stdineof = 1;
44                     Shutdown(sockfd, SHUT_WR); /* send FIN */
45                     continue;
46                 }

47                 Writen(sockfd, buf, n);
48             }
49         }
50     }
51 }
</PRE>

<A NAME="ch14lev3sec13"></A>
<H5 class="docSection3Title"> List descriptors for <TT>/dev/poll</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>14–21</TT></span> After filling in an array of <TT>pollfd</TT> structures, we pass them to <TT>/dev/poll</TT>. Our example only requires two file descriptors, so we use a static array of structures. In practice, programs that use <TT>/dev/poll</TT> need to monitor hundreds or even thousands of file descriptors, so the array would likely be allocated dynamically.</p>

<A NAME="ch14lev3sec14"></A>
<H5 class="docSection3Title"> Wait for work</H5>
<p class="docText"><span class="docEmphasis"><TT>24–28</TT></span> Rather than calling <TT>select</TT>, this program blocks, waiting for work, in the <TT>ioctl</TT> call. The return is the number of file descriptors that are ready.</p>

<A NAME="ch14lev3sec15"></A>
<H5 class="docSection3Title"> Loop through descriptors</H5>
<p class="docText"><span class="docEmphasis"><TT>30–49</TT></span> The code in our example is simplified since we know the ready file descriptors will be <TT>sockfd</TT>, the input file descriptor, or both. In a large-scale program, this loop would be more complex, perhaps even dispatching the work to threads.</p>


<A NAME="ch14lev2sec7"></A>
<H4 class="docSection2Title"> <TT>kqueue</TT> Interface</H4>
<P class="docText">FreeBSD introduced the <TT>kqueue</TT> interface in FreeBSD version 4.1. This interface allows a process to register an "event filter" that describes the <TT>kqueue</TT> events it is interested in. Events include file I/O and timeouts like <TT>select</TT>, but also adds asynchronous I/O, file modification notification (e.g., notification when a file is removed or modified), process tracking (e.g., notification when a given process exits or calls <TT>fork</TT>), and signal handling. The <TT>kqueue</TT> interface includes the following two functions and macro:</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/types.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/event.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/time.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int kqueue(void)</TT>;</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int kevent(int</TT> <span class="docEmphasis">kq</span>, <TT>const struct kevent *</TT><span class="docEmphasis">changelist</span>, <TT>int</TT> <span class="docEmphasis">nchanges</span>, <TT>struct kevent *</TT><span class="docEmphasis">eventlist</span>, <TT>int</TT> <span class="docEmphasis">nevents</span>, <TT>const struct timespec *</TT><span class="docEmphasis">timeout</span><TT>)</TT> ;</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void EV_SET(struct kevent *</TT><span class="docEmphasis">kev</span>, <TT>uintptr_t</TT> <span class="docEmphasis">ident</span>, <TT>short</TT> <span class="docEmphasis">filter</span>, <TT>u_short</TT> <span class="docEmphasis">flags</span>, <TT>u_int</TT> <span class="docEmphasis">fflags</span>, <TT>intptr_t</TT> <span class="docEmphasis">data</span>, <TT>void *</TT><span class="docEmphasis">udata</span><TT>)</TT>;</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">The <TT>kqueue</TT> function returns a new <TT>kqueue</TT> descriptor, which can be used with future calls to <TT>kevent</TT>. The <TT>kevent</TT> function is used to both register events of interest and determine if any events have occurred. The <span class="docEmphasis">changelist</span> and <span class="docEmphasis">nchanges</span> parameters describe the changes to be made to the events of interest, or are <TT>NULL</TT> and <TT>0</TT>, respectively, if no changes are to be made. If <span class="docEmphasis">nchanges</span> is nonzero, each event filter change requested in the <span class="docEmphasis">changelist</span> array is performed. Any filters whose conditions have triggered, including those that may have just been added in the <span class="docEmphasis">changelist</span>, are returned through the <span class="docEmphasis">eventlist</span> parameter, which points to an array of <span class="docEmphasis">nevents</span> <TT>struct kevents</TT>. The <TT>kevent</TT> function returns the number of events that are returned, or zero if a timeout has occurred. The <span class="docEmphasis">timeout</span> argument holds the timeout, which is handled just like <TT>select: NULL</TT> to block, a nonzero <TT>timespec</TT> to specify an explicit timeout, and a zero <TT>timespec</TT> to perform a nonblocking check for events. Note that the <span class="docEmphasis">timeout</span> parameter is a <TT>struct timespec</TT>, which is different from <TT>select's struct timeval</TT> in that it has nanosecond instead of microsecond resolution.</P>
<P class="docText">The <TT>kevent</TT> structure is defined by including the <TT>&lt;sys/event.h&gt;</TT> header.</P>
<pre>

</pre><pre>
struct kevent {
  uintptr_t  ident;      /* identifier (e.g., file descriptor) */
  short      filter;     /* filter type (e.g., EVFILT_READ) */
  u_short    flags;      /* action flags (e.g., EV_ADD) */
  u_int      fflags;     /* filter-specific flags */
  intptr_t   data;       /* filter-specific data */
  void      *udata;      /* opaque user data */
};
</pre><pre>
</pre>
<P class="docText">The actions for changing a filter and the flag return values are shown in <A class="docLink" HREF="#ch14fig16">Figure 14.16</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch14fig16"></A>Figure 14.16. <span class="docEmphasis">flags</span> for <TT>kevent</TT> operations.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="500" HEIGHT="129" src="FILES/14fig16.gif" ALT="graphics/14fig16.gif"></p>

</CENTER>
<P class="docText">Filter types are shown in <A class="docLink" HREF="#ch14fig17">Figure 14.17</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch14fig17"></A>Figure 14.17. <span class="docEmphasis">filters</span> for <TT>kevent</TT> operations.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="418" HEIGHT="161" src="FILES/14fig17.gif" ALT="graphics/14fig17.gif"></p>

</CENTER>
<P class="docText">We modify our <TT>str_cli</TT> function, which used <TT>select</TT> in <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>, to use <TT>kqueue</TT> in <A class="docLink" HREF="#ch14fig18">Figure 14.18</A>.</P>
<A NAME="ch14lev3sec16"></A>
<H5 class="docSection3Title"> Determine if file pointer points to a file</H5>
<p class="docText"><span class="docEmphasis"><TT>10–11</TT></span> The behavior of <TT>kqueue</TT> on EOF is different depending on whether the file descriptor is associated with a file, a pipe, or a terminal, so we use the <TT>fstat</TT> call to determine if it is a file. We will use this determination later.</p>

<A NAME="ch14lev3sec17"></A>
<H5 class="docSection3Title"> Set up <TT>kevent</TT> structures for <TT>kqueue</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>12–13</TT></span> We use the <TT>EV_SET</TT> macro to set up two <TT>kevent</TT> structures; both specify a read filter (<TT>EVFILT_READ</TT>) and request to add this event to the filter (<TT>EV_ADD</TT>).</p>

<A NAME="ch14lev3sec18"></A>
<H5 class="docSection3Title"> Create <TT>kqueue</TT> and add filters</H5>
<p class="docText"><span class="docEmphasis"><TT>14–16</TT></span> We call <TT>kqueue</TT> to get a <TT>kqueue</TT> descriptor, set the timeout to zero to allow a nonblocking call to <TT>kevent</TT>, and call <TT>kevent</TT> with our array of <TT>kevents</TT> as the change request.</p>

<A NAME="ch14lev3sec19"></A>
<H5 class="docSection3Title"> Loop forever, blocking in <TT>kevent</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>17–18</TT></span> We loop forever, blocking in <TT>kevent</TT>. We pass a <TT>NULL</TT> change list, since we are only interested in the events we have already registered, and a <TT>NULL</TT> timeout to block forever.</p>

<A NAME="ch14lev3sec20"></A>
<H5 class="docSection3Title"> Loop through returned events</H5>
<p class="docText"><span class="docEmphasis"><TT>19</TT></span> We check each event that was returned and process it individually.</p>

<H5 class="docExampleTitle"><A NAME="ch14fig18"></A>Figure 14.18 <TT>str_cli</TT> function using <TT>kqueue</TT>.</H5>
<P class="docText"><span class="docEmphasis">advio/str_cli_kqueue04.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 str_cli(FILE *fp, int sockfd)
 4 {
 5     int     kq, i, n, nev, stdineof = 0, isfile;
 6     char    buf[MAXLINE];
 7     struct kevent kev[2];
 8     struct timespec ts;
 9     struct stat st;

10     isfile = ((fstat(fileno(fp), &amp;st) == 0) &amp;&amp;
11               (st.st_mode &amp; S_IFMT) == S_IFREG);

12     EV_SET(&amp;kev[0], fileno(fp), EVFILT_READ, EV_ADD, 0, 0, NULL);
13     EV_SET(&amp;kev[1], sockfd, EVFILT_READ, EV_ADD, 0, 0, NULL);

14     kq = Kqueue();
15     ts.tv_sec = ts.tv_nsec = 0;
16     Kevent(kq, kev, 2, NULL, 0, &amp;ts);

17     for ( ; ; ) {
18         nev = Kevent(kq, NULL, 0, kev, 2, NULL);

19         for (i = 0; i &lt; nev; i++) {
20             if (kev[i].ident == sockfd) {     /* socket is readable */
21                 if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {
22                     if (stdineof == 1)
23                         return; /* normal termination */
24                     else
25                         err_quit("str_cli: server terminated prematurely");
26                 }

27                 Write(fileno(stdout), buf, n);
28             }

29             if (kev[i].ident == fileno(fp)) {  /* input is readable */
30                 n = Read(fileno(fp), buf, MAXLINE);
31                 if (n &gt; 0)
32                     Writen(sockfd, buf, n);

33                 if (n == 0 || (isfile &amp;&amp; n == kev[i].data)) {
34                     stdineof = 1;
35                     Shutdown(sockfd, SHUT_WR);  /* send FIN */
36                     kev[i].flags = EV_DELETE;
37                     Kevent(kq, &amp;kev[i], 1, NULL, 0, &amp;ts);    /* remove kevent */
38                     continue;
39                 }
40             }
41         }
42     }
43 }
</PRE>


<A NAME="ch14lev3sec21"></A>
<H5 class="docSection3Title"> Socket is readable</H5>
<p class="docText"><span class="docEmphasis"><TT>20–28</TT></span> This code is exactly the same as in <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>.</p>

<A NAME="ch14lev3sec22"></A>
<H5 class="docSection3Title"> Input is readable</H5>
<p class="docText"><span class="docEmphasis"><TT>29–40</TT></span> This code is similar to <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A>, but is structured slightly differently to handle how <TT>kqueue</TT> reports an EOF. On pipes and terminals, <TT>kqueue</TT> returns a readable indication that an EOF is pending, just like <TT>select</TT>. However, on files, <TT>kqueue</TT> simply returns the number of bytes left in the file in the <TT>data</TT> member of the <TT>struct kevent</TT> and assumes that the application will know when it reaches the end. Therefore, we restructure the loop to write the data to the network if a nonzero number of bytes were read. Next, we check our modified EOF condition: if we have read zero bytes or if it's a file and we've read as many bytes as are left in the file. The other modification from <A class="docLink" HREF="0131411551_ch06lev1sec7.html#ch06fig13">Figure 6.13</A> is that instead of using <TT>FD_CLR</TT> to remove the input descriptor from the file set, we set the flags to <TT>EV_DELETE</TT> and call <TT>kevent</TT> to remove this event from the filter in the kernel.</p>


<A NAME="ch14lev2sec8"></A>
<H4 class="docSection2Title"> Suggestions</H4>
<P class="docText">Care should be taken with these newly evolved interfaces to read the documentation specific to the OS release. These interfaces often change in subtle ways between releases while the vendors work through the details of how they should work.</P>
<P class="docText">While writing nonportable code is, in general, something to avoid, it is quite common to use any means possible to optimize a very heavily used network application for the specific server it runs on.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch14lev1sec8.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch14lev1sec10.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
