<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="28.3 Raw Socket Output"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch28lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch28lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch28lev1sec3"></A>
<H3 class="docSection1Title">28.3 Raw Socket Output</H3>
<P class="docText">Output on a raw socket is governed by the following rules:</P>
<UL><LI><P class="docList">Normal output is performed by calling <TT>sendto</TT> or <TT>sendmsg</TT> and specifying the destination IP address. <TT>write</TT>, <TT>writev</TT>, or <TT>send</TT> can also be called if the socket has been connected.</P></LI><LI><P class="docList">If the <TT>IP_HDRINCL</TT> option is not set, the starting address of the data for the kernel to send specifies the first byte following the IP header because the kernel will build the IP header and prepend it to the data from the process. The kernel sets the protocol field of the IPv4 header that it builds to the third argument from the call to <TT>socket</TT>.</P></LI><LI><P class="docList">If the <TT>IP_HDRINCL</TT> option is set, the starting address of the data for the kernel to send specifies the first byte of the IP header. The amount of data to write must include the size of the caller's IP header. The process builds the entire IP header, except: (i) the IPv4 identification field can be set to 0, which tells the kernel to set this value; (ii) the kernel always calculates and stores the IPv4 header checksum; and (iii) IP options may or may not be included; see <A class="docLink" HREF="0131411551_ch27lev1sec2.html#ch27lev1sec2">Section 27.2</A></P></LI><LI><P class="docList">The kernel fragments raw packets that exceed the outgoing interface MTU.</P><BLOCKQUOTE><P><P class="docList">Raw sockets are documented to provide an identical interface to the one a protocol would have if it was resident in the kernel [McKusick et al. 1996] Unfortunately, this means that certain pieces of the API are dependent on the OS kernel, specifically with regard to the byte ordering of the fields in the IP header. On many Berkeley-derived kernels, all fields are in network byte order except <TT>ip_len</TT> and <TT>ip_off</TT>, which are in host byte order (pp. 233 and 1057 of TCPv2). On Linux and OpenBSD, however, all the fields must be in network byte order.</P></P><P><P class="docList">The <TT>IP_HDRINCL</TT> socket option was introduced with 4.3BSD Reno. Before this, the only way for an application to specify its own IP header in packets sent on a raw IP socket was to apply a kernel patch that was introduced in 1988 by Van Jacobson to support <TT>traceroute</TT>. This patch required the application to create a raw IP socket specifying <span class="docEmphasis">a protocol</span> of <TT>IPPROTO_RAW</TT>, which has a value of 255 (and is a reserved value and must never appear as the protocol field in an IP header).</P></P><P><P class="docList">The functions that perform input and output on raw sockets are some of the simplest in the kernel. For example, in TCPv2, each function requires about 40 lines of C code (pp. 1054–1057), compared to TCP input at about 2,000 lines and TCP output at about 700 lines.</P></P></BLOCKQUOTE></LI></UL>
<P class="docText">Our description of the <TT>IP_HDRINCL</TT> socket option is for 4.4BSD. Earlier versions, such as Net/2, filled in more fields in the IP header when this option was set.</P>
<P class="docText">With IPv4, it is the responsibility of the user process to calculate and set any header checksums contained in whatever follows the IPv4 header. For example, in our <TT>ping</TT> program (<A class="docLink" HREF="0131411551_ch28lev1sec5.html#ch28fig14">Figure 28.14</A>), we must calculate the ICMPv4 checksum and store it in the ICMPv4 header before calling <TT>sendto</TT>.</P>
<A NAME="ch28lev2sec1"></A>
<H4 class="docSection2Title"> IPv6 Differences</H4>
<P class="docText">There are a few differences with raw IPv6 sockets (RFC 3542 [Stevens et al. 2003]):</P>
<UL><LI><P class="docList">All fields in the protocol headers sent or received on a raw IPv6 socket are in network byte order.</P></LI><LI><P class="docList">There is nothing similar to the IPv4 <TT>IP_HDRINCL</TT> socket option with IPv6. Complete IPv6 packets (including the IPv6 header or extension headers) cannot be read or written on an IPv6 raw socket. Almost all fields in an IPv6 header and all extension headers are available to the application through socket options or ancillary data (see <A class="docLink" HREF="0131411551_ch28lev1sec9.html#ch28lev1sec9">Exercise 28.1</A>). Should an application need to read or write complete IPv6 datagrams, datalink access (described in <A class="docLink" HREF="0131411551_ch29.html#ch29">Chapter 29</A>) must be used.</P></LI><LI><P class="docList">Checksums on raw IPv6 sockets are handled differently, as will be described shortly.</P></LI></UL>

<A NAME="ch28lev2sec2"></A>
<H4 class="docSection2Title"> <TT>IPV6_CHECKSUM</TT> Socket Option</H4>
<P class="docText">For an ICMPv6 raw socket, the kernel always calculates and stores the checksum in the ICMPv6 header. This differs from an ICMPv4 raw socket, where the application must do this itself (compare <A class="docLink" HREF="0131411551_ch28lev1sec5.html#ch28fig14">Figures 28.14</A> and <A class="docLink" HREF="0131411551_ch28lev1sec5.html#ch28fig16">28.16</A>). While ICMPv4 and ICMPv6 both require the sender to calculate the checksum, ICMPv6 includes a pseudoheader in its checksum (we will discuss the concept of a pseudoheader when we calculate the UDP checksum in <A class="docLink" HREF="0131411551_ch29lev1sec7.html#ch29fig14">Figure 29.14</A>). One of the fields in this pseudoheader is the source IPv6 address, and normally the application lets the kernel choose this value. To prevent the application from having to try to choose this address just to calculate the checksum, it is easier to let the kernel calculate the checksum.</P>
<P class="docText">For other raw IPv6 sockets (i.e., those created with a third argument to <TT>socket</TT> other than <TT>IPPROTO_ICMPV6</TT>), a socket option tells the kernel whether to calculate and store a checksum in outgoing packets and verify the checksum in received packets. By default, this option is disabled, and it is enabled by setting the option value to a nonnegative value, as in</P>
<pre>

</pre><pre>
int offset = 2;

if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_CHECKSUM,
               &amp;offset, sizeof(offset)) &lt; 0)
    <span class="docEmphasis">error</span>
</pre><pre>
</pre>
<P class="docText">This not only enables checksums on this socket, it also tells the kernel the byte offset of the 16-bit checksum: 2 bytes from the start of the application data in this example. To disable the option, it must be set to -1. When enabled, the kernel will calculate and store the checksum for outgoing packets sent on the socket and also verify the checksums for packets received on the socket.</P>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch28lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch28lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
