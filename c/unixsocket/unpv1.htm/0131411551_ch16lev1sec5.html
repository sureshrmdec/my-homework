<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="16.5 Nonblocking 'connect:' Web Client"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch16lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch16lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch16lev1sec5"></A>
<H3 class="docSection1Title" id="162666-824">16.5 Nonblocking <TT>connect:</TT> Web Client</H3>
<P class="docText">A real-world example of nonblocking <TT>connects</TT> started with the Netscape Web client (Section 13.4 of TCPv3). The client establishes an HTTP connection with a Web server and fetches a home page. Often, that page will have numerous references to other Web pages. Instead of fetching these other pages serially, one at a time, the client can fetch more than one at the same time using nonblocking <TT>connects</TT>. <A class="docLink" HREF="#ch16fig12">Figure 16.12</A> shows an example of establishing multiple connections in parallel. The leftmost scenario shows all three connections performed serially. We assume that the first connection takes 10 units of time, the second 15, and the third 4, for a total of 29 units of time.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig12"></A>Figure 16.12. Establishing multiple connections in parallel.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="481" HEIGHT="355" src="FILES/16fig12.gif" ALT="graphics/16fig12.gif"></p>

</CENTER>
<P class="docText">In the middle scenario, we perform two connections in parallel. At time 0, the first two connections are started, and when the first of these finishes, we start the third. The total time is almost halved, from 29 to 15, but realize that this is the ideal case. If the parallel connections are sharing a common link (say the client is behind a dialup modem link to the Internet), each can compete against each other for the limited resources and all the individual connection times might get longer. For example, the time of 10 might be 15, the time of 15 might be 20, and the time of 4 might be 6. Nevertheless, the total time would be 21, still shorter than the serial scenario.</P>
<P class="docText">In the third scenario, we perform three connections in parallel, and we again assume there is no interference between the three connections (the ideal case). But, the total time is the same (15 units) as the second scenario given the example times that we choose.</P>
<P class="docText">When dealing with Web clients, the first connection is done by itself, followed by multiple connections for the references found in the data from that first connection. We show this in <A class="docLink" HREF="#ch16fig13">Figure 16.13</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig13"></A>Figure 16.13. Complete first connection, then multiple connections in parallel.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="128" HEIGHT="329" src="FILES/16fig13.gif" ALT="graphics/16fig13.gif"></p>

</CENTER>
<P class="docText">To further optimize this sequence, the client can start parsing the data that is returned for the first connection before the first connection completes and initiate additional connections as soon as it knows that additional connections are needed.</P>
<P class="docText">Since we are doing multiple nonblocking <TT>connects</TT> at the same time, we cannot use our <TT>connect_nonb</TT> function from <A class="docLink" HREF="0131411551_ch16lev1sec4.html#ch16fig11">Figure 16.11</A> because it does not return until the connection is established. Instead, we must keep track of multiple connections ourself.</P>
<P class="docText">Our program will read up to 20 files from a Web server. We specify as command-line arguments the maximum number of parallel connections, the server's hostname, and each of the filenames to fetch from the server. A typical execution of our program is</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">web  3  www.foobar.com  /  image1.gif image2.gif  \</span>
<span class="docEmphStrong">image3.gif image4.gif image5.gif  \</span>
<span class="docEmphStrong">image6.gif image7.gif</span>
</pre><pre>
</pre>
<P class="docText">The command-line arguments specify three simultaneous connections: the server's hostname, the filename for the home page (<TT>/</TT>, the server's root page), and seven files to then read (which in this example are all GIF images). These seven files would normally be referenced on the home page, and a Web client would read the home page and parse the HTML to obtain these filenames. We do not want to complicate this example with HTML parsing, so we just specify the filenames on the command line.</P>
<P class="docText">This is a larger example, so we will show it in pieces. <A class="docLink" HREF="#ch16fig14">Figure 16.14</A> is our <TT>web.h</TT> header that each file includes.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig14"></A>Figure 16.14 <TT>web.h</TT> header.</H5>
<P class="docText"><span class="docEmphasis">nonblock/web.h</span></P>

<PRE>
 1 #include     "unp.h"

 2 #define MAXFILES     20
 3 #define SERV         "80"         /* port number or service name */

 4 struct file {
 5     char   *f_name;               /* filename */
 6     char   *f_host;               /* hostname or IPv4/IPv6 address */
 7     int     f_fd;                 /* descriptor */
 8     int     f_flags;              /* F_xxx below */
 9 } file[MAXFILES];

10 #define F_CONNECTING     1        /* connect() in progress */
11 #define F_READING        2        /* connect() complete; now reading */
12 #define F_DONE           4        /* all done */

13 #define GET_CMD      "GET %s HTTP/1.0\r\n\r\n"

14             /* globals */
15 int     nconn,  nfiles, nlefttoconn, nlefttoread, maxfd;
16 fd_set  rset, wset;

17            /* function prototypes */
18 void   home_page(const char *, const char *);
19 void   start_connect(struct file *);
20 void   write_get_cmd(struct file *);
</PRE>

<A NAME="ch16lev3sec21"></A>
<H4 class="docSection2Title"> Define <TT>file</TT> structure</H4>
<p class="docText"><span class="docEmphasis"><TT>2–13</TT></span> The program reads up to <TT>MAXFILES</TT> files from the Web server. We maintain a <TT>file</TT> structure with information about each file: its name (copied from the command-line argument), the hostname or IP address of the server to read the file from, the socket descriptor being used for the file, and a set of flags to specify what we are doing with this file (connecting, reading, or done).</p>

<A NAME="ch16lev3sec22"></A>
<H4 class="docSection2Title"> Define globals and function prototypes</H4>
<p class="docText"><span class="docEmphasis"><TT>14–20</TT></span> We define the global variables and function prototypes for the functions that we will describe shortly.</p>
<P class="docText"><A class="docLink" HREF="#ch16fig15">Figure 16.15</A> shows the first part of the <TT>main</TT> program.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig15"></A>Figure 16.15 First part of simultaneous <TT>connect:</TT> globals and start of <TT>main</TT>.</H5>
<P class="docText"><span class="docEmphasis">nonblock/web.c</span></P>

<PRE>
 1 #include     "web.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     i, fd, n, maxnconn, flags, error;
 6     char    buf[MAXLINE];
 7     fd_set  rs, ws;

 8     if (argc &lt; 5)
 9         err_quit("usage: web &lt;#conns&gt; &lt;hostname&gt; &lt;homepage&gt; &lt;file1&gt; ...");
10     maxnconn = atoi(argv[1]);

11     nfiles = min(argc - 4, MAXFILES);
12     for (i = 0; i &lt; nfiles; i++) {
13         file[i].f_name = argv[i + 4];
14         file[i].f_host = argv[2];
15         file[i].f_flags = 0;
16     }
17     printf("nfiles = %d\n", nfiles);

18     home_page(argv[2], argv[3]);

19     FD_ZERO(&amp;rset);
20     FD_ZERO(&amp;wset);
21     maxfd = -1;
22     nlefttoread = nlefttoconn = nfiles;
23     nconn = 0;
</PRE>


<A NAME="ch16lev3sec23"></A>
<H4 class="docSection2Title"> Process command-line arguments</H4>
<p class="docText"><span class="docEmphasis"><TT>11–17</TT></span> The <TT>file</TT> structures are filled in with the relevant information from the command-line arguments.</p>

<A NAME="ch16lev3sec24"></A>
<H4 class="docSection2Title"> Read home page</H4>
<p class="docText"><span class="docEmphasis"><TT>18</TT></span> The function <TT>home_page</TT>, which we will show next, creates a TCP connection, sends a command to the server, and then reads the home page. This is the first connection, which is done by itself, before we start establishing multiple connections in parallel.</p>

<A NAME="ch16lev3sec25"></A>
<H4 class="docSection2Title"> Initialize globals</H4>
<p class="docText"><span class="docEmphasis"><TT>19–23</TT></span> Two descriptor sets, one for reading and one for writing, are initialized. <TT>maxfd</TT> is the maximum descriptor for <TT>select</TT> (which we initialize to –1 since descriptors are non-negative), <TT>nlefttoread</TT> is the number of files remaining to be read (when this reaches 0, we are finished), <TT>nlefttoconn</TT> is the number of files that still need a TCP connection, and <TT>nconn</TT> is the number of connections currently open (which can never exceed the first command-line argument).</p>
<P class="docText"><A class="docLink" HREF="#ch16fig16">Figure 16.16</A> shows the <TT>home_page</TT> function that is called once when the <TT>main</TT> function begins.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig16"></A>Figure 16.16 <TT>home_page</TT> function.</H5>
<P class="docText"><span class="docEmphasis">nonblock/home_page.c</span></P>

<PRE>
 1 #include     "web.h"

 2 void
 3 home_page(const char *host, const char *fname)
 4 {
 5     int     fd, n;
 6     char    line[MAXLINE];

 7     fd = Tcp_connect(host, SERV);   /* blocking connect() */

 8     n = snprintf(line, sizeof(line), GET_CMD, fname);
 9     Writen(fd, line, n);

10     for ( ; ; ) {
11         if ( (n = Read(fd, line, MAXLINE)) == 0)
12             break;               /* server closed connection */

13         printf("read %d bytes of home page\n", n);
14         /* do whatever with data */
15     }
16     printf("end-of-file on home page\n");
17     Close(fd);
18 }
</PRE>


<A NAME="ch16lev3sec26"></A>
<H4 class="docSection2Title"> Establish connection with server</H4>
<p class="docText"><span class="docEmphasis"><TT>7</TT></span> Our <TT>tcp_connect</TT> establishes a connection with the server.</p>

<A NAME="ch16lev3sec27"></A>
<H4 class="docSection2Title"> Send HTTP command to server, read reply</H4>
<p class="docText"><span class="docEmphasis"><TT>8–17</TT></span> An HTTP <TT>GET</TT> command is issued for the home page (often named <TT>/</TT>). The reply is read (we do not do anything with the reply) and the connection is closed.</p>
<P class="docText">The next function, <TT>start_connect</TT>, shown in <A class="docLink" HREF="#ch16fig17">Figure 16.17</A>, initiates a nonblocking <TT>connect</TT>.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig17"></A>Figure 16.17 Initiate nonblocking <TT>connect</TT>.</H5>
<P class="docText"><span class="docEmphasis">nonblock/start_connect.c</span></P>

<PRE>
 1 #include     "web.h"

 2 void
 3 start_connect(struct file *fptr)
 4 {
 5     int     fd, flags, n;
 6     struct addrinfo *ai;

 7     ai = Host_serv(fptr-&gt;f_host, SERV, 0, SOCK_STREAM);

 8     fd = Socket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol);
 9     fptr-&gt;f_fd = fd;
10     printf("start_connect for %s, fd %d\n", fptr-&gt;f_name, fd);

11         /* Set socket nonblocking */
12     flags = Fcntl(fd, F_GETFL, 0);
13     Fcntl(fd, F_SETFL, flags | O_NONBLOCK);

14         /* Initiate nonblocking connect to the server. */
15     if ( (n = connect(fd, ai-&gt;ai_addr, ai-&gt;ai_addrlen)) &lt; 0) {
16         if (errno != EINPROGRESS)
17             err_sys("nonblocking connect error");
18         fptr-&gt;f_flags = F_CONNECTING;
19         FD_SET(fd, &amp;rset);     /* select for reading and writing */
20         FD_SET(fd, &amp;wset);
21         if (fd &gt; maxfd)
22             maxfd = fd;

23      } else if (n &gt;= 0)            /* connect is already done */
24          write_get_cmd(fptr);      /* write() the GET command */
25 }
</PRE>


<A NAME="ch16lev3sec28"></A>
<H4 class="docSection2Title"> Create socket, set to nonblocking</H4>
<p class="docText"><span class="docEmphasis"><TT>7–13</TT></span> We call our <TT>host_serv</TT> function (<A class="docLink" HREF="0131411551_ch11lev1sec11.html#ch11fig09">Figure 11.9</A>) to look up and convert the hostname and service name, returning a pointer to an array of <TT>addrinfo</TT> structures. We use only the first structure. A TCP socket is created and the socket is set to nonblocking.</p>

<A NAME="ch16lev3sec29"></A>
<H4 class="docSection2Title"> Initiate nonblocking <TT>connect</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>14–22</TT></span> The nonblocking <TT>connect</TT> is initiated and the file's flag is set to <TT>F_CONNECTING</TT>. The socket descriptor is turned on in both the read set and the write set since <TT>select</TT> will wait for either condition as an indication that the connection has finished. We also update <TT>maxfd</TT>, if necessary.</p>

<A NAME="ch16lev3sec30"></A>
<H4 class="docSection2Title"> Handle connection complete</H4>
<p class="docText"><span class="docEmphasis"><TT>23–24</TT></span> If <TT>connect</TT> returns successfully, the connection is already complete and the function <TT>write_get_cmd</TT> (shown next) sends a command to the server.</p>
<P class="docText">We set the socket to nonblocking for the <TT>connect</TT>, but never reset it to its default blocking mode. This is fine because we write only a small amount of data to the socket (the <TT>GET</TT> command in the next function) and we assume that this command is much smaller than the socket send buffer. Even if <TT>write</TT> returns a short count because of the nonblocking flag, our <TT>writen</TT> function handles this. Leaving the socket as nonblocking has no effect on the subsequent <TT>reads</TT> that are performed because we always call <TT>select</TT> to wait for the socket to become readable.</P>
<P class="docText"><A class="docLink" HREF="#ch16fig18">Figure 16.18</A> shows the function <TT>write_get_cmd</TT>, which sends an HTTP <TT>GET</TT> command to the server.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig18"></A>Figure 16.18 Send an HTTP <TT>GET</TT> command to the server.</H5>
<P class="docText"><span class="docEmphasis">nonblock/write_get_cmd.c</span></P>

<PRE>
 1 #include     "web.h"

 2 void
 3 write_get_cmd(struct file *fptr)
 4 {
 5     int     n;
 6     char    line[MAXLINE];

 7     n = snprintf(line, sizeof(line), GET_CMD, fptr-&gt;f_name);
 8     Writen(fptr-&gt;f_fd, line, n);
 9     printf("wrote %d bytes for %s\n", n, fptr-&gt;f_name);

10     fptr-&gt;f_flags = F_READING;  /* clears F_CONNECTING */

11     FD_SET(fptr-&gt;f_fd, &amp;rset);  /* will read server's reply */
12     if (fptr-&gt;f_fd &gt; maxfd)
13         maxfd = fptr-&gt;f_fd;
14 }
</PRE>


<A NAME="ch16lev3sec31"></A>
<H4 class="docSection2Title"> Build command and send it</H4>
<p class="docText"><span class="docEmphasis"><TT>7–9</TT></span> The command is built and written to the socket.</p>

<A NAME="ch16lev3sec32"></A>
<H4 class="docSection2Title"> Set flags</H4>
<p class="docText"><span class="docEmphasis"><TT>10–13</TT></span> The file's <TT>F_READING</TT> flag is set, which also clears the <TT>F_CONNECTING</TT> flag (if set). This indicates to the main loop that this descriptor is ready for input. The descriptor is also turned on in the read set and <TT>maxfd</TT> is updated, if necessary.</p>
<P class="docText">We now return to the <TT>main</TT> function in <A class="docLink" HREF="#ch16fig19">Figure 16.19</A>, picking up where we left off in <A class="docLink" HREF="#ch16fig15">Figure 16.15</A>. This is the main loop of the program: As long as there are more files to process (<TT>nlefttoread</TT> is greater than 0), start another connection if possible and then use <TT>select</TT> on all active descriptors, handling both nonblocking connection completions and the arrival of data.</P>

<A NAME="ch16lev3sec33"></A>
<H4 class="docSection2Title"> Initiate another connection, if possible</H4>
<p class="docText"><span class="docEmphasis"><TT>24–35</TT></span> If we are not at the specified limit of simultaneous connections, and there are additional connections to establish, find a file that we have not yet processed (indicated by a <TT>f_flags</TT> of 0) and call <TT>start_connect</TT> to initiate the connection. The number of active connections is incremented (<TT>nconn</TT>) and the number of connections remaining to be established is decremented (<TT>nlefttoconn</TT>).</p>

<A NAME="ch16lev3sec34"></A>
<H4 class="docSection2Title"> <TT>select:</TT> wait for something to happen</H4>
<p class="docText"><span class="docEmphasis"><TT>36–37</TT></span> <TT>select</TT> waits for either readability or writability. Descriptors that have a nonblocking <TT>connect</TT> in progress will be enabled in both sets, while descriptors with a completed connection that are waiting for data from the server will be enabled in just the read set.</p>

<A NAME="ch16lev3sec35"></A>
<H4 class="docSection2Title"> Handle all ready descriptors</H4>
<p class="docText"><span class="docEmphasis"><TT>39–55</TT></span> We now process each element in the array of <TT>file</TT> structures to determine which descriptors need processing. If the <TT>F_CONNECTING</TT> flag is set and the descriptor is on in either the read set or the write set, the nonblocking <TT>connect</TT> is finished. As we described with <A class="docLink" HREF="0131411551_ch16lev1sec4.html#ch16fig11">Figure 16.11</A>, we call <TT>getsockopt</TT> to fetch the pending error for the socket. If this value is 0, the connection completed successfully. In that case, we turn off the descriptor in the write set and call <TT>write_get_cmd</TT> to send the HTTP request to the server.</p>

<A NAME="ch16lev3sec36"></A>
<H4 class="docSection2Title"> See if descriptor has data</H4>
<p class="docText"><span class="docEmphasis"><TT>56–67</TT></span> If the <TT>F_READING</TT> flag is set and the descriptor is ready for reading, we call <TT>read</TT>. If the connection was closed by the other end, we close the socket, set the <TT>F_DONE</TT> flag, turn off the descriptor in the read set, and decrement the number of active connections and the total number of connections to be processed.</p>
<P class="docText">There are two optimizations that we do not perform in this example (to avoid complicating it even more). First, we could terminate the <TT>for</TT> loop in <A class="docLink" HREF="#ch16fig19">Figure 16.19</A> when we finish processing the number of descriptors that <TT>select</TT> said were ready. Next, we could decrease the value of <TT>maxfd</TT> when possible, to save <TT>select</TT> from examining descriptor bits that are no longer set. Since the number of descriptors this code deals with at any one time is probably less than 10, and not in the thousands, it is doubtful that either of these optimizations is worth the additional complications.</P>

<H5 class="docExampleTitle"><A NAME="ch16fig19"></A>Figure 16.19 Main loop of <TT>main</TT> function.</H5>
<P class="docText"><span class="docEmphasis">nonblock/web.c</span></P>

<PRE>
24      while (nlefttoread &gt; 0) {
25          while (nconn &lt; maxnconn &amp;&amp; nlefttoconn &gt; 0) {
26                  /* find a file to read */
27              for (i = 0; i &lt; nfiles; i++)
28                   if (file[i].f_flags == 0)
29                       break;
30              if  (i == nfiles)
31                  err_quit("nlefttoconn = %d but nothing found", nlefttoconn);
32              start_connect(&amp;file[i]);
33              nconn++;
34              nlefttoconn--;
35         }

36         rs = rset;
37         ws = wset;
38         n = Select(maxfd + 1, &amp;rs, &amp;ws, NULL, NULL);

39         for (i = 0; i &lt; nfiles; i++) {
40             flags = file[i].f_flags;
41             if (flags == 0 || flags &amp; F_DONE)
42                 continue;
43             fd = file[i].f_fd;
44             if (flags &amp; F_CONNECTING &amp;&amp;
45                 (FD_ISSET(fd, &amp;rs) || FD_ISSET(fd, &amp;ws))) {
46                 n = sizeof(error);
47                 if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;n) &lt; 0 ||
48                 error != 0) {
49                 err_ret("nonblocking connect failed for %s",
50                         file[i].f_name);
51             }
52                 /* connection established */
53             printf("connection established for %s\n", file[i].f_name);
54             FD_CLR(fd, &amp;wset); /* no more writeability test */
55             write_get_cmd(&amp;file[i]);   /* write() the GET command */

56        } else if (flags &amp; F_READING &amp;&amp; FD_ISSET(fd, &amp;rs)) {
57            if ( (n = Read(fd, buf, sizeof(buf))) == 0) {
58                printf("end-of-file on %s\n", file[i].f_name);
59                Close(fd);
60                file[i].f_flags = F_DONE;    /* clears F_READING */
61                FD_CLR(fd, &amp;rset);
62                nconn--;
63                nlefttoread--;
64            } else {
65                printf("read %d bytes from %s\n", n, file[i].f_name);
66            }
67         }
68      }
69   }
70   exit(0);
71 }
</PRE>


<A NAME="ch16lev2sec4"></A>
<H4 class="docSection2Title"> Performance of Simultaneous Connections</H4>
<P class="docText">What is the performance gain in establishing multiple connections at the same time? <A class="docLink" HREF="#ch16fig20">Figure 16.20</A> shows the clock time required to fetch a Web server's home page, followed by nine image files from that server. The RTT to the server is about 150 ms. The home page size was 4,017 bytes and the average size of the 9 image files was 1,621 bytes. TCP's segment size was 512 bytes. We also include in this figure, for comparison, values for a version of this program that we will develop in <A class="docLink" HREF="0131411551_ch26lev1sec9.html#ch26lev1sec9">Section 26.9</A> using threads.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch16fig20"></A>Figure 16.20. Clock time for various numbers of simultaneous connections.</H5>

<p class="docText">
<IMG BORDER="0" id="132235130214" WIDTH="294" HEIGHT="213" src="FILES/16fig20.gif" ALT="graphics/16fig20.gif"></p>

</CENTER>
<P class="docText">Most of the improvement is obtained with three simultaneous connections (the clock time is halved), and the performance increase is much less with four or more simultaneous connections.</P>
<BLOCKQUOTE><P><P class="docList">We provide this example using simultaneous <TT>connects</TT> because it is a nice example using nonblocking I/O and one whose performance impact can be measured. It is also a feature used by a popular Web application, the Netscape browser. There are pitfalls in this technique if there is any congestion in the network. Chapter 21 of TCPv1 describes TCP's slow-start and congestion avoidance algorithms in detail. When multiple connections are established from a client to a server, there is no communication between the connections at the TCP layer. That is, if one connection encounters a packet loss, the other connections to the same server are not notified, and it is highly probable that the other connections will soon encounter packet loss unless they slow down. These additional connections are sending more packets into an already congested network. This technique also increases the load at any given time on the server.</P></P></BLOCKQUOTE>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch16lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch16lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
