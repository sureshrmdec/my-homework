<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.9 Server Not Running"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch08lev1sec8.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch08lev1sec10.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec9"></A>
<H3 class="docSection1Title">8.9 Server Not Running</H3>
<P class="docText">The next scenario to examine is starting the client without starting the server. If we do so and type in a single line to the client, nothing happens. The client blocks forever in its call to <TT>recvfrom</TT>, waiting for a server reply that will never appear. But, this is an example where we need to understand more about the underlying protocols to understand what is happening to our networking application.</P>
<P class="docText">First we start <TT>tcpdump</TT> on the host <TT>macosx</TT>, and then we start the client on the same host, specifying the host <TT>freebsd4</TT> as the server host. We then type a single line, but the line is not echoed.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>macosx %</TT> <span class="docEmphStrong"><TT>udpcli01 172.24.37.94</TT></span></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><span class="docEmphStrong"><TT>hello, world</TT></span></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText"><span class="docEmphasis">we type this line but nothing is echoed back</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><A class="docLink" HREF="#ch08fig10">Figure 8.10</A> shows the <TT>tcpdump</TT> output.</P>

<H5 class="docExampleTitle"><A NAME="ch08fig10"></A>Figure 8.10 <TT>tcpdump</TT> output when server process not started on server host.</H5>

<PRE>
1 0.0                    arp who-has freebsd4 tell macosx
2 0.003576 ( 0.0036)     arp reply freebsd4 is-at 0:40:5:42:d6:de

3 0.003601 ( 0.0000)     macosx.51139 &gt; freebsd4.9877: udp 13
4 0.009781 ( 0.0062)     freebsd4 &gt; macosx: icmp: freebsd4 udp port 9877 unreachable
</PRE>

<P class="docText">First we notice that an ARP request and reply are needed before the client host can send the UDP datagram to the server host. (We left this exchange in the output to reiterate the potential for an ARP request-reply before an IP datagram can be sent to another host or router on the local network.)</P>
<P class="docText">In line 3, we see the client datagram sent but the server host responds in line 4 with an ICMP "port unreachable." (The length of 13 accounts for the 12 characters and the newline.) This ICMP error, however, is not returned to the client process, for reasons that we will describe shortly. Instead, the client blocks forever in the call to <TT>recvfrom</TT> in <A class="docLink" HREF="0131411551_ch08lev1sec6.html#ch08fig08">Figure 8.8</A>. We also note that ICMPv6 has a "port unreachable" error, similar to ICMPv4 (<A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig15">Figures A.15</A> and <A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig16">A.16</A>), so the results described here are similar for IPv6.</P>
<P class="docText">We call this ICMP error an <span class="docEmphasis">asynchronous error</span>. The error was caused by <TT>sendto</TT>, but <TT>sendto</TT> returned successfully. Recall from <A class="docLink" HREF="0131411551_ch02lev1sec11.html#ch02lev1sec11">Section 2.11</A> that a successful return from a UDP output operation only means there was room for the resulting IP datagram on the interface output queue. The ICMP error is not returned until later (4 ms later in <A class="docLink" HREF="#ch08fig10">Figure 8.10</A>), which is why it is called asynchronous.</P>
<P class="docText">The basic rule is that an asynchronous error is not returned for a UDP socket unless the socket has been connected. We will describe how to call <TT>connect</TT> for a UDP socket in <A class="docLink" HREF="0131411551_ch08lev1sec11.html#ch08lev1sec11">Section 8.11</A>. Why this design decision was made when sockets were first implemented is rarely understood. (The implementation implications are discussed on pp. 748–749 of TCPv2.)</P>
<P class="docText">Consider a UDP client that sends three datagrams in a row to three different servers (i.e., three different IP addresses) on a single UDP socket. The client then enters a loop that calls <TT>recvfrom</TT> to read the replies. Two of the datagrams are correctly delivered (that is, the server was running on two of the three hosts) but the third host was not running the server. This third host responds with an ICMP port unreachable. This ICMP error message contains the IP header and UDP header of the datagram that caused the error. (ICMPv4 and ICMPv6 error messages always contain the IP header and all of the UDP header or part of the TCP header to allow the receiver of the ICMP error to determine which socket caused the error. We will show this in <A class="docLink" HREF="0131411551_ch28lev1sec6.html#ch28fig21">Figures 28.21</A> and <A class="docLink" HREF="0131411551_ch28lev1sec6.html#ch28fig22">28.22</A>.) The client that sent the three datagrams needs to know the destination of the datagram that caused the error to distinguish which of the three datagrams caused the error. But how can the kernel return this information to the process? The only piece of information that <TT>recvfrom</TT> can return is an <TT>errno</TT> value; <TT>recvfrom</TT> has no way of returning the destination IP address and destination UDP port number of the datagram in error. The decision was made, therefore, to return these asynchronous errors to the process only if the process connected the UDP socket to exactly one peer.</P>
<BLOCKQUOTE><P><P class="docList">Linux returns most ICMP "destination unreachable" errors even for unconnected sockets, as long as the <TT>SO_BSDCOMPAT</TT> socket option is not enabled. All the ICMP "destination unreachable" errors from <A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig15">Figure A.15</A> are returned, except codes 0, 1, 4, 5, 11, and 12.</P></P><P><P class="docList">We return to this problem of asynchronous errors with UDP sockets in <A class="docLink" HREF="0131411551_ch28lev1sec7.html#ch28lev1sec7">Section 28.7</A> and show an easy way to obtain these errors on unconnected sockets using a daemon of our own.</P></P></BLOCKQUOTE>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch08lev1sec8.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch08lev1sec10.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
