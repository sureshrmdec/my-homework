<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="25.2 Signal-Driven I/O for Sockets"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch25lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch25lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch25lev1sec2"></A>
<H3 class="docSection1Title">25.2 Signal-Driven I/O for Sockets</H3>
<P class="docText">To use signal-driven I/O with a socket (<TT>SIGIO</TT>) requires the process to perform the following three steps:</P>
<A NAME="ch25pro01"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">A signal handler must be established for the <TT>SIGIO</TT> signal.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">The socket owner must be set, normally with the <TT>F_SETOWN</TT> command of <TT>fcntl</TT> (<A class="docLink" HREF="0131411551_ch07lev1sec11.html#ch07fig20">Figure 7.20</A>).</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">Signal-driven I/O must be enabled for the socket, normally with the <TT>F_SETFL</TT> command of <TT>fcntl</TT> to turn on the <TT>O_ASYNC</TT> flag (<A class="docLink" HREF="0131411551_ch07lev1sec11.html#ch07fig20">Figure 7.20</A>).</P>
<BLOCKQUOTE><P><P class="docList">The <TT>O_ASYNC</TT> flag is a relatively late addition to the POSIX specification. Very few systems have implemented support for the flag. In <A class="docLink" HREF="0131411551_ch25lev1sec3.html#ch25fig04">Figure 25.4</A>, we will enable signal-driven I/O with the <TT>FIOASYNC ioctl</TT> instead. Notice the bad choice of names by POSIX: The name <TT>O_SIGIO</TT> would have been a better choice for the new flag.</P></P><P><P class="docList">We should establish the signal handler <span class="docEmphasis">before</span> setting the owner of the socket. Under Berkeley-derived implementations, the order of the two function calls does not matter because the default action is to ignore <TT>SIGIO</TT>. Therefore, if we were to reverse the order of the two function calls, there is a small chance that a signal could be generated after the call to <TT>fcntl</TT> but before the call to <TT>signal</TT>; if that happens, the signal is just discarded. Under SVR4, however, <TT>SIGIO</TT> is defined to be <TT>SIGPOLL</TT> in the <TT>&lt;sys/signal.h&gt;</TT> header and the default action of <TT>SIGPOLL</TT> is to terminate the process. Therefore, under SVR4, we want to be certain the signal handler is installed before setting the owner of the socket.</P></P></BLOCKQUOTE>
</span></LI></OL></span>
<P class="docText">Although setting a socket for signal-driven I/O is easy, the hard part is determining what conditions cause <TT>SIGIO</TT> to be generated for the socket owner. This depends on the underlying protocol.</P>
<A NAME="ch25lev2sec1"></A>
<H4 class="docSection2Title"> <TT>SIGIO</TT> with UDP Sockets</H4>
<P class="docText">Using signal-driven I/O with UDP is simple. The signal is generated whenever</P>
<UL><LI><P class="docList">A datagram arrives for the socket</P></LI><LI><P class="docList">An asynchronous error occurs on the socket</P></LI></UL>
<P class="docText">Hence, when we catch <TT>SIGIO</TT> for a UDP socket, we call <TT>recvfrom</TT> to either read the datagram that arrived or to obtain the asynchronous error. We talked about asynchronous errors with regard to UDP sockets in <A class="docLink" HREF="0131411551_ch08lev1sec9.html#ch08lev1sec9">Section 8.9</A>. Recall that these are generated only if the UDP socket is connected.</P>
<BLOCKQUOTE><P><P class="docList"><TT>SIGIO</TT> is generated for these two conditions by the calls to <TT>sorwakeup</TT> on pp. 775, 779, and 784 of TCPv2.</P></P></BLOCKQUOTE>

<A NAME="ch25lev2sec2"></A>
<H4 class="docSection2Title"> <TT>SIGIO</TT> with TCP Sockets</H4>
<P class="docText">Unfortunately, signal-driven I/O is next to useless with a TCP socket. The problem is that the signal is generated too often, and the occurrence of the signal does not tell us what happened. As noted on p. 439 of TCPv2, the following conditions all cause <TT>SIGIO</TT> to be generated for a TCP socket (assuming signal-driven I/O is enabled):</P>
<UL><LI><P class="docList">A connection request has completed on a listening socket</P></LI><LI><P class="docList">A disconnect request has been initiated</P></LI><LI><P class="docList">A disconnect request has completed</P></LI><LI><P class="docList">Half of a connection has been shut down</P></LI><LI><P class="docList">Data has arrived on a socket</P></LI><LI><P class="docList">Data has been sent from a socket (i.e., the output buffer has free space)</P></LI><LI><P class="docList">An asynchronous error occurred</P></LI></UL>
<P class="docText">For example, if one is both reading from and writing to a TCP socket, <TT>SIGIO</TT> is generated when new data arrives and when data previously written is acknowledged, and there is no way to distinguish between the two in the signal handler. If <TT>SIGIO</TT> is used in this scenario, the TCP socket should be set to nonblocking to prevent a <TT>read</TT> or <TT>write</TT> from blocking. We should consider using <TT>SIGIO</TT> only with a listening TCP socket, because the only condition that generates <TT>SIGIO</TT> for a listening socket is the completion of a new connection.</P>
<P class="docText">The only real-world use of signal-driven I/O with sockets that the authors were able to find is the NTP server, which uses UDP. The main loop of the server receives a datagram from a client and sends a response. But, there is a non-negligible amount of processing to do for each client's request (more than our trivial echo server). It is important for the server to record accurate timestamps for each received datagram, since that value is returned to the client and then used by the client to calculate the RTT to the server. <A class="docLink" HREF="#ch25fig01">Figure 25.1</A> shows two ways to build such a UDP server.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch25fig01"></A>Figure 25.1. Two different ways to build a UDP server.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="450" HEIGHT="312" src="FILES/25fig01.gif" ALT="graphics/25fig01.gif"></p>

</CENTER>
<P class="docText">Most UDP servers (including our echo server from <A class="docLink" HREF="0131411551_ch08.html#ch08">Chapter 8</A>) are designed as shown at the left of this figure. But the NTP server uses the technique shown on the right side: When a new datagram arrives, it is read by the <TT>SIGIO</TT> handler, which also records the time at which the datagram arrived. The datagram is then placed on another queue within the process from which it will be removed by and processed by the main server loop. Although this complicates the server code, it provides accurate timestamps of arriving datagrams.</P>
<BLOCKQUOTE><P><P class="docList">Recall from <A class="docLink" HREF="0131411551_ch22lev1sec2.html#ch22fig04">Figure 22.4</A> that the process can set the <TT>IP_RECVDSTADDR</TT> socket option to receive the destination address of a received UDP datagram. One could argue that two additional pieces of information that should also be returned for a received UDP datagram are an indication of the received interface (which can differ from the destination address, if the host employs the common weak end system model) and the time at which the datagram arrived.</P></P><P><P class="docList">For IPv6, the <TT>IPV6_PKTINFO</TT> socket option (<A class="docLink" HREF="0131411551_ch22lev1sec8.html#ch22lev1sec8">Section 22.8</A>) returns the received interface. For IPv4, we discussed the <TT>IP_RECVIF</TT> socket option in <A class="docLink" HREF="0131411551_ch22lev1sec2.html#ch22lev1sec2">Section 22.2</A>.</P></P><P><P class="docList">FreeBSD also provides the <TT>SO_TIMESTAMP</TT> socket option, which returns the time at which the datagram was received as ancillary data in a <TT>timeval</TT> structure. Linux provides an <TT>SIOCGSTAMP ioctl</TT> that returns a <TT>timeval</TT> structure containing the time at which the datagram was received.</P></P></BLOCKQUOTE>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch25lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch25lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
