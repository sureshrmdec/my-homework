<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="24.3 'sockatmark' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch24lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch24lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch24lev1sec3"></A>
<H3 class="docSection1Title">24.3 <TT>sockatmark</TT> Function</H3>
<P class="docText">Whenever out-of-band data is received, there is an associated <span class="docEmphasis">out-of-band mark</span>. This is the position in the normal stream of data <span class="docEmphasis">at the sender</span> when the sending process sent the out-of-band byte. The receiving process determines whether or not it is at the out-of-band mark by calling the <TT>sockatmark</TT> function while it reads from the socket.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/socket.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int sockatmark(int</TT> <span class="docEmphasis">sockfd</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 1 if at out-of-band mark, 0 if not at mark, –1 on error</P></TD></TR></COLGROUP></TABLE></P>
<BLOCKQUOTE><P><P class="docList">This function is an invention of POSIX. POSIX is replacing many <TT>ioctls</TT> with functions.</P></P></BLOCKQUOTE>
<P class="docText"><A class="docLink" HREF="#ch24fig07">Figure 24.7</A> shows an implementation of this function using the commonly found <TT>SIOCATMARK ioctl</TT>.</P>

<H5 class="docExampleTitle"><A NAME="ch24fig07"></A>Figure 24.7 <TT>sockatmark</TT> function implemented using <TT>ioctl</TT>.</H5>
<P class="docText"><span class="docEmphasis">lib/sockatmark.c</span></P>

<PRE>
1 #include    "unp.h"

2 int
3 sockatmark(int fd)
4 {
5     int     flag;

6     if (ioctl(fd, SIOCATMARK, &amp;flag) &lt; 0)
7         return (-1);
8     return (flag != 0);
9 }
</PRE>

<P class="docText">The out-of-band mark applies regardless of whether the receiving process is receiving the out-of-band data inline (the <TT>SO_OOBINLINE</TT> socket option) or out-of-band (the <TT>MSG_OOB</TT> flag). One common use of the out-of-band mark is for the receiver to treat all the data as special until the mark is passed.</P>
<A NAME="ch24lev2sec3"></A>
<H4 class="docSection2Title"> Example</H4>
<P class="docText">We now show a simple example to illustrate the following two features of the out-of-band mark:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">The out-of-band mark always points one beyond the final byte of normal data. This means that, if the out-of-band data is received inline, <TT>sockatmark</TT> returns true if the next byte to be read is the byte that was sent with the <TT>MSG_OOB</TT> flag. Alternately, if the <TT>SO_OOBINLINE</TT> socket option is not enabled, then <TT>sockatmark</TT> returns true if the next byte of data is the first byte that was sent following the out-of-band data.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A read operation always stops at the out-of-band mark (pp. 519–520 of TCPv2). That is, if there are 100 bytes in the socket receive buffer, but only 5 bytes until the out-of-band mark, and the process performs a <TT>read</TT> asking for 100 bytes, only the 5 bytes up to the mark are returned. This forced stop at the mark is to allow the process to call <TT>sockatmark</TT> to determine if the buffer pointer is at the mark.</P></span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="#ch24fig08">Figure 24.8</A> is our sending program. It sends three bytes of normal data, one byte of out-of-band data, followed by another byte of normal data. There are no pauses between each output operation.</P>
<P class="docText"><A class="docLink" HREF="#ch24fig09">Figure 24.9</A> is the receiving program. This program does not use the <TT>SIGURG</TT> signal or <TT>select</TT>. Instead, it calls <TT>sockatmark</TT> to determine when the out-of-band byte is encountered.</P>

<H5 class="docExampleTitle"><A NAME="ch24fig08"></A>Figure 24.8 Sending program.</H5>
<P class="docText"><span class="docEmphasis">oob/tcpsend04.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;

 6     if (argc != 3)
 7         err_quit("usage: tcpsend04 &lt;host&gt; &lt;port#&gt;");

 8     sockfd = Tcp_connect(argv[1], argv[2]);

 9     Write(sockfd, "123", 3);
10     printf("wrote 3 bytes of normal data\n");

11     Send(sockfd, "4", 1, MSG_OOB);
12     printf("wrote 1 byte of OOB data\n");

13     Write(sockfd, "5", 1);
14     printf("wrote 1 byte of normal data\n");

15     exit(0);
16 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch24fig09"></A>Figure 24.9 Receiving program that calls <TT>sockatmark</TT>.</H5>
<P class="docText"><span class="docEmphasis">oob/tcprecv04.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     listenfd, connfd, n, on = 1;
 6     char    buff[100];

 7     if (argc == 2)
 8         listenfd = Tcp_listen(NULL, argv[1], NULL);
 9     else if (argc == 3)
10         listenfd = Tcp_listen(argv[1], argv[2], NULL);
11     else
12         err_quit("usage: tcprecv04 [ &lt;host&gt; ] &lt;port#&gt;");

13     Setsockopt(listenfd, SOL_SOCKET, SO_OOBINLINE, &amp;on, sizeof(on));

14     connfd = Accept(listenfd, NULL, NULL);
15     sleep(5);

16     for ( ; ; ) {
17         if (Sockatmark(connfd))
18             printf("at OOB mark\n");

19         if ( (n = Read(connfd, buff, sizeof(buff) - 1)) == 0) {
20             printf("received EOF\n");
21             exit(0);
22         }
23         buff[n] = 0;            /* null terminate */
24         printf("read %d bytes: %s\n", n, buff);
25     }
26 }
</PRE>

<A NAME="ch24lev3sec3"></A>
<H5 class="docSection3Title"> Set <TT>SO_OOBINLINE</TT> socket option</H5>
<p class="docText"><span class="docEmphasis"><TT>13</TT></span> We want to receive the out-of-band data inline, so we must set the <TT>SO_OOBINLINE</TT> socket option. But if we wait until <TT>accept</TT> returns and set the option on the connected socket, the three-way handshake is complete and out-of-band data may have already arrived. Therefore, we must set this option for the listening socket, knowing that all socket options carry over from the listening socket to the connected socket (<A class="docLink" HREF="0131411551_ch07lev1sec4.html#ch07lev1sec4">Section 7.4</A>).</p>

<A NAME="ch24lev3sec4"></A>
<H5 class="docSection3Title"> <TT>sleep</TT> after connection accepted</H5>
<p class="docText"><span class="docEmphasis"><TT>14–15</TT></span> The receiver sleeps after the connection is accepted to let all the data from the sender be received. This allows us to demonstrate that a <TT>read</TT> stops at the out-of-band mark, even though additional data is in the socket receive buffer.</p>

<A NAME="ch24lev3sec5"></A>
<H5 class="docSection3Title"> Read all data from sender</H5>
<p class="docText"><span class="docEmphasis"><TT>16–25</TT></span> The program calls <TT>read</TT> in a loop, printing the received data. But before calling <TT>read</TT>, <TT>sockatmark</TT> checks if the buffer pointer is at the out-of-band mark.</p>
<P class="docText">When we run this program, we get the following output:</P>
<pre>

</pre><pre>
freebsd4 % <span class="docEmphStrong">tcprecv04 6666</span>
read 3 bytes: 123
at OOB mark
read 2 bytes: 45
received EOF
</pre><pre>
</pre>
<P class="docText">Even though all the data has been received by the receiving TCP when <TT>read</TT> is called the first time (because the receiving process calls <TT>sleep</TT>), only three bytes are returned because the mark is encountered. The next byte read is the out-of-band byte (with a value of 4), because we told the kernel to place the out-of-band data inline.</P>


<A NAME="ch24lev2sec4"></A>
<H4 class="docSection2Title"> Example</H4>
<P class="docText">We now show another simple example to illustrate two additional features of out-of-band data, both of which we mentioned earlier.</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">TCP sends notification of out-of-band data (its urgent pointer), even though it is stopped by flow control from sending data.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A receiving process can be notified that the sender has sent out-of-band data (with the <TT>SIGURG</TT> signal or by <TT>select</TT>) <span class="docEmphasis">before</span> the out-of-band data arrives. If the process then calls <TT>recv</TT> specifying <TT>MSG_OOB</TT> and the out-of-band data has not arrived, an error of <TT>EWOULDBLOCK</TT> is returned.</P></span></LI></OL></span>
<P class="docText"><A class="docLink" HREF="#ch24fig10">Figure 24.10</A> is the sending program.</P>
<p class="docText"><span class="docEmphasis"><TT>9–19</TT></span> This process sets the size of its socket send buffer to 32,768, writes 16,384 bytes of normal data, and then sleeps for 5 seconds. We will see shortly that the receiver sets the size of its socket receive buffer to 4,096, so these operations by the sender guarantee that the sending TCP fills the receiver's socket receive buffer. The sender then sends 1 byte of out-of-band data, followed by 1,024 bytes of normal data, and terminates.</p>

<H5 class="docExampleTitle"><A NAME="ch24fig10"></A>Figure 24.10 Sending program.</H5>
<P class="docText"><span class="docEmphasis">oob/tcpsend05.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd, size;
 6     char    buff[16384];

 7     if (argc != 3)
 8         err_quit("usage: tcpsend05 &lt;host&gt; &lt;port#&gt;");

 9     sockfd = Tcp_connect(argv[1], argv[2]);

10     size = 32768;
11     Setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size));

12     Write(sockfd, buff, 16384);
13     printf("wrote 16384 bytes of normal data\n");
14     sleep(5);

15     Send(sockfd, "a", 1, MSG_OOB);
16     printf("wrote 1 byte of OOB data\n");

17     Write(sockfd, buff, 1024);
18     printf("wrote 1024 bytes of normal data\n");

19     exit(0);
20 }
</PRE>

<P class="docText"><A class="docLink" HREF="#ch24fig11">Figure 24.11</A> shows the receiving program.</P>
<p class="docText"><span class="docEmphasis"><TT>14–20</TT></span> The receiving process sets the size of the listening socket's receive buffer to 4,096. This size will carry over to the connected socket after the connection is established. The process then <TT>accepts</TT> the connection, establishes a signal handler for <TT>SIGURG</TT>, and establishes the owner of the socket. The main loop calls <TT>pause</TT> in an infinite loop.</p>
<p class="docText"><span class="docEmphasis"><TT>22–31</TT></span> The signal handler calls <TT>recv</TT> to read the out-of-band data.</p>
<P class="docText">When we start the receiver and then the sender, here is the output from the sender:</P>
<pre>

</pre><pre>
macosx % <span class="docEmphStrong">tcpsend05 freebsd4 5555</span>
wrote 16384 bytes of normal data
wrote 1 byte of OOB data
wrote 1024 bytes of normal data
</pre><pre>
</pre>
<P class="docText">As expected, all the data fits into the sender's socket send buffer, and then it terminates. Here is the output from the receiver:</P>
<pre>

</pre><pre>
freebsd4 % <span class="docEmphStrong">tcprecv05 5555</span>
SIGURG received
recv error: Resource temporarily unavailable
</pre><pre>
</pre>
<P class="docText">The error string printed by our <TT>err_sys</TT> function corresponds to <TT>EAGAIN</TT>, which is the same as <TT>EWOULDBLOCK</TT> in FreeBSD. TCP sends the out-of-band notification to the receiving TCP, which then generates the <TT>SIGURG</TT> signal for the receiving process. But when <TT>recv</TT> is called specifying the <TT>MSG_OOB</TT> flag, the out-of-band byte cannot be read.</P>

<H5 class="docExampleTitle"><A NAME="ch24fig11"></A>Figure 24.11 Receiving program.</H5>
<P class="docText"><span class="docEmphasis">oob/tcprecv05.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int     listenfd, connfd;

 3 void    sig_urg(int);

 4 int
 5 main(int argc, char **argv)
 6 {
 7     int     size;

 8     if (argc == 2)
 9         listenfd = Tcp_listen(NULL, argv[1], NULL);
10     else if (argc == 3)
11         listenfd = Tcp_listen(argv[1], argv[2], NULL);
12     else
13         err_quit("usage: tcprecv05 [ &lt;host&gt; ] &lt;port#&gt;");

14     size = 4096;
15     Setsockopt(listenfd, SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size));

16     connfd = Accept(listenfd, NULL, NULL);

17     Signal(SIGURG, sig_urg);
18     Fcntl(connfd, F_SETOWN, getpid());

19     for ( ;  ; )
20         pause();
21 }

22 void
23 sig_urg(int signo)
24 {
25     int     n;
26     char    buff[2048];

27     printf("SIGURG received\n");
28     n = Recv(connfd, buff, sizeof(buff) - 1, MSG_OOB);
29     buff[n] = 0;                /* null terminate */
30     printf("read %d OOB byte\n", n);
31 }
</PRE>

<P class="docText">The solution is for the receiver to make room in its socket receive buffer by reading the normal data that is available. This will cause its TCP to advertise a nonzero window to the sender, which will eventually let the sender transmit the out-of-band byte.</P>
<BLOCKQUOTE><P><P class="docList">We note two related issues in Berkeley-derived implementations (pp. 1016–1017 of TCPv2). First, even if the socket send buffer is full, an out-of-band byte is always accepted by the kernel from the process for sending to the peer. Second, when the process sends an out-of-band byte, a TCP segment is immediately sent that contains the urgent notification. All the normal TCP output checks (Nagle algorithm, silly-window avoidance, etc.) are bypassed.</P></P></BLOCKQUOTE>

<A NAME="ch24lev2sec5"></A>
<H4 class="docSection2Title"> Example</H4>
<P class="docText">Our next example demonstrates that there is only a single out-of-band mark for a given TCP connection, and if new out-of-band data arrives before the receiving process reads some existing out-of-band data, the previous mark is lost.</P>
<P class="docText"><A class="docLink" HREF="#ch24fig12">Figure 24.12</A> is the sending program, which is similar to <A class="docLink" HREF="#ch24fig08">Figure 24.8</A> with the addition of another <TT>send</TT> of out-of-band data, followed by one more <TT>write</TT> of normal data.</P>

<H5 class="docExampleTitle"><A NAME="ch24fig12"></A>Figure 24.12 Sending two out-of-band bytes in rapid succession.</H5>
<P class="docText"><span class="docEmphasis">oob/tcpsend06.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     sockfd;

 6     if (argc != 3)
 7         err_quit("usage: tcpsend06 &lt;host&gt; &lt;port#&gt;");

 8     sockfd = Tcp_connect(argv[1], argv[2]);

 9     Write(sockfd, "123", 3);
10     printf("wrote 3 bytes of normal data\n");

11     Send(sockfd, "4", 1, MSG_OOB);
12     printf("wrote 1 byte of OOB data\n");

13     Write(sockfd, "5", 1);
14     printf("wrote 1 byte of normal data\n");

15     Send(sockfd, "6", 1, MSG_OOB);
16     printf("wrote 1 byte of OOB data\n");

17     Write(sockfd, "7", 1);
18     printf("wrote 1 byte of normal data\n");

19     exit(0);
20 }
</PRE>

<P class="docText">There are no pauses in the sending, allowing all the data to be sent to the receiving TCP quickly.</P>
<P class="docText">The receiving program is identical to <A class="docLink" HREF="#ch24fig09">Figure 24.9</A>, which <TT>sleeps</TT> for five seconds after accepting the connection to allow the data to arrive at its TCP. Here is the receiving program's output:</P>
<pre>

</pre><pre>
freebsd4 % <span class="docEmphStrong">tcprecv06 5555</span>
read 5 bytes: 12345
at OOB mark
read 2 bytes: 67
received EOF
</pre><pre>
</pre>
<P class="docText">The arrival of the second out-of-band byte (the <TT>6</TT>) overwrites the mark that was stored when the first out-of-band byte arrived (the <TT>4</TT>). As we said, there is at most one out-of-band mark per TCP connection.</P>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch24lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch24lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
