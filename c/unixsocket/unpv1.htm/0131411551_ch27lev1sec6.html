<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="27.6 IPv6 Routing Header"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch27lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch27lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch27lev1sec6"></A>
<H3 class="docSection1Title">27.6 IPv6 Routing Header</H3>
<P class="docText">The IPv6 routing header is used for source routing in IPv6. The first two bytes of the routing header are the same as we showed in <A class="docLink" HREF="0131411551_ch27lev1sec5.html#ch27fig07">Figure 27.7</A>: a <span class="docEmphasis">next header</span> field followed by a <span class="docEmphasis">header extension length</span>. The next two bytes specify the <span class="docEmphasis">routing type</span> and the number of <span class="docEmphasis">segments left</span> (i.e., how many listed nodes are still to be visited). Only one type of routing header is specified, type 0, and we show its format in <A class="docLink" HREF="#ch27fig11">Figure 27.11</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch27fig11"></A>Figure 27.11. IPv6 routing header.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="475" HEIGHT="637" src="FILES/27fig11.gif" ALT="graphics/27fig11.gif"></p>

</CENTER>
<P class="docText">An unlimited number of addresses can appear in the routing header (limited only by packet length) and <span class="docEmphasis">segments left</span> must be equal to or less than the number of addresses in the header. RFC 2460 [Deering and Hinden 1998] specifies the details of how the header is processed as the packet travels to the final destination, along with a detailed example.</P>
<P class="docText">The routing header is normally specified as ancillary data with <TT>sendmsg</TT> and returned as ancillary data by <TT>recvmsg</TT>. Nothing special needs to be done by the application to send the header: just specify it as ancillary data in a call to <TT>sendmsg</TT>. To receive the routing header, the <TT>IPV6_RECVRTHDR</TT> socket option must be enabled, as in</P>
<pre>

</pre><pre>
const int on = 1;

setsockopt(sockfd, IPPROTO_IPV6, IPV6_RECVRTHDR, &amp;on, sizeof(on));
</pre><pre>
</pre>
<P class="docText"><A class="docLink" HREF="#ch27fig12">Figure 27.12</A> shows the format of the ancillary data object used to send and receive the routing header. Six functions are defined to create and process the routing header. The following three functions build an option to send:</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch27fig12"></A>Figure 27.12. Ancillary data object for IPv6 routing header.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="231" HEIGHT="150" src="FILES/27fig12.gif" ALT="graphics/27fig12.gif"></p>

</CENTER>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;netinet/in.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>socklen_t inet6_rth_space(int</TT> <span class="docEmphasis">type</span><TT>, int</TT> <span class="docEmphasis">segments</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: positive number of bytes if OK, 0 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void *inet6_rth_init(void *</TT><span class="docEmphasis">rthbuf</span><TT>, socklen_t</TT> <span class="docEmphasis">rthlen</span><TT>, int</TT> <span class="docEmphasis">type</span><TT>, int</TT> <span class="docEmphasis">segments</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: non-null pointer if OK, <TT>NULL</TT> on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_rth_add(void *</TT><span class="docEmphasis">rthbuf</span><TT>, const struct in6_addr *</TT><span class="docEmphasis">addr</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK, -1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>inet6_rth_space</TT> returns the number of bytes required to hold a routing header of the specified <span class="docEmphasis">type</span> (normally specified as <TT>IPV6_RTHDR_TYPE_0</TT>) with the specified number of <span class="docEmphasis">segments</span>.</P>
<P class="docText"><TT>inet6_rth_init</TT> initializes the buffer pointed to by <span class="docEmphasis">rthbuf</span> to contain a routing header of the specified <span class="docEmphasis">type</span> and the specified number of <span class="docEmphasis">segments</span>. The return value is the pointer to the buffer, and this pointer is then used as an argument to the next function. <TT>inet6_rth_init</TT> returns <TT>NULL</TT> if an error occurs, for instance, when the supplied buffer is not large enough.</P>
<P class="docText"><TT>inet6_rth_add</TT> adds the IPv6 address pointed to by <TT>addr</TT> to the end of the routing header being constructed. When successful, the <TT>segleft</TT> member of the routing header is updated to account for the new address.</P>
<P class="docText">The following three functions deal with a received routing header:</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;netinet/in.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_rth_reverse(const void *</TT><span class="docEmphasis">in</span><TT>, void *</TT><span class="docEmphasis">out</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK, -1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_rth_segments(const void *</TT><span class="docEmphasis">rthbuf</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: number of segments in routing header if OK, -1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>struct in6_addr *inet6_rth_getaddr(const void *</TT><span class="docEmphasis">rthbuf</span><TT>, int</TT> <span class="docEmphasis">index</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: non-null pointer if OK, <TT>NULL</TT> on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>inet6_rth_reverse</TT> takes a routing header that was received (pointed to by <span class="docEmphasis">in</span>) and creates a new routing header (in the buffer pointed to by <span class="docEmphasis">out</span>) that sends datagrams along the reverse of that path. The reversal can occur in place; that is, the <span class="docEmphasis">in</span> and <span class="docEmphasis">out</span> pointers can point to the same buffer.</P>
<P class="docText"><TT>inet6_rth_segments</TT> returns the number of segments in the routing header described by <span class="docEmphasis">rthbuf</span>. When successful, the return value is greater than zero.</P>
<P class="docText"><TT>inet6_rth_getaddr</TT> returns a pointer to the IPv6 address specified by <span class="docEmphasis">index</span> in the routing header described by <span class="docEmphasis">rthbuf. index</span> must have a value between zero and one less than the value returned by <TT>inet6_rth_segments</TT>, inclusive.</P>
<P class="docText">To demonstrate these options, we create a UDP client and server. The client, shown in <A class="docLink" HREF="#ch27fig13">Figure 27.13</A>, accepts a source route on the command line like the IPv4 TCP client we showed in <A class="docLink" HREF="0131411551_ch27lev1sec3.html#ch27fig06">Figure 27.6</A>; the server prints the received source route and reverses it to send back to the client.</P>
<A NAME="ch27lev3sec9"></A>
<H4 class="docSection2Title"> Create source route</H4>
<p class="docText"><span class="docEmphasis"><TT>11–21</TT></span> If more than one argument was supplied, all but the final argument form the source route. We first determine how much space the route header will require with <TT>inet6_rth_space</TT>, then allocate the necessary space with <TT>malloc</TT>. We initialize the allocated buffer with <TT>inet6_rth_init</TT>. Then, for each address in the source route, we convert it to numeric form using <TT>host_serv</TT> and add it to the source route using <TT>inet6_rth_add</TT>. This is very similar to our IPv4 TCP client, except that instead of our own helper functions, these library functions are provided by the system.</p>

<A NAME="ch27lev3sec10"></A>
<H4 class="docSection2Title"> Look up destination and create socket</H4>
<p class="docText"><span class="docEmphasis"><TT>22–23</TT></span> We use <TT>host_serv</TT> to look up the destination, and create a socket to use.</p>

<A NAME="ch27lev3sec11"></A>
<H4 class="docSection2Title"> Set sticky <TT>IPV6_RTHDR</TT> option and call worker function</H4>
<p class="docText"><span class="docEmphasis"><TT>24–27</TT></span> As we will see in <A class="docLink" HREF="0131411551_ch27lev1sec7.html#ch27lev1sec7">Section 27.7</A>, instead of sending the same ancillary data with every packet, we can use <TT>setsockopt</TT> to apply the routing header to every packet in the session. We only set this option if <TT>ptr</TT> is non-NULL, meaning that we allocated a route header earlier. Finally, we call the worker function, <TT>dg_cli</TT>, which we defined in <A class="docLink" HREF="0131411551_ch08lev1sec6.html#ch08fig08">Figure 8.8</A>.</p>

<H5 class="docExampleTitle"><A NAME="ch27fig13"></A>Figure 27.13 IPv6 UDP client with source route.</H5>
<P class="docText"><span class="docEmphasis">ipopts/udpcli01.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc,  char **argv)
 4  {
 5     int     c,  sockfd, len = 0;
 6     u_char *ptr = NULL;
 7     void     *rth;
 8     struct addrinfo *ai;

 9     if (argc &lt; 2)
10         err_quit("usage: udpcli01 [ &lt;hostname&gt; ... ] &lt;hostname&gt;");

11     if (argc &gt; 2)  {
12         int     i;

13         len = Inet6_rth_space(IPV6_RTHDR_TYPE_0, argc - 2);
14         ptr = Malloc(len);
15         Inet6_rth_init(ptr, len, IPV6_RTHDR_TYPE_0, argc - 2);
16         for (i = 1; i &lt; argc - 1; i++)  {
17             ai = Host_serv(argv[i], NULL, AF_INET6, 0);
18             Inet6_rth_add(ptr,
19                           &amp;((struct sockaddr_in6 *) ai-&gt;ai_addr)-&gt;sin6_addr);
20         }
21     }

22     ai = Host_serv(argv[argc - 1], SERV_PORT_STR, AF_INET6, SOCK_DGRAM);

23     sockfd = Socket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol);

24     if (ptr)  {
25         Setsockopt (sockfd, IPPROTO_IPV6, IPV6_RTHDR, ptr, len);
26         free (ptr);
27     }

28     dg_cli (stdin, sockfd, ai-&gt;ai_addr, ai-&gt;ai_addrlen); /* do it all */

29     exit (0);
30  }
</PRE>

<P class="docText">Our server is the same simple UDP server as before: open a socket and call <TT>dg_echo</TT>. The setup is trivial, so we do not show it. Instead, <A class="docLink" HREF="#ch27fig14">Figure 27.14</A> shows our <TT>dg_echo</TT> function, which prints the source route if one was received and reverses it for use in returning the packet.</P>

<A NAME="ch27lev3sec12"></A>
<H4 class="docSection2Title"> Turn on <TT>IPV6_RECVRTHDR</TT> option and set up <TT>msghdr</TT> struct</H4>
<p class="docText"><span class="docEmphasis"><TT>12–13</TT></span> To receive the incoming source route, we must set the <TT>IPV6_RECVRTHDR</TT> socket option. We must also use <TT>recvmsg</TT>, so we set up the unchanging fields of a <TT>msghdr</TT> structure.</p>

<A NAME="ch27lev3sec13"></A>
<H4 class="docSection2Title"> Set up modifiable fields and call <TT>recvmsg</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>21–24</TT></span> We set the length fields to the appropriate sizes and call <TT>recvmsg</TT>.</p>

<H5 class="docExampleTitle"><A NAME="ch27fig14"></A>Figure 27.14 <TT>dg_echo</TT> function that prints and reverses IPv6 source route.</H5>
<P class="docText"><span class="docEmphasis">ipopts/dgechoprintroute.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 void
 3 dg_echo(int sockfd, SA *pcliaddr, socklen_t clilen)
 4 {
 5     int     n;
 6     char    mesg[MAXLINE];
 7     int     on;
 8     char    control[MAXLINE];
 9     struct msghdr msg;
10     struct cmsghdr *cmsg;
11     struct iovec iov[1];

12     on = 1;
13     Setsockopt (sockfd, IPPROTO_IPV6, IPV6_RECVRTHDR, &amp;on, sizeof(on));

14     bzero (&amp;msg, sizeof(msg));
15     iov[0].iov_base = mesg;
16     msg.msg_name = pcliaddr;
17     msg.msg_iov = iov;
18     msg.msg_iovlen = 1;
19     msg.msg_control = control;
20     for ( ; ; )  {
21         msg.msg_namelen = clilen;
22         msg.msg_controllen = sizeof(control);
23         iov[0].iov_len = MAXLINE;
24         n = Recvmsg (sockfd, &amp;msg, 0);

25         for (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg != NULL;
26              cmsg = CMSG_NXTHDR (&amp;msg, cmsg))  {
27             if (cmsg-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;
28                 cmsg-&gt;cmsg_type == IPV6_RTHDR)  {
29                 inet6_srcrt_print(CMSG_DATA(cmsg));
30                 Inet6_rth_reverse(CMSG_DATA(cmsg), CMSG_DATA(cmsg));
31             }
32         }
33         iov[0].iov_len = n;
34         Sendmsg(sockfd, &amp;msg, 0);
35     }
36 }
</PRE>


<A NAME="ch27lev3sec14"></A>
<H4 class="docSection2Title"> Find and process route header</H4>
<p class="docText"><span class="docEmphasis"><TT>25–32</TT></span> We loop through the ancillary data using <TT>CMSG_FIRSTHDR</TT> and <TT>CMSG_NXTHDR</TT>. Even though we are only expecting one piece of ancillary data, it is good practice to loop like this. If we do find a routing header, we print it with our <TT>inet6_srcrt_print</TT> function (<A class="docLink" HREF="#ch27fig15">Figure 27.15</A>). We then reverse the route with <TT>inet6_rth_reverse</TT> so that we can use it to return the packet along the same path. In this case, <TT>inet6_rth_reverse</TT> works on the route in place, so that we can use the same ancillary data to send the return packet.</p>

<A NAME="ch27lev3sec15"></A>
<H4 class="docSection2Title"> Echo packet</H4>
<p class="docText"><span class="docEmphasis"><TT>33–34</TT></span> We set the length of the data to send, and use <TT>sendmsg</TT> to return the packet.</p>

<H5 class="docExampleTitle"><A NAME="ch27fig15"></A>Figure 27.15 <TT>inet6_srcrt_print</TT> function: prints a received IPv6 source route.</H5>
<P class="docText"><span class="docEmphasis">ipopts/sourceroute6.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 void
 3 inet6_srcrt_print(void *ptr)
 4 {
 5     int     i, segments;
 6     char    str[INET6_ADDRSTRLEN];

 7     segments = Inet6_rth_segments(ptr);
 8     printf("received source route: ");
 9     for (i = 0; i &lt; segments; i++)
10         printf ("%s ", Inet_ntop(AF_INET6, Inet6_rth_getaddr(ptr, i),
11                                  str, sizeof(str)));
12     printf("\n");
13  }
</PRE>

<P class="docText">Our <TT>inet6_srcrt_print</TT> is almost trivial, thanks to the IPv6 route helper functions.</P>

<A NAME="ch27lev3sec16"></A>
<H4 class="docSection2Title"> Determine number of segments in route</H4>
<p class="docText"><span class="docEmphasis"><TT>7</TT></span> We first use <TT>inet6_rth_segments</TT> to determine the number of segments present in the route.</p>

<A NAME="ch27lev3sec17"></A>
<H4 class="docSection2Title"> Loop through each segment</H4>
<p class="docText"><span class="docEmphasis"><TT>9–11</TT></span> We loop through all the segments, calling <TT>inet6_rth_getaddr</TT> for each one and converting the address to presentation form using <TT>inet_ntop</TT>.</p>
<P class="docText">Our client and server that handle IPv6 source routes do not need to know how the source route is formatted in the packet. The library functions the API provides hide the details of the packet format from us, yet give us all the flexibility we had when we built the option from scratch in IPv4.</P>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch27lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch27lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
