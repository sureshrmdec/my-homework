<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="16.4 Nonblocking 'connect:' Daytime Client"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch16lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch16lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch16lev1sec4"></A>
<H3 class="docSection1Title" id="162666-867">16.4 Nonblocking <TT>connect:</TT> Daytime Client</H3>
<P class="docText"><A class="docLink" HREF="#ch16fig11">Figure 16.11</A> shows our function <TT>connect_nonb</TT>, which performs a nonblocking <TT>connect</TT>. We replace the call to <TT>connect</TT> in <A class="docLink" HREF="0131411551_ch01lev1sec2.html#ch01fig05">Figure 1.5</A> with</P>
<pre>

</pre><pre>
if (connect_nonb(sockfd, (SA *) &amp;servaddr, sizeof(servaddr), 0) &lt; 0)
    err_sys("connect error");
</pre><pre>
</pre>
<P class="docText">The first three arguments are the normal arguments to <TT>connect</TT>, and the fourth argument is the number of seconds to wait for the connection to complete. A value of 0 implies no timeout on the <TT>select;</TT> hence, the kernel will use its normal TCP connection establishment timeout.</P>
<A NAME="ch16lev3sec14"></A>
<H4 class="docSection2Title"> Set socket nonblocking</H4>
<p class="docText"><span class="docEmphasis"><TT>9–10</TT></span> We call <TT>fcntl</TT> to set the socket to nonblocking.</p>
<p class="docText"><span class="docEmphasis"><TT>11–14</TT></span> We initiate the nonblocking <TT>connect</TT>. The error we expect is <TT>EINPROGRESS</TT>, indicating that the connection has started, but is not yet complete (p. 466 of TCPv2). Any other error is returned to the caller.</p>

<A NAME="ch16lev3sec15"></A>
<H4 class="docSection2Title"> Overlap processing with connection establishment</H4>
<p class="docText"><span class="docEmphasis"><TT>15</TT></span> At this point, we can do whatever we want while we wait for the connection to complete.</p>

<A NAME="ch16lev3sec16"></A>
<H4 class="docSection2Title"> Check for immediate completion</H4>
<p class="docText"><span class="docEmphasis"><TT>16–17</TT></span> If the nonblocking <TT>connect</TT> returns 0, the connection is complete. As we have said, this can occur when the server is on the same host as the client.</p>

<A NAME="ch16lev3sec17"></A>
<H4 class="docSection2Title"> Call <TT>select</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>18–24</TT></span> We call <TT>select</TT> and wait for the socket to be ready for either reading or writing. We zero out <TT>rset</TT>, turn on the bit corresponding to <TT>sockfd</TT> in this descriptor set, and then copy <TT>rset</TT> into <TT>wset</TT>. This assignment is probably a structure assignment since descriptor sets are normally represented as structures. We also initialize the <TT>timeval</TT> structure and then call <TT>select</TT>. If the caller specifies a fourth argument of 0 (uses the default timeout), we must specify a null pointer as the final argument to <TT>select</TT> and not a <TT>timeval</TT> structure with a value of 0 (which means do not wait at all).</p>

<A NAME="ch16lev3sec18"></A>
<H4 class="docSection2Title"> Handle timeouts</H4>
<p class="docText"><span class="docEmphasis"><TT>25–28</TT></span> If <TT>select</TT> returns 0, the timer expired, and we return <TT>ETIMEDOUT</TT> to the caller. We also close the socket, to prevent the three-way handshake from proceeding any further.</p>

<H5 class="docExampleTitle"><A NAME="ch16fig11"></A>Figure 16.11 Issue a nonblocking <TT>connect</TT>.</H5>
<P class="docText"><span class="docEmphasis">lib/connect_nonb.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 connect_nonb(int sockfd, const SA *saptr, socklen_t salen, int nsec)
 4 {
 5     int     flags, n, error;
 6     socklen_t len;
 7     fd_set rset, wset;
 8     struct timeval tval;

 9     flags = Fcntl(sockfd, F_GETFL, 0);
10     Fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

11     error = 0;
12     if ( (n = connect(sockfd, saptr, salen)) &lt; 0)
13         if (errno != EINPROGRESS)
14             return (-1);

15     /* Do whatever we want while the connect is taking place. */

16     if (n == 0)
17         goto done;               /* connect completed immediately */

18     FD_ZERO(&amp;rset);
19     FD_SET(sockfd, &amp;rset);
20     wset = rset;
21     tval.tv_sec = nsec;
22     tval.tv_usec = 0;

23     if ( (n = Select(sockfd + 1, &amp;rset, &amp;wset, NULL,
24                     nsec ? &amp;tval : NULL)) == 0) {
25         close(sockfd);          /* timeout */
26         errno = ETIMEDOUT;
27         return (-1);
28     }

29     if (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset)) {
30         len = sizeof(error);
31         if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0)
32             return (-1);     /* Solaris pending error */
33     } else
34         err_quit("select error: sockfd not set");

35   done:
36     Fcntl(sockfd, F_SETFL, flags);  /* restore file status flags */

37     if (error) {
38         close(sockfd);           /* just in case */
39         errno = error;
40         return (-1);
41     }
42     return (0);
43 }
</PRE>


<A NAME="ch16lev3sec19"></A>
<H4 class="docSection2Title"> Check for readability or writability</H4>
<p class="docText"><span class="docEmphasis"><TT>29–34</TT></span> If the descriptor is readable or writable, we call <TT>getsockopt</TT> to fetch the socket's pending error (<TT>SO_ERROR</TT>). If the connection completed successfully, this value will be 0. If the connection encountered an error, this value is the <TT>errno</TT> value corresponding to the connection error (e.g., <TT>ECONNREFUSED</TT>, <TT>ETIMEDOUT</TT>, etc.). We also encounter our first portability problem. If an error occurred, Berkeley-derived implementations of <TT>getsockopt</TT> return 0 with the pending error returned in our variable <TT>error</TT>. But Solaris causes <TT>getsockopt</TT> itself to return –1 with <TT>errno</TT> set to the pending error. Our code handles both scenarios.</p>

<A NAME="ch16lev3sec20"></A>
<H4 class="docSection2Title"> Turn off nonblocking and return</H4>
<p class="docText"><span class="docEmphasis"><TT>36–42</TT></span> We restore the file status flags and return. If our <TT>error</TT> variable is nonzero from <TT>getsockopt</TT>, that value is stored in <TT>errno</TT> and the function returns –1.</p>
<P class="docText">As we said earlier, there are portability problems with various socket implementations and nonblocking connects. First, it is possible for a connection to complete and for data to arrive from a peer before <TT>select</TT> is called. In this case, the socket will be both readable and writable on success, the same as if the connection had failed. Our code in <A class="docLink" HREF="#ch16fig11">Figure 16.11</A> handles this scenario by calling <TT>getsockopt</TT> and checking the pending error for the socket.</P>
<P class="docText">Next is determining whether the connection completed successfully or not, if we cannot assume that writability is the only way success is returned. Various solutions have been posted to Usenet. These would replace our call to <TT>getsockopt</TT> in <A class="docLink" HREF="#ch16fig11">Figure 16.11</A>.</P>
<A NAME="ch16pro01"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">Call <TT>getpeername</TT> instead of <TT>getsockopt</TT>. If this fails with <TT>ENOTCONN</TT>, the connection failed and we must then call <TT>getsockopt</TT> with <TT>SO_ERROR</TT> to fetch the pending error for the socket.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">Call <TT>read</TT> with a length of 0. If the <TT>read</TT> fails, the <TT>connect</TT> failed and the <TT>errno</TT> from <TT>read</TT> indicates the reason for the connection failure. When a connection succeeds, <TT>read</TT> should return 0.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">Call <TT>connect</TT> again. It should fail, and if the error is <TT>EISCONN</TT>, the socket is already connected and the first connection succeeded.</P>
</span></LI></OL></span>
<P class="docText">Unfortunately, nonblocking <TT>connects</TT> are one of the most nonportable areas of network programming. Be prepared for portability problems, especially with older implementations. A simpler technique is to create a thread (<A class="docLink" HREF="0131411551_ch26.html#ch26">Chapter 26</A>) to handle a connection.</P>

<A NAME="ch16lev2sec3"></A>
<H4 class="docSection2Title"> Interrupted <TT>connect</TT></H4>
<P class="docText">What happens if our call to <TT>connect</TT> on a normal blocking socket is interrupted, say, by a caught signal, before TCP's three-way handshake completes? Assuming the <TT>connect</TT> is not automatically restarted, it returns <TT>EINTR</TT>. But, we cannot call <TT>connect</TT> again to wait for the connection to complete. Doing so will return <TT>EADDRINUSE</TT>.</P>
<P class="docText">What we must do in this scenario is call <TT>select</TT>, just as we have done in this section for a nonblocking <TT>connect</TT>. <TT>select</TT> returns when the connection completes successfully (making the socket writable) or when the connection fails (making the socket readable and writable).</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch16lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch16lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
