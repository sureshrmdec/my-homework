<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="26.1 Introduction"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch26.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch26lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch26lev1sec1"></A>
<H3 class="docSection1Title">26.1 Introduction</H3>
<P class="docText">In the traditional Unix model, when a process needs something performed by another entity, it <TT>fork</TT>s a child process and lets the child perform the processing. Most network servers under Unix are written this way, as we have seen in our concurrent server examples: The parent <TT>accept</TT>s the connection, <TT>fork</TT>s a child, and the child handles the client.</P>
<P class="docText">While this paradigm has served well for many years, there are problems with <TT>fork</TT>:</P>
<UL><LI><P class="docList"><TT>fork</TT> is expensive. Memory is copied from the parent to the child, all descriptors are duplicated in the child, and so on. Current implementations use a technique called <span class="docEmphasis">copy-on-write</span>, which avoids a copy of the parent's data space to the child until the child needs its own copy. But, regardless of this optimization, <TT>fork</TT> is expensive.</P></LI><LI><P class="docList">IPC is required to pass information between the parent and child <span class="docEmphasis">after</span> the <TT>fork</TT>. Passing information from the parent to the child <span class="docEmphasis">before</span> the <TT>fork</TT> is easy, since the child starts with a copy of the parent's data space and with a copy of all the parent's descriptors. But, returning information from the child to the parent takes more work.</P></LI></UL>
<P class="docText">Threads help with both problems. Threads are sometimes called <span class="docEmphasis">lightweight processes</span> since a thread is "lighter weight" than a process. That is, thread creation can be 10–100 times faster than process creation.</P>
<P class="docText">All threads within a process share the same global memory. This makes the sharing of information easy between the threads, but along with this simplicity comes the problem of <span class="docEmphasis">synchronization</span>.</P>
<P class="docText">More than just the global variables are shared. All threads within a process share the following:</P>
<UL><LI><P class="docList">Process instructions</P></LI><LI><P class="docList">Most data</P></LI><LI><P class="docList">Open files (e.g., descriptors)</P></LI><LI><P class="docList">Signal handlers and signal dispositions</P></LI><LI><P class="docList">Current working directory</P></LI><LI><P class="docList">User and group IDs</P></LI></UL>
<P class="docText">But each thread has its own</P>
<UL><LI><P class="docList">Thread ID</P></LI><LI><P class="docList">Set of registers, including program counter and stack pointer</P></LI><LI><P class="docList">Stack (for local variables and return addresses)</P></LI><LI><P class="docList"><TT>errno</TT></P></LI><LI><P class="docList">Signal mask</P></LI><LI><P class="docList">Priority</P><BLOCKQUOTE><P><P class="docList">One analogy is to think of signal handlers as a type of thread as we discussed in <A class="docLink" HREF="0131411551_ch11lev1sec18.html#ch11lev1sec18">Section 11.18</A>. That is, in the traditional Unix model, we have the main flow of execution (one thread) and a signal handler (another thread). If the main flow is in the middle of updating a linked list when a signal occurs, and the signal handler also tries to update the linked list, havoc normally results. The main flow and signal handler share the same global variables, but each has its own stack.</P></P></BLOCKQUOTE></LI></UL>
<P class="docText">In this text, we cover POSIX threads, also called <span class="docEmphasis">Pthreads</span>. These were standardized in 1995 as part of the POSIX.1c standard and most versions of Unix will support them in the future. We will see that all the Pthread functions begin with <TT>pthread_</TT>. This chapter is an introduction to threads, so that we can use threads in our network programs. For additional details see [Butenhof 1997].</P>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch26.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch26lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
