<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="31.6 Transport Provider Interface (TPI)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch31lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch31lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch31lev1sec6"></A>
<H3 class="docSection1Title">31.6 Transport Provider Interface (TPI)</H3>
<P class="docText">In <A class="docLink" HREF="0131411551_ch31lev1sec2.html#ch31fig03">Figure 31.3</A>, we showed that TPI is the service interface into the transport layer from above. Both sockets and XTI use this interface in a STREAMS environment. In <A class="docLink" HREF="0131411551_ch31lev1sec2.html#ch31fig03">Figure 31.3</A>, it is a combination of the sockets library and <TT>sockmod</TT>, along with a combination of the XTI library and <TT>timod</TT>, that exchange TPI messages with TCP and UDP.</P>
<P class="docText">TPI is a <span class="docEmphasis">message-based</span> interface. It defines the messages that are exchanged up and down a stream between the application (e.g., the sockets library) and the transport layer: the format of these messages and what operation each message performs. In many instances, the application sends a request to the provider (such as "bind this local address") and the provider sends back a response ("OK" or "error"). Some events occur asynchronously at the provider (the arrival of a connection request for a server), causing a message or a signal to be sent up the stream.</P>
<P class="docText">We are able to bypass both sockets and XTI and use TPI directly. In this section, we will rewrite our simple daytime client using TPI instead of sockets (<A class="docLink" HREF="0131411551_ch01lev1sec2.html#ch01fig05">Figure 1.5</A>). Using programming languages as an analogy, using sockets is like programming in a high-level language such as C or Pascal, while using TPI directly is like programming in assembly language. We are not advocating the use of TPI directly in real applications. But examining how TPI works and developing this example give us a better understanding of how the sockets library works in a STREAMS environment.</P>
<P class="docText"><A class="docLink" HREF="#ch31fig07">Figure 31.7</A> is our <TT>tpi_daytime.h</TT> header.</P>

<H5 class="docExampleTitle"><A NAME="ch31fig07"></A>Figure 31.7 Our <TT>tpi_daytime.h</TT> header.</H5>
<P class="docText"><span class="docEmphasis">streams/tpi_daytime.h</span></P>

<PRE>
1 #include     "unpxti.h"
2 #include     &lt;sys/stream.h&gt;
3 #include     &lt;sys/tihdr.h&gt;

4 void    tpi_bind(int, const void *, size_t);
5 void    tpi_connect(int, const void *, size_t);
6 ssize_t tpi_read(int, void *, size_t);
7 void    tpi_close(int);
</PRE>

<P class="docText">We need to include one additional STREAMS header along with <TT>&lt;sys/tihdr.h&gt;</TT>, which contains the definitions of the structures for all TPI messages.</P>
<P class="docText"><A class="docLink" HREF="#ch31fig08">Figure 31.8</A> is the <TT>main</TT> function for our daytime client.</P>

<H5 class="docExampleTitle"><A NAME="ch31fig08"></A>Figure 31.8 <TT>main</TT> function for our daytime client written to TPI.</H5>
<P class="docText"><span class="docEmphasis">streams/tpi_daytime.c</span></P>

<PRE>
 1 #include    "tpi_daytime.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     fd, n;
 6     char    recvline[MAXLINE + 1];
 7     struct sockaddr_in myaddr, servaddr;

 8     if (argc != 2)
 9         err_quit("usage: tpi_daytime &lt;IPaddress&gt;");

10     fd = Open(XTI_TCP, O_RDWR, 0);

11         /* bind any local address */
12     bzero(&amp;myaddr, sizeof(myaddr));
13     myaddr.sin_family = AF_INET;
14     myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
15     myaddr.sin_port = htons(0);

16     tpi_bind(fd, &amp;myaddr, sizeof(struct sockaddr_in));

17         /* fill in server's address */
18     bzero(&amp;servaddr, sizeof(servaddr));
19     servaddr.sin_family = AF_INET;
20     servaddr.sin_port = htons(13);  /* daytime server */
21     Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr);

22     tpi_connect(fd, &amp;servaddr, sizeof(struct sockaddr_in));

23     for ( ; ; ) {
24         if ( (n = tpi_read(fd, recvline, MAXLINE)) &lt;= 0) {
25             if (n == 0)
26                 break;
27             else
28                 err_sys("tpi_read error");
29         }
30         recvline[n] = 0;        /* null terminate */
31         fputs(recvline, stdout);
32     }
33     tpi_close(fd);
34     exit(0);
35 }
</PRE>

<A NAME="ch31lev3sec1"></A>
<H4 class="docSection2Title"> Open transport provider, bind local address</H4>
<p class="docText"><span class="docEmphasis"><TT>10–16</TT></span> We open the device corresponding to the transport provider (normally <TT>/dev/tcp</TT>). We fill in an Internet socket address structure with <TT>INADDR_ANY</TT> and a port of 0, telling TCP to bind any local address to our endpoint. We call our own function <TT>tpi_bind</TT> (shown shortly) to do the bind.</p>

<A NAME="ch31lev3sec2"></A>
<H4 class="docSection2Title"> Fill in server's address, establish connection</H4>
<p class="docText"><span class="docEmphasis"><TT>17–22</TT></span> We fill in another Internet socket address structure with the server's IP address (taken from the command line) and port (13). We call our <TT>tpi_connect</TT> function to establish the connection.</p>

<A NAME="ch31lev3sec3"></A>
<H4 class="docSection2Title"> Read data from server, copy to standard output</H4>
<p class="docText"><span class="docEmphasis"><TT>23–33</TT></span> As in our other daytime clients, we just copy data from the connection to standard output, stopping when we receive the EOF from the server (e.g., the FIN). We then call our <TT>tpi_close</TT> function to close our endpoint.</p>
<P class="docText">Our <TT>tpi_bind</TT> function is shown in <A class="docLink" HREF="#ch31fig09">Figure 31.9</A>.</P>

<A NAME="ch31lev3sec4"></A>
<H4 class="docSection2Title"> Fill in <TT>T_bind_req</TT> structure</H4>
<p class="docText"><span class="docEmphasis"><TT>16–20</TT></span> The <TT>&lt;sys/tihdr.h&gt;</TT> header defines the <TT>T_bind_req</TT> structure.</p>
<pre>

</pre><pre>
struct T_bind_req {
  t_scalar_t     PRIM_type;      /* T_BIND_REQ */
  t_scalar_t     ADDR_length;    /* address length */
  t_scalar_t     ADDR_offset;    /* address offset */
  t_uscalar_t    CONIND_number;  /* connect indications requested */
      /* followed by the protocol address for bind */
};
</pre><pre>
</pre>
<P class="docText">All TPI requests are defined as a structure that begins with a long integer type field. We define our own <TT>bind_req</TT> structure that begins with the <TT>T_bind_req</TT> structure, followed by a buffer containing the local address to be bound. TPI says nothing about the contents of this buffer; it is defined by the provider. TCP providers expect this buffer to contain a <TT>sockaddr_in</TT> structure.</P>
<P class="docText">We fill in the <TT>T_bind_req</TT> structure, setting the <TT>ADDR_length</TT> member to the size of the address (16 bytes for an Internet socket address structure) and <TT>ADDR_offset</TT> to the byte offset of the address (it immediately follows the <TT>T_bind_req</TT> structure). We are not guaranteed that this location is suitably aligned for the <TT>sockaddr_in</TT> structure that is stored there, so we call <TT>memcpy</TT> to copy the caller's structure into our <TT>bind_req</TT> structure. We set <TT>CONIND_number</TT> to 0 because we are a client, not a server.</P>

<A NAME="ch31lev3sec5"></A>
<H4 class="docSection2Title"> Call <TT>putmsg</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>21–23</TT></span> TPI requires the structure that we just built to be passed to the provider as one <TT>M_PROTO</TT> message. We therefore call <TT>putmsg</TT>, specifying our <TT>bind_req</TT> structure as the control information, with no data and with a flag of 0.</p>

<A NAME="ch31lev3sec6"></A>
<H4 class="docSection2Title"> Call <TT>getmsg</TT> to read high-priority message</H4>
<p class="docText"><span class="docEmphasis"><TT>24–30</TT></span> The response to our <TT>T_BIND_REQ</TT> request will be either a <TT>T_BIND_ACK</TT> message or a <TT>T_ERROR_ACK</TT> message. These acknowledgment messages are sent as high-priority messages (<TT>M_PCPROTO</TT>) so we read them using <TT>getmsg</TT> with a flag of <TT>RS_HIPRI</TT>. Since the reply is a high-priority message, it will bypass any normal-priority messages on the stream.</p>

<H5 class="docExampleTitle"><A NAME="ch31fig09"></A>Figure 31.9 <TT>tpi_bind</TT> function: binds a local address to an endpoint.</H5>
<P class="docText"><span class="docEmphasis">streams/tpi_bind.c</span></P>

<PRE>
 1 #include    "tpi_daytime.h"

 2 void
 3 tpi_bind(int fd, const void *addr, size_t addrlen)
 4 {
 5     struct {
 6         struct T_bind_req msg_hdr;
 7         char    addr[128];
 8     } bind_req;
 9     struct {
10         struct T_bind_ack msg_hdr;
11         char    addr[128];
12     } bind_ack;
13     struct strbuf ctlbuf;
14     struct T_error_ack *error_ack;
15     int     flags;

16     bind_req.msg_hdr.PRIM_type = T_BIND_REQ;
17     bind_req.msg_hdr.ADDR_length = addrlen;
18     bind_req.msg_hdr.ADDR_offset = sizeof(struct T_bind_req);
19     bind_req.msg_hdr.CONIND_number = 0;
20     memcpy(bind_req.addr, addr, addrlen);   /* sockaddr_in{} */

21     ctlbuf.len = sizeof(struct T_bind_req) + addrlen;
22     ctlbuf.buf = (char *) &amp;bind_req;
23     Putmsg(fd, &amp;ctlbuf, NULL, 0);

24     ctlbuf.maxlen = sizeof(bind_ack);
25     ctlbuf.len = 0;
26     ctlbuf.buf = (char *) &amp;bind_ack;
27     flags = RS_HIPRI;
28     Getmsg(fd, &amp;ctlbuf, NULL, &amp;flags);

29     if (ctlbuf.len &lt; (int) sizeof(long))
30         err_quit("bad length from getmsg");

31     switch (bind_ack.msg_hdr.PRIM_type) {
32     case T_BIND_ACK:
33         return;

34     case T_ERROR_ACK:
35         if (ctlbuf.len &lt; (int) sizeof(struct T_error_ack))
36             err_quit("bad length for T_ERROR_ACK");
37         error_ack = (struct T_error_ack *) &amp;bind_ack.msg_hdr;
38         err_quit("T_ERROR_ACK from bind (%d, %d)",
39                  error_ack-&gt;TLI_error, error_ack-&gt;UNIX_error);

40     default:
41         err_quit("unexpected message type: %d", bind_ack.msg_hdr.PRIM_type);
42     }
43 }
</PRE>

<P class="docText">These two messages are as follows:</P>
<pre>

</pre><pre>
struct T_bind_ack {
  t_scalar_t     PRIM_type;     /* T_BIND_ACK */
  t_scalar_t     ADDR_length;   /* address length */
  t_scalar_t     ADDR_offset;   /* address offset */
  t_uscalar_t    CONIND_number; /* connect ind to be queued */
      /* followed by the bound address */
};

struct T_error_ack {
  t_scalar_t     PRIM_type;     /* T_ERROR_ACK */
  t_scalar_t     ERROR_prim     /* primitive in error */
  t_scalar_t     TLI_error;     /* TLI error code */
  t_scalar_t     UNIX_error;    /* UNIX error code */
};
</pre><pre>
</pre>
<P class="docText">All these messages begin with the type, so we can read the reply assuming it is a <TT>T_BIND_ACK</TT> message, look at the type, and process the message accordingly. We do not expect any data from the provider, so we specify a null pointer as the third argument to <TT>getmsg</TT>.</P>
<BLOCKQUOTE><P><P class="docList">When we verify that the amount of control information returned is at least the size of a long integer, we must be careful to cast the <TT>sizeof</TT> value to an integer. The <TT>sizeof</TT> operator returns an unsigned integer value, but it is possible for the returned <TT>len</TT> field to be –1. But since the less-than comparison is comparing a signed value on the left to an unsigned value on the right, the compiler casts the signed value to an unsigned value. On a two's-complement architecture, –1, considered as an unsigned value, is very large, causing –1 to be greater than 4 (if we assume a long integer occupies 4 bytes).</P></P></BLOCKQUOTE>

<A NAME="ch31lev3sec7"></A>
<H4 class="docSection2Title"> Process reply</H4>
<p class="docText"><span class="docEmphasis"><TT>31–33</TT></span> If the reply is <TT>T_BIND_ACK</TT>, the bind was successful and we return. The actual address that was bound to the endpoint is returned in the <TT>addr</TT> member of our <TT>bind_ack</TT> structure, which we ignore.</p>
<p class="docText"><span class="docEmphasis"><TT>34–39</TT></span> If the reply is <TT>T_ERROR_ACK</TT>, we verify that the entire message was received and then print the three return values in the structure. In this simple program, we terminate when an error occurs; we do not return to the caller.</p>
<P class="docText">We can see these errors from the bind request by changing our <TT>main</TT> function to bind some port other than 0. For example, if we try to bind port 1 (which requires superuser privileges, since it is a port less than 1024), we get</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">tpi_daytime 127.0.0.1</span>
T_ERROR_ACK from bind (3, 0)
</pre><pre>
</pre>
<P class="docText">The error <TT>TACCES</TT> has the value 3 on this system. If we change the port to a value greater than 1023, but one that is currently in use by another TCP endpoint, we get</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">tpi_daytime 127.0.0.1</span>
T_ERROR_ACK from bind (23, 0)
</pre><pre>
</pre>
<P class="docText">The error <TT>TADDRBUSY</TT> has the value 23 on this system.</P>
<P class="docText">The next function, shown in <A class="docLink" HREF="#ch31fig10">Figure 31.10</A>, is <TT>tpi_connect</TT>, which establishes the connection with the server.</P>

<A NAME="ch31lev3sec8"></A>
<H4 class="docSection2Title"> Fill in request structure and send to provider</H4>
<p class="docText"><span class="docEmphasis"><TT>18–26</TT></span> TPI defines a <TT>T_conn_req</TT> structure that contains the protocol address and options for the connection.</p>
<pre>

</pre><pre>
struct T_conn_req {
  t_scalar_t     PRIM_type;   /* T_CONN_REQ */
  t_scalar_t     DEST_length; /* destination address length */
  t_scalar_t     DEST_offset; /* destination address offset */
  t_scalar_t     OPT_length;  /* options length */
  t_scalar_t     OPT_offset;  /* options offset */
      /* followed by the protocol address and options for connection */
};
</pre><pre>
</pre>
<P class="docText">As in our <TT>tpi_bind</TT> function, we define our own structure named <TT>conn_req</TT>, which includes a <TT>T_conn_req</TT> structure along with room for the protocol address. We fill in our <TT>conn_req</TT> structure, setting the two members dealing with options to 0. We call <TT>putmsg</TT> with only control information and a flag of 0 to send an <TT>M_PROTO</TT> message down the stream.</P>

<H5 class="docExampleTitle"><A NAME="ch31fig10"></A>Figure 31.10 <TT>tpi_connect</TT> function: establishes connection with server.</H5>
<P class="docText"><span class="docEmphasis">streams/tpi_connect.c</span></P>

<PRE>
 1 #include    "tpi_daytime.h"

 2 void
 3 tpi_connect(int fd, const void *addr, size_t addrlen)
 4 {
 5     struct {
 6         struct T_conn_req msg_hdr;
 7         char    addr[128];
 8     } conn_req;
 9     struct {
10         struct T_conn_con msg_hdr;
11         char    addr[128];
12     } conn_con;
13     struct strbuf ctlbuf;
14     union T_primitives rcvbuf;
15     struct T_error_ack *error_ack;
16     struct T_discon_ind *discon_ind;
17     int     flags;

18     conn_req.msg_hdr.PRIM_type = T_CONN_REQ;
19     conn_req.msg_hdr.DEST_length = addrlen;
20     conn_req.msg_hdr.DEST_offset = sizeof(struct T_conn_req);
21     conn_req.msg_hdr.OPT_length = 0;
22     conn_req.msg_hdr.OPT_offset = 0;
23     memcpy(conn_req.addr, addr, addrlen);   /* sockaddr_in{} */

24     ctlbuf.len = sizeof(struct T_conn_req) + addrlen;
25     ctlbuf.buf = (char *) &amp;conn_req;
26     Putmsg(fd, &amp;ctlbuf, NULL, 0);

27     ctlbuf.maxlen = sizeof(union T_primitives);
28     ctlbuf.len = 0;
29     ctlbuf.buf = (char *) &amp;rcvbuf;
30     flags = RS_HIPRI;
31     Getmsg(fd, &amp;ctlbuf, NULL, &amp;flags);

32     if (ctlbuf.len &lt; (int) sizeof(long))
33         err_quit("tpi_connect: bad length from getmsg");

34     switch (rcvbuf.type) {
35     case T_OK_ACK:
36         break;

37     case T_ERROR_ACK:
38         if (ctlbuf.len &lt; (int) sizeof(struct T_error_ack))
39             err_quit("tpi_connect: bad length for T_ERROR_ACK");
40         error_ack = (struct T_error_ack *) &amp;rcvbuf;
41         err_quit("tpi_connect: T_ERROR_ACK from conn (%d, %d)",
42                  error_ack-&gt;TLI_error, error_ack-&gt;UNIX_error);

43     default:
44         err_quit("tpi_connect: unexpected message type: %d", rcvbuf.type);
45     }

46     ctlbuf.maxlen = sizeof(conn_con);
47     ctlbuf.len = 0;
48     ctlbuf.buf = (char *) &amp;conn_con;
49     flags = 0;
50     Getmsg(fd, &amp;ctlbuf, NULL, &amp;flags);

51     if (ctlbuf.len &lt; (int) sizeof(long))
52         err_quit("tpi_connect2: bad length from getmsg");

53     switch (conn_con.msg_hdr.PRIM_type) {
54     case T_CONN_CON:
55         break;

56     case T_DISCON_IND:
57         if (ctlbuf.len &lt; (int) sizeof(struct T_discon_ind))
58             err_quit("tpi_connect2: bad length for T_DISCON_IND");
59         discon_ind = (struct T_discon_ind *) &amp;conn_con.msg_hdr;
60         err_quit("tpi_connect2: T_DISCON_IND from conn (%d)",
61                  discon_ind-&gt;DISCON_reason);

62     default:
63         err_quit("tpi_connect2: unexpected message type: %d",
64                  conn_con.msg_hdr.PRIM_type);
65     }
66 }
</PRE>


<A NAME="ch31lev3sec9"></A>
<H4 class="docSection2Title"> Read response</H4>
<p class="docText"><span class="docEmphasis"><TT>27–45</TT></span> We call <TT>getmsg</TT>, expecting to receive either a <TT>T_OK_ACK</TT> message if the connection establishment was started, or a <TT>T_ERROR_ACK</TT> message (which we showed earlier).</p>
<pre>

</pre><pre>
struct T_ok_ack {
  t_scalar_t    PRIM_type;        /* T_OK_ACK */
  t_scalar_t    CORRECT_prim;     /* correct primitive */
};
</pre><pre>
</pre>
<P class="docText">In case of an error, we terminate. Since we do not know what type of message we will receive, a <TT>union</TT> named <TT>T_primitives</TT> is defined as the union of all the possible requests and replies, and we allocate one of these that we use as the input buffer for the control information when we call <TT>getmsg</TT>.</P>

<A NAME="ch31lev3sec10"></A>
<H4 class="docSection2Title"> Wait for connection to be established</H4>
<p class="docText"><span class="docEmphasis"><TT>46–65</TT></span> The successful <TT>T_OK_ACK</TT> message that was just received only tells us that the connection establishment was started. We must now wait for a <TT>T_CONN_CON</TT> message to tell us that the other end has confirmed the connection request.</p>
<pre>

</pre><pre>
struct T_conn_con {
  t_scalar_t     PRIM_type;      /* T_CONN_CON */
  t_scalar_t     RES_length;     /* responding address length */
  t_scalar_t     RES_offset;     /* responding address offset */
  t_scalar_t     OPT_length;     /* option length */
  t_scalar_t     OPT_offset;     /* option offset */
      /* followed by peer's protocol address and options */
};
</pre><pre>
</pre>
<P class="docText">We call <TT>getmsg</TT> again, but the expected message is sent as an <TT>M_PROTO</TT> message, not an <TT>M_PCPROTO</TT> message, so we set the flags to 0. If we receive the <TT>T_CONN_CON</TT> message, the connection is established and we return, but if the connection was not established (either the peer process was not running, a timeout occurred, or whatever), a <TT>T_DISCON_IND</TT> message is sent up the stream instead.</P>
<pre>

</pre><pre>
struct T_discon_ind {
  t_scalar_t     PRIM_type;      /* T_DISCON_IND */
  t_scalar_t     DISCON_reason;  /* disconnect reason */
  t_scalar_t     SEQ_number;     /* sequence number */
};
</pre><pre>
</pre>
<P class="docText">We can see the different errors that are returned by the provider. We first specify the IP address of a host that is not running the daytime server.</P>
<pre>

</pre><pre>
solaris % tpi_daytime 192.168.1.10
tpi_connect2: T_DISCON_IND from conn (146)
</pre><pre>
</pre>
<P class="docText">The error of 146 corresponds to <TT>ECONNREFUSED</TT>. Next, we specify an IP address that is not connected to the Internet.</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">tpi_daytime 192.3.4.5</span>
tpi_connect2: T_DISCON_IND from conn (145)
</pre><pre>
</pre>
<P class="docText">The error this time is <TT>ETIMEDOUT</TT>. But if we run our program again, specifying the same IP address, we get a different error.</P>
<pre>

</pre><pre>
solaris % <span class="docEmphStrong">tpi_daytime 192.3.4.5</span>
tpi_connect2: T_DISCON_IND from conn (148)
</pre><pre>
</pre>
<P class="docText">The error this time is <TT>EHOSTUNREACH</TT>. The difference in the last two results is that the first time, no ICMP "host unreachable" errors were returned, while the next time, this error was returned.</P>
<P class="docText">The next function is <TT>tpi_read</TT>, shown in <A class="docLink" HREF="#ch31fig11">Figure 31.11</A>. It reads data from a stream.</P>

<H5 class="docExampleTitle"><A NAME="ch31fig11"></A>Figure 31.11 <TT>tpi_read</TT> function: reads data from a stream.</H5>
<P class="docText"><span class="docEmphasis">streams/tpi_read.c</span></P>

<PRE>
 1 #include    "tpi_daytime.h"

 2 ssize_t
 3 tpi_read(int fd, void *buf, size_t len)
 4 {
 5     struct strbuf ctlbuf;
 6     struct strbuf datbuf;
 7     union T_primitives rcvbuf;
 8     int     flags;

 9     ctlbuf.maxlen = sizeof(union T_primitives);
10     ctlbuf.buf = (char *) &amp;rcvbuf;

11     datbuf.maxlen = len;
12     datbuf.buf = buf;
13     datbuf.len = 0;

14     flags = 0;
15     Getmsg(fd, &amp;ctlbuf, &amp;datbuf, &amp;flags);

16     if (ctlbuf.len &gt;= (int) sizeof(long)) {
17         if (rcvbuf.type == T_DATA_IND)
18             return (datbuf.len);
19         else if (rcvbuf.type == T_ORDREL_IND)
20             return (0);
21         else
22             err_quit("tpi_read: unexpected type %d", rcvbuf.type);
23     } else if (ctlbuf.len == -1)
24         return (datbuf.len);
25     else
26         err_quit("tpi_read: bad length from getmsg");
27 }
</PRE>


<A NAME="ch31lev3sec11"></A>
<H4 class="docSection2Title"> Read control and data; process reply</H4>
<p class="docText"><span class="docEmphasis"><TT>9–26</TT></span> This time, we call <TT>getmsg</TT> to read both control information and data. The <TT>strbuf</TT> structure for the data points to the caller's buffer. Four different scenarios can occur on the stream:</p>
<UL><LI><P class="docList">The data can arrive as an <TT>M_DATA</TT> message, which is indicated by the returned control length being set to –1. The data was copied into the caller's buffer by <TT>getmsg</TT>, and we just return the length of this data as the return value of the function.</P></LI><LI><P class="docList">The data can arrive as a <TT>T_DATA_IND</TT> message, in which case, the control information will be a <TT>T_data_ind</TT> structure.</P><pre>

</pre><pre>
struct T_data_ind {
  t_scalar_t    PRIM_type;     /* T_DATA_IND */
  t_scalar_t    MORE_flag;     /* more data */
};
</pre><pre>
</pre><P class="docList">If this message is returned, we ignore the <TT>MORE_flag</TT> member (it will never be set for a stream protocol such as TCP) and just return the length of the data that was copied into the caller's buffer by <TT>getmsg</TT>.</P></LI><LI><P class="docList">A <TT>T_ORDREL_IND</TT> message is returned if all the data has been consumed and the next item is a FIN.</P><pre>

</pre><pre>
struct T_ordrel_ind {
  t_scalar_t    PRIM_type;     /* T_ORDREL_IND */
};
</pre><pre>
</pre><P class="docList">This is the orderly release. We just return 0, indicating to the caller that the EOF has been encountered on the connection.</P></LI><LI><P class="docList">A <TT>T_DISCON_IND</TT> message is returned if a disconnect has been received.</P></LI></UL>
<P class="docText">Our final function is <TT>tpi_close</TT>, shown in <A class="docLink" HREF="#ch31fig12">Figure 31.12</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch31fig12"></A>Figure 31.12 <TT>tpi_close</TT> function: sends an orderly release to the peer.</H5>
<P class="docText"><span class="docEmphasis">streams/tpi_close.c</span></P>

<PRE>
 1 #include    "tpi_daytime.h"

 2 void
 3 tpi_close(int fd)
 4 {
 5     struct T_ordrel_req ordrel_req;
 6     struct strbuf ctlbuf;

 7     ordrel_req.PRIM_type = T_ORDREL_REQ;

 8     ctlbuf.len = sizeof(struct T_ordrel_req);
 9     ctlbuf.buf = (char *) &amp;ordrel_req;
10     Putmsg(fd, &amp;ctlbuf, NULL, 0);

11     Close(fd);
12 }
</PRE>


<A NAME="ch31lev3sec12"></A>
<H4 class="docSection2Title"> Send orderly release to peer</H4>
<p class="docText"><span class="docEmphasis"><TT>7–10</TT></span> We build a <TT>T_ordrel_req</TT> structure</p>
<pre>

</pre><pre>
struct T_ordrel_req {
  long  PRIM_type;   /* T_ORDREL_REQ */
};
</pre><pre>
</pre>
<P class="docText">and send it as an <TT>M_PROTO</TT> message using <TT>putmsg</TT>.</P>
<P class="docText">This example has given us a flavor for TPI. The application sends messages down a stream to the provider (requests) and the provider sends messages up the stream (replies). Some exchanges follow a simple request-reply scenario (binding a local address), while others may take a while (establishing a connection), allowing us to do something while we wait for the reply. Our choice of writing a TCP client using TPI was done for simplicity; writing a TCP server and handling connections are much harder.</P>
<BLOCKQUOTE><P><P class="docList">We can compare the number of system calls required for the network operations that we have seen in this chapter when using TPI versus a kernel that implements sockets within the kernel. Binding a local address takes two system calls with TPI, but only one with kernel sockets (TCPv2, p. 454). To establish a connection on a blocking descriptor takes three system calls with TPI, but only one with kernel sockets (TCPv2, p. 466).</P></P></BLOCKQUOTE>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch31lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch31lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
