<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Chapter 8"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_app05lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_app05lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app05lev1sec8"></A>
<H3 class="docSection1Title"> Chapter 8</H3>
<P><TABLE BORDER="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a01"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q01">8.1</A></B></TD><TD><P class="docText">Yes, <TT>read</TT> returns 4,096 bytes of data, but the <TT>recvfrom</TT> returns 2,048 (the first of the two datagrams). A <TT>recvfrom</TT> on a datagram socket never returns more than one datagram, regardless of how much the application asks for.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a02"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q02">8.2</A></B></TD><TD><P class="docText">If the protocol uses variable-length socket address structures, <TT>clilen</TT> could be too large. We will see in <A class="docLink" HREF="0131411551_ch15.html#ch15">Chapter 15</A> that this is acceptable with Unix domain socket address structures, but the correct way to code the function is to use the actual length returned by <TT>recvfrom</TT> as the length for <TT>sendto</TT>.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a04"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q04">8.4</A></B></TD><TD><P class="docText">Running <TT>ping</TT> like this is an easy way to see ICMP messages that are received by the host on which <TT>ping</TT> is being run. We reduce the number of packets sent from the normal one per second just to reduce the output. If we run our UDP client on our host <TT>aix</TT>, specifying the server's IP address as 192.168.42.1, and also run the <TT>ping</TT> program, we get the following output:</P><pre>
</pre><pre>
aix % <span class="docEmphStrong">ping -v -i 60 127.0.0.1</span>
PING 127.0.0.1: (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0 ms
36 bytes from 192.168.42.1: Destination Port Unreachable
Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src      Dst Data
 4  5  00 0022 0007   0 0000  1e  11 c770 192.168.42.2  192.168.42.1
UDP: from port 40645, to port 9877 (decimal)
</pre><pre>
</pre><BLOCKQUOTE><P><P class="docList">Note that not all <TT>ping</TT> clients print received ICMP errors, even with the <TT>-v</TT> flag.</P></P></BLOCKQUOTE></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a05"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q05">8.5</A></B></TD><TD><P class="docText">It probably has a socket receive buffer size, but data is never accepted for a listening TCP socket. Most implementations do not preallocate memory for socket send buffers or socket receive buffers. The socket buffer sizes specified with the <TT>SO_SNDBUF</TT> and <TT>SO_RCVBUF</TT> socket options are just upper limits for that socket.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a06"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q06">8.6</A></B></TD><TD><P class="docText">We run the <TT>sock</TT> program on the multihomed host <TT>freebsd</TT>, specifying the <TT>-u</TT> option (use UDP) and the <TT>-l</TT> option (specifying the local IP address and port).</P><pre>
</pre><pre>
freebsd % <span class="docEmphStrong">sock -u -l 12.106.32.254.4444 192.168.42.2 8888</span>
<span class="docEmphStrong">hello</span>
</pre><pre>
</pre><P class="docText">The local IP address is the Internet-side interface in <A class="docLink" HREF="0131411551_ch01lev1sec9.html#ch01fig16">Figure 1.16</A>, but the datagram must go out the other interface to get to the destination. Watching the network with <TT>tcpdump</TT> shows that the source IP address is the one that was bound by the client, not the outgoing interface address.</P><pre>
</pre><pre>
14:28:29.614846 12.106.32.254.4444 &gt; 192.168.42.2.8888: udp 6
14:28:29.615225 192.168.42.2 &gt; 12.106.32.254: icmp: 192.168.42.2
                                           udp port 8888 unreachable
</pre><pre>
</pre></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a07"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q07">8.7</A></B></TD><TD><P class="docText">Putting a <TT>printf</TT> in the client should introduce a delay between each datagram, allowing the server to receive more datagrams. Putting a <TT>printf</TT> in the server should cause the server to lose more datagrams.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch08a08"></A><B><A class="docLink" HREF="0131411551_ch08lev1sec17.html#ch08q08">8.8</A></B></TD><TD><P class="docText">The largest IPv4 datagram is 65,535 bytes, limited by the 16-bit total length field in <A class="docLink" HREF="0131411551_app01lev1sec2.html#app01fig01">Figure A.1</A>. The IP header requires 20 bytes and the UDP header requires 8 bytes, leaving a maximum of 65,507 bytes for user data. With IPv6 without jumbogram support, the size of the IPv6 header is 40 bytes, leaving a maximum of 65,487 bytes for user data.</P><P class="docText"><A class="docLink" HREF="#app05fig09">Figure E.9</A> shows the new version of <TT>dg_cli</TT>. If you forget to set the send buffer size, Berkeley-derived kernels return an error of <TT>EMSGSIZE</TT> from <TT>sendto</TT>, since the size of the socket send buffer is normally less than required for a maximum-sized UDP datagram (be sure to do <A class="docLink" HREF="0131411551_ch07lev1sec13.html#ch07lev1sec13">Exercise 7.1</A>). But if we set the client's socket buffer sizes as shown in <A class="docLink" HREF="#app05fig09">Figure E.9</A> and run the client program, nothing is returned by the server. We can verify that the client's datagram is sent to the server by running <TT>tcpdump</TT>, but if we put a <TT>printf</TT> in the server, its call to <TT>recvfrom</TT> does not return the datagram. The problem is that the server's UDP socket receive buffer is smaller than the datagram we are sending, so the datagram is discarded and not delivered to the socket. On a FreeBSD system, we can verify this by running <TT>netstat -s</TT> and looking at the "dropped due to full socket buffers" counter before and after our big datagram is received. The final solution is to modify the server, setting its socket send and receive buffer sizes.</P>
<H5 class="docExampleTitle"><A NAME="app05fig09"></A>Figure E.9 Writing the maximum-sized UDP/IPv4 datagram.</H5>
<P class="docText"><span class="docEmphasis">udpcliserv/dgclibig.c</span></P>
<PRE>
 1 #include    "unp.h"

 2 #undef  MAXLINE
 3 #define MAXLINE 65507

 4 void
 5 dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
 6 {
 7     int     size;
 8     char    sendline[MAXLINE], recvline[MAXLINE + 1];
 9     ssize_t n;

10     size = 70000;
11     Setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size));
12     Setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size));

13     Sendto(sockfd, sendline, MAXLINE, 0, pservaddr, servlen);

14     n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);

15     printf("received %d bytes\n", n);
16 }
</PRE>
<P class="docText">On most networks, a 65,535-byte IP datagram is fragmented. Recall from <A class="docLink" HREF="0131411551_ch02lev1sec11.html#ch02lev1sec11">Section 2.11</A> that an IP layer must support a reassembly buffer size of only 576 bytes. Therefore, you may encounter hosts that will not receive the maximum-sized datagrams sent in this exercise. Also, many Berkeley-derived implementations, including 4.4BSD-Lite2, have a sign bug that prevents UDP from accepting a datagram larger than 32,767 bytes (line 95 of p.770 of TCPv2).</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR></TABLE></P><br>
<P class="docText"></P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_app05lev1sec7.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_app05lev1sec9.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
