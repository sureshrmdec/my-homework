<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="18.4 'sysctl' Operations"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch18lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch18lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch18lev1sec4"></A>
<H3 class="docSection1Title">18.4 <TT>sysctl</TT> Operations</H3>
<P class="docText">Our main interest in routing sockets is the use of the <TT>sysctl</TT> function to examine both the routing table and interface list. Whereas the creation of a routing socket (a raw socket in the <TT>AF_ROUTE</TT> domain) requires superuser privileges, any process can examine the routing table and interface list using <TT>sysctl</TT>.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/param.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/sysctl.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int sysctl(int *</TT><span class="docEmphasis">name</span><TT>, u_int</TT> <span class="docEmphasis">namelen</span><TT>, void *</TT><span class="docEmphasis">oldp</span><TT>, size_t *</TT><span class="docEmphasis">oldlenp</span><TT>, void *</TT><span class="docEmphasis">newp</span><TT>, size_t</TT> <span class="docEmphasis">newlen</span><TT>);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 if OK, -1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">This function uses names that look like SNMP management information base (MIB) names. Chapter 25 of TCPv1 talks about SNMP and its MIB in detail. These names are hierarchical.</P>
<P class="docText">The <span class="docEmphasis">name</span> argument is an array of integers specifying the name, and <span class="docEmphasis">namelen</span> specifies the number of elements in the array. The first element in the array specifies which subsystem of the kernel the request is directed to. The second element specifies some part of that subsystem, and so on. <A class="docLink" HREF="#ch18fig11">Figure 18.11</A> shows the hierarchical arrangement, with some of the constants used at the first three levels.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig11"></A>Figure 18.11. Hierarchical arrangement of <TT>sysctl</TT> names.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="164" src="FILES/18fig11.gif" ALT="graphics/18fig11.gif"></p>

</CENTER>
<P class="docText">To fetch a value, <span class="docEmphasis">oldp</span> points to a buffer into which the kernel stores the value. <span class="docEmphasis">oldlenp</span> is a value-result argument: When the function is called, the value pointed to by <span class="docEmphasis">oldlenp</span> specifies the size of this buffer, and on return, the value contains the amount of data stored in the buffer by the kernel. If the buffer is not large enough, <TT>ENOMEM</TT> is returned. As a special case, <span class="docEmphasis">oldp</span> can be a null pointer and <span class="docEmphasis">oldlenp</span> a non-null pointer, and the kernel can determine how much data the call would have returned and returns this size through <span class="docEmphasis">oldlenp</span>.</P>
<P class="docText">To set a new value, <span class="docEmphasis">newp</span> points to a buffer of size <span class="docEmphasis">newlen</span>. If a new value is not being specified, <span class="docEmphasis">newp</span> should be a null pointer and <span class="docEmphasis">newlen</span> should be 0.</P>
<P class="docText">The <TT>sysctl</TT> man page details all the various system information that can be obtained with this function: information on the filesystems, virtual memory, kernel limits, hardware, and so on. Our interest is in the networking subsystem, designated by the first element of the <span class="docEmphasis">name</span> array being set to <TT>CTL_NET</TT>. (The <TT>CTL_</TT><span class="docEmphasis">xxx</span> constants are defined by including the <TT>&lt;sys/sysctl.h&gt;</TT> header.) The second element can then be as follows:</P>
<UL><LI><P class="docList"><TT>AF_INET</TT>—Get or set variables affecting the Internet protocols. The next level specifies the protocol using one of the <TT>IPPROTO_</TT><span class="docEmphasis">xxx</span> constants. FreeBSD 5.0 provides about 75 variables at this level, controlling features such as whether the kernel should generate an ICMP redirect, whether TCP should use the RFC 1323 options, whether UDP checksums should be sent, and so on. We will show an example of this use of <TT>sysctl</TT> at the end of this section.</P></LI><LI><P class="docList"><TT>AF_LINK</TT>—Get or set link-layer information such as the number of PPP interfaces.</P></LI><LI><P class="docList"><TT>AF_ROUTE</TT>—Return information on either the routing table or interface list. We will describe this information shortly.</P></LI><LI><P class="docList"><TT>AF_UNSPEC</TT>—Get or set some socket-layer variables such as the maximum size of a socket send or receive buffer.</P></LI></UL>
<P class="docText">When the second element of the <span class="docEmphasis">name</span> array is <TT>AF_ROUTE</TT>, the third element (a protocol number) is always 0 (since there are no protocols within the <TT>AF_ROUTE</TT> family, as there are within the <TT>AF_INET</TT> family, for example), the fourth element is an address family, and the fifth and sixth levels specify what to do. We will summarize this in <A class="docLink" HREF="#ch18fig12">Figure 18.12</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig12"></A>Figure 18.12. <TT>sysctl</TT> information returned for route domain.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="132" src="FILES/18fig12.gif" ALT="graphics/18fig12.gif"></p>

</CENTER>
<P class="docText">Three operations are supported, specified by <span class="docEmphasis">name</span> <TT>[4]</TT>. (The <TT>NET_RT_</TT><span class="docEmphasis">xxx</span> constants are defined by including the <TT>&lt;sys/socket.h&gt;</TT> header.) The information returned by these four operations is returned through the <span class="docEmphasis">oldp</span> pointer in the call to <TT>sysctl</TT>. This buffer contains a variable number of <TT>RTM_</TT><span class="docEmphasis">xxx</span> messages (<A class="docLink" HREF="0131411551_ch18lev1sec3.html#ch18fig02">Figure 18.2</A>).</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList"><TT>NET_RT_DUMP</TT> returns the routing table for the address family specified by <span class="docEmphasis">name</span> <TT>[3]</TT>. If this address family is 0, the routing tables for all address families are returned.</P><P class="docList">The routing table is returned as a variable number of <TT>RTM_GET</TT> messages, with each message followed by up to four socket address structures: the destination, gateway, network mask, and cloning mask of the routing table entry. We showed one of these messages on the right side of <A class="docLink" HREF="0131411551_ch18lev1sec3.html#ch18fig05">Figure 18.5</A> and our code in <A class="docLink" HREF="0131411551_ch18lev1sec3.html#ch18fig07">Figure 18.7</A> parsed one of these messages. All that changes with this <TT>sysctl</TT> operation is that one or more of these messages are returned by the kernel.</P></span></LI><LI><span style="font-weight:normal"><P class="docList"><TT>NET_RT_FLAGS</TT> returns the routing table for the address family specified by <span class="docEmphasis">name</span> <TT>[3]</TT>, but only the routing table entries with an <TT>RTF_</TT><span class="docEmphasis">xxx</span> flag value that contains the flag specified by <span class="docEmphasis">name</span> <TT>[5]</TT>. All ARP cache entries in the routing table have the <TT>RTF_LLINFO</TT> flag bit set.</P><P class="docList">The information is returned in the same format as the previous item.</P></span></LI><LI><span style="font-weight:normal"><P class="docList"><TT>NET_RT_IFLIST</TT> returns information on all configured interfaces. If <span class="docEmphasis">name</span> <TT>[5]</TT> is nonzero, it is an interface index number, and only information on that interface is returned. (We will say more about interface indexes in <A class="docLink" HREF="0131411551_ch18lev1sec6.html#ch18lev1sec6">Section 18.6</A>.) All the addresses assigned to each interface are also returned, and if <span class="docEmphasis">name</span> <TT>[3]</TT> is nonzero, only addresses for that address family are returned.</P><P class="docList">For each interface, one <TT>RTM_IFINFO</TT> message is returned, followed by one <TT>RTM_NEWADDR</TT> message for each address assigned to the interface. The <TT>RTM_IFINFO</TT> message is followed by one datalink socket address structure, and each <TT>RTM_NEWADDR</TT> message is followed by up to three socket address structures: the interface address, the network mask, and the broadcast address. These two messages are shown in <A class="docLink" HREF="#ch18fig14">Figure 18.14</A>.</P></span></LI></OL></span>
<A NAME="ch18lev2sec2"></A>
<H4 class="docSection2Title"> Example: Determine if UDP Checksums Are Enabled</H4>
<P class="docText">We now provide a simple example of <TT>sysctl</TT> with the Internet protocols to check whether UDP checksums are enabled. Some UDP applications (e.g., BIND) check whether UDP checksums are enabled when they start, and if not, they try to enable them. Naturally, it takes superuser privileges to enable a feature such as this, but all we do now is check whether the feature is enabled or not. <A class="docLink" HREF="#ch18fig13">Figure 18.13</A> is our program.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig13"></A>Figure 18.13 Check whether UDP checksums are enabled.</H5>
<P class="docText"><span class="docEmphasis">route/checkudpsum.c</span></P>

<PRE>
 1 #include     "unproute.h"
 2 #include     &lt;netinet/udp.h&gt;
 3 #include     &lt;netinet/ip_var.h&gt;
 4 #include     &lt;netinet/udp_var.h&gt; /* for UDPCTL_xxx constants */
 5 int
 6 main(int argc, char **argv)
 7 {
 8     int     mib[4], val;
 9     size_t  len;

10    mib[0] = CTL_NET;
11    mib[1] = AF_INET;
12    mib[2] = IPPROTO_UDP;
13    mib[3] = UDPCTL_CHECKSUM;

14    len = sizeof(val);
15    Sysctl(mib, 4, &amp;val, &amp;len, NULL, 0);
16    printf("udp checksum flag: %d\n", val);

17    exit(0) ;
18 }
</PRE>

<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig14"></A>Figure 18.14. Information returned for <TT>sysctl</TT>, <TT>CTL_NET</TT>, <TT>NET_RT_IFLIST</TT> command.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="250" HEIGHT="510" src="FILES/18fig14.gif" ALT="graphics/18fig14.gif"></p>

</CENTER>
<A NAME="ch18lev3sec7"></A>
<H5 class="docSection3Title"> Include system headers</H5>
<p class="docText"><span class="docEmphasis"><TT>2–4</TT></span> We must include the <TT>&lt;netinet/udp_var.h&gt;</TT> header to obtain the definition of the UDP <TT>sysctl</TT> constants. The two other headers are required for this header.</p>

<A NAME="ch18lev3sec8"></A>
<H5 class="docSection3Title"> Call <TT>sysctl</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>10–16</TT></span> We allocate an integer array with four elements and store the constants that correspond to the hierarchy shown in <A class="docLink" HREF="#ch18fig11">Figure 18.11</A>. Since we are only fetching a variable and not setting a new value, we specify a null pointer for the <span class="docEmphasis">newp</span> argument to <TT>sysctl</TT> and a value of 0 for the <span class="docEmphasis">newlen</span> argument. <span class="docEmphasis">oldp</span> points to an integer variable of ours into which the result is stored and <span class="docEmphasis">oldlenp</span> points to a value-result variable for the size of this integer. The flag that we print will be either 0 (disabled) or 1 (enabled).</p>



<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch18lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch18lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
