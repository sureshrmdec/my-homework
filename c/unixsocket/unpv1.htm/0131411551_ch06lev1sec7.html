<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.7 'str_cli' Function (Revisited Again)"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch06lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch06lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec7"></A>
<H3 class="docSection1Title">6.7 <TT>str_cli</TT> Function (Revisited Again)</H3>
<P class="docText"><A class="docLink" HREF="#ch06fig13">Figure 6.13</A> shows our revised (and correct) version of the <TT>str_cli</TT> function. This version uses <TT>select</TT> and <TT>shutdown</TT>. The former notifies us as soon as the server closes its end of the connection and the latter lets us handle batch input correctly. This version also does away with line-centric code and operates instead on buffers, eliminating the complexity concerns raised in <A class="docLink" HREF="0131411551_ch06lev1sec5.html#ch06lev1sec5">Section 6.5</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch06fig13"></A>Figure 6.13 <TT>str_cli</TT> function using <TT>select</TT> that handles EOF correctly.</H5>
<P class="docText"><span class="docEmphasis">select/strcliselect02.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 str_cli(FILE *fp, int sockfd)
 4 {
 5     int     maxfdp1, stdineof;
 6     fd_set  rset;
 7     char    buf[MAXLINE];
 8     int     n;

 9     stdineof = 0;
10     FD_ZERO(&amp;rset);
11     for ( ; ; ) {
12         if (stdineof == 0)
13             FD_SET(fileno(fp), &amp;rset);
14         FD_SET(sockfd, &amp;rset);
15         maxfdp1 = max(fileno(fp), sockfd) + 1;
16         Select(maxfdp1, &amp;rset, NULL, NULL, NULL);

17         if (FD_ISSET(sockfd, &amp;rset)) {  /* socket is readable */
18             if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {
19                 if (stdineof == 1)
20                     return;       /* normal termination */
21                 else
22                     err_quit("str_cli: server terminated prematurely");
23                 }
24                 Write(fileno(stdout), buf, n);
25         }
26         if (FD_ISSET(fileno(fp), &amp;rset)) {  /* input is readable */
27             if ( (n = Read(fileno(fp), buf, MAXLINE)) == 0) {
28                 stdineof = 1;
29                 Shutdown(sockfd, SHUT_WR);  /* send FIN */
30                 FD_CLR(fileno(fp), &amp;rset);
31                 continue;
32             }
33             Writen(sockfd, buf, n);
34         }
35     }
36 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>5–8</TT></span> <TT>stdineof</TT> is a new flag that is initialized to 0. As long as this flag is 0, each time around the main loop, we <TT>select</TT> on standard input for readability.</p>
<p class="docText"><span class="docEmphasis"><TT>17–25</TT></span> When we read the EOF on the socket, if we have already encountered an EOF on standard input, this is normal termination and the function returns. But if we have not yet encountered an EOF on standard input, the server process has prematurely terminated. We now call <TT>read</TT> and <TT>write</TT> to operate on buffers instead of lines and allow <TT>select</TT> to work for us as expected.</p>
<p class="docText"><span class="docEmphasis"><TT>26–34</TT></span> When we encounter the EOF on standard input, our new flag, <TT>stdineof</TT>, is set and we call <TT>shutdown</TT> with a second argument of <TT>SHUT_WR</TT> to send the FIN. Here also, we've changed to operating on buffers instead of lines, using <TT>read</TT> and <TT>writen</TT>.</p>
<P class="docText">We are not finished with our <TT>str_cli</TT> function. We will develop a version using nonblocking I/O in <A class="docLink" HREF="0131411551_ch16lev1sec2.html#ch16lev1sec2">Section 16.2</A> and a version using threads in <A class="docLink" HREF="0131411551_ch26lev1sec3.html#ch26lev1sec3">Section 26.3</A>.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch06lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch06lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
