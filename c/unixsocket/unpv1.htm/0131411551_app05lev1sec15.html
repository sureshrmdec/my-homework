<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Chapter 15"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_app05lev1sec14.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_app05lev1sec16.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app05lev1sec15"></A>
<H3 class="docSection1Title"> Chapter 15</H3>
<P><TABLE BORDER="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch15a01"></A><B><A class="docLink" HREF="0131411551_ch15lev1sec10.html#ch15q01">15.1</A></B></TD><TD><P class="docText"><TT>unlink</TT> removes the pathname from the filesystem, and when the client calls <TT>connect</TT> at a later time, the <TT>connect</TT> will fail. The server's listening socket is not affected, but no clients will be able to <TT>connect</TT> after the <TT>unlink</TT>.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch15a02"></A><B><A class="docLink" HREF="0131411551_ch15lev1sec10.html#ch15q02">15.2</A></B></TD><TD><P class="docText">The client cannot <TT>connect</TT> to the server even if the pathname still exists, because for the <TT>connect</TT> to succeed, a Unix domain socket must be currently open and bound to that pathname (<A class="docLink" HREF="0131411551_ch15lev1sec4.html#ch15lev1sec4">Section 15.4</A>).</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch15a03"></A><B><A class="docLink" HREF="0131411551_ch15lev1sec10.html#ch15q03">15.3</A></B></TD><TD><P class="docText">When the server prints the client's protocol address by calling <TT>sock_ntop</TT>, the output is "datagram from (no pathname bound)" because no pathname is bound to the client's socket by default.</P><P class="docText">One solution is to specifically check for a Unix domain socket in <TT>udp_client</TT> and <TT>udp_connect</TT> and <TT>bind</TT> a temporary pathname to the socket. This puts the protocol dependency in the library function where it belongs, not in our application.</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch15a04"></A><B><A class="docLink" HREF="0131411551_ch15lev1sec10.html#ch15q04">15.4</A></B></TD><TD><P class="docText">Even though we force 1-byte <TT>writes</TT> by the server for its 26-byte reply, putting the <TT>sleep</TT> in the client guarantees that all 26 segments are received before <TT>read</TT> is called, causing <TT>read</TT> to return the entire reply. This is just to confirm (again) that TCP is a byte stream with no inherent record markers.</P><P class="docText">To use the Unix domain protocols, we start the client and server with the two command-line arguments <TT>/local</TT> (or <TT>/unix</TT>) and <TT>/tmp/daytime</TT> (or any other temporary pathname you wish to use). Nothing changes: 26 bytes are returned by <TT>read</TT> each time the client runs.</P><P class="docText">Since the server specifies the <TT>MSG_EOR</TT> flag for each <TT>send</TT>, each byte is considered a logical record and <TT>read</TT> returns 1 byte each time it is called. What is happening here is that Berkeley-derived implementations support the <TT>MSG_EOR</TT> flag by default. This is undocumented, however, and should not be used in production code. We use it here as an example of the difference between a byte stream and a record-oriented protocol. From an implementation perspective, each output operation goes into a memory buffer (mbuf) and the <TT>MSG_EOR</TT> flag is retained by the kernel with the mbuf as the mbuf goes from the sending socket to the receiving socket's receive buffer. When <TT>read</TT> is called, the <TT>MSG_EOR</TT> flag is still attached to each mbuf, so the generic kernel <TT>read</TT> routine (which supports the <TT>MSG_EOR</TT> flag since some protocols use the flag) returns each byte by itself. Had we used <TT>recvmsg</TT> instead of <TT>read</TT>, the <TT>MSG_EOR</TT> flag would be returned in the <TT>msg_flags</TT> member each time <TT>recvmsg</TT> returned 1 byte. This does not work with TCP because the sending TCP never looks at the <TT>MSG_EOR</TT> flag in the mbuf that it is sending, and even if it did, there is no way to pass this flag to the receiving TCP in the TCP header. (Thanks to Matt Thomas for pointing out this undocumented "feature.")</P></TD></TR><TR valign="top"><TD align="right" class="docText"><B></B></TD><TD><P class="docText"></P></TD></TR><TR valign="top"><TD align="right" class="docText"><A NAME="ch15a05"></A><B><A class="docLink" HREF="0131411551_ch15lev1sec10.html#ch15q05">15.5</A></B></TD><TD><P class="docText"><span class="docEmphStrong">15.5</span> <A class="docLink" HREF="#app05fig13">Figure E.13</A> shows an implementation of this program.</P>
<H5 class="docExampleTitle"><A NAME="app05fig13"></A>Figure E.13 Determine actual number of queued connections for different <span class="docEmphasis">backlog</span> values.</H5>
<P class="docText"><span class="docEmphasis">debug/backlog.c</span></P>
<PRE>
 1 #include    "unp.h"

 2 #define PORT        9999
 3 #define ADDR        "127.0.0.1"
 4 #define MAXBACKLOG  100

 5             /* globals */
 6 struct sockaddr_in serv;
 7 pid_t   pid;                    /* of child */

 8 int     pipefd[2];
 9 #define pfd pipefd[1]           /* parent's end */
10 #define cfd pipefd[0]           /* child's end */

11             /* function prototypes */
12 void    do_parent(void);
13 void    do_child(void);

14 int
15 main(int argc, char **argv)
16 {
17     if (argc != 1)
18         err_quit("usage: backlog");

19     Socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd);

20     bzero(&amp;serv, sizeof(serv));
21     serv.sin_family = AF_INET;
22     serv.sin_port = htons(PORT);
23     Inet_pton(AF_INET, ADDR, &amp;serv.sin_addr);

24     if ( (pid = Fork()) == 0)
25         do_child();
26     else
27         do_parent();

28     exit(0);
29 }

30 void
31 parent_alrm(int signo)
32 {
33     return;                      /* just interrupt blocked connect() */
34 }

35 void
36 do_parent(void)
37 {
38     int     backlog,  j, k, junk, fd[MAXBACKLOG + 1];

39     Close(cfd);
40     Signal(SIGALRM, parent_alrm);

41     for (backlog = 0; backlog &lt;= 14; backlog++) {
42         printf("backlog = %d: ", backlog);
43         Write(pfd, &amp;backlog, sizeof(int));  /* tell child value */
44         Read(pfd, &amp;junk, sizeof(int));  /* wait for child */

45         for (j = 1; j &lt;= MAXBACKLOG; j++) {
46             fd[j] = Socket(AF_INET, SOCK_STREAM, 0);
47             alarm(2);
48             if (connect(fd[j], (SA *) &amp;serv, sizeof(serv)) &lt; 0) {
49                 if (errno != EINTR)
50                     err_sys("connect error, j = %d", j);
51                 printf("timeout, %d connections completed\n", j - 1);
52                 for (k = 1; k &lt;= j; k++)
53                     Close(fd[k]);
54                 break;          /* next value of backlog */
55             }
56             alarm(0);
57         }
58         if (j &gt; MAXBACKLOG)
59             printf("%d connections?\n", MAXBACKLOG);
60     }
61     backlog = -1;      /* tell child we're all done */
62     Write(pfd, &amp;backlog, sizeof(int));
63 }

64 void
65 do_child(void)
66 {
67     int     listenfd, backlog, junk;
68     const int on = 1;

69     Close(pfd);

70     Read(cfd, &amp;backlog, sizeof(int));      /* wait for parent */
71     while (backlog &gt;= 0) {
72         listenfd = Socket(AF_INET, SOCK_STREAM, 0);
73         Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));
74         Bind(listenfd, (SA *) &amp;serv, sizeof(serv));
75         Listen(listenfd, backlog);  /* start the listen */

76         Write(cfd, &amp;junk, sizeof(int)); /* tell parent */

77         Read(cfd, &amp;backlog, sizeof(int));   /* just wait for parent */
78         Close(listenfd);        /* closes all queued connections, too */
79     }
80 }
</PRE>
</TD></TR></TABLE></P><br>
<P class="docText"></P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_app05lev1sec14.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_app05lev1sec16.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
