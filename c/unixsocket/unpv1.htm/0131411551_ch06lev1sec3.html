<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.3 'select' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch06lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch06lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec3"></A>
<H3 class="docSection1Title">6.3 <TT>select</TT> Function</H3>
<P class="docText">This function allows the process to instruct the kernel to wait for any one of multiple events to occur and to wake up the process only when one or more of these events occurs or when a specified amount of time has passed.</P>
<P class="docText">As an example, we can call <TT>select</TT> and tell the kernel to return only when:</P>
<UL><LI><P class="docList">Any of the descriptors in the set {1, 4, 5} are ready for reading</P></LI><LI><P class="docList">Any of the descriptors in the set {2, 7} are ready for writing</P></LI><LI><P class="docList">Any of the descriptors in the set {1, 4} have an exception condition pending</P></LI><LI><P class="docList">10.2 seconds have elapsed</P></LI></UL>
<P class="docText">That is, we tell the kernel what descriptors we are interested in (for reading, writing, or an exception condition) and how long to wait. The descriptors in which we are interested are not restricted to sockets; any descriptor can be tested using <TT>select</TT>.</P>
<BLOCKQUOTE><P><P class="docList">Berkeley-derived implementations have always allowed I/O multiplexing with any descriptor. SVR3 originally limited I/O multiplexing to descriptors that were STREAMS devices (<A class="docLink" HREF="0131411551_ch31.html#ch31">Chapter 31</A>), but this limitation was removed with SVR4.</P></P></BLOCKQUOTE>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/select.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;sys/time.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int select(int</TT> <span class="docEmphasis">maxfdp1</span>, <TT>fd_set *</TT><span class="docEmphasis">readset</span>, <TT>fd_set *</TT><span class="docEmphasis">writeset</span>, <TT>fd_set *</TT><span class="docEmphasis">exceptset</span>, <TT>const struct timeval *</TT><span class="docEmphasis">timeout</span><TT>)</TT>;</P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: positive count of ready descriptors, 0 on timeout, –1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">We start our description of this function with its final argument, which tells the kernel how long to wait for one of the specified descriptors to become ready. A <TT>timeval</TT> structure specifies the number of seconds and microseconds.</P>
<pre>

</pre><pre>
struct timeval  {
  long   tv_sec;          /* seconds */
  long   tv_usec;         /* microseconds */
};
</pre><pre>
</pre>
<P class="docText">There are three possibilities:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Wait forever—</span> Return only when one of the specified descriptors is ready for I/O. For this, we specify the <span class="docEmphasis">timeout</span> argument as a null pointer.</p></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Wait up to a fixed amount of time—</span> Return when one of the specified descriptors is ready for I/O, but do not wait beyond the number of seconds and microseconds specified in the <TT>timeval</TT> structure pointed to by the <span class="docEmphasis">timeout</span> argument.</p></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphRoman">Do not wait at all—</span> Return immediately after checking the descriptors. This is called <span class="docEmphasis">polling</span>. To specify this, the <span class="docEmphasis">timeout</span> argument must point to a <TT>timeval</TT> structure and the timer value (the number of seconds and microseconds specified by the structure) must be 0.</p></span></LI></OL></span>
<P class="docText">The wait in the first two scenarios is normally interrupted if the process catches a signal and returns from the signal handler.</P>
<BLOCKQUOTE><P><P class="docList">Berkeley-derived kernels never automatically restart <TT>select</TT> (p. 527 of TCPv2), while SVR4 will if the <TT>SA_RESTART</TT> flag is specified when the signal handler is installed. This means that for portability, we must be prepared for <TT>select</TT> to return an error of <TT>EINTR</TT> if we are catching signals.</P></P></BLOCKQUOTE>
<P class="docText">Although the <TT>timeval</TT> structure lets us specify a resolution in microseconds, the actual resolution supported by the kernel is often more coarse. For example, many Unix kernels round the timeout value up to a multiple of 10 ms. There is also a scheduling latency involved, meaning it takes some time after the timer expires before the kernel schedules this process to run.</P>
<BLOCKQUOTE><P><P class="docList">On some systems, <TT>select</TT> will fail with <TT>EINVAL</TT> if the <TT>tv_sec</TT> field in the timeout is over 100 million seconds. Of course, that's a very large timeout (over three years) and likely not very useful, but the point is that the <TT>timeval</TT> structure can represent values that are not supported by <TT>select</TT>.</P></P></BLOCKQUOTE>
<P class="docText">The <TT>const</TT> qualifier on the <span class="docEmphasis">timeout</span> argument means it is not modified by <TT>select</TT> on return. For example, if we specify a time limit of 10 seconds, and <TT>select</TT> returns before the timer expires with one or more of the descriptors ready or with an error of <TT>EINTR</TT>, the <TT>timeval</TT> structure is not updated with the number of seconds remaining when the function returns. If we wish to know this value, we must obtain the system time before calling <TT>select</TT>, and then again when it returns, and subtract the two (any robust program will take into account that the system time may be adjusted by either the administrator or by a daemon like <TT>ntpd</TT> occasionally).</P>
<BLOCKQUOTE><P><P class="docList">Some Linux versions modify the <TT>timeval</TT> structure. Therefore, for portability, assume the <TT>timeval</TT> structure is undefined upon return, and initialize it before each call to <TT>select</TT>. POSIX specifies the <TT>const</TT> qualifier.</P></P></BLOCKQUOTE>
<P class="docText">The three middle arguments, <span class="docEmphasis">readset</span>, <span class="docEmphasis">writeset</span>, and <span class="docEmphasis">exceptset</span>, specify the descriptors that we want the kernel to test for reading, writing, and exception conditions. There are only two exception conditions currently supported:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">The arrival of out-of-band data for a socket. We will describe this in more detail in <A class="docLink" HREF="0131411551_ch24.html#ch24">Chapter 24</A>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The presence of control status information to be read from the master side of a pseudo-terminal that has been put into packet mode. We do not talk about pseudo-terminals in this book.</P></span></LI></OL></span>
<P class="docText">A design problem is how to specify one or more descriptor values for each of these three arguments. <TT>select</TT> uses <span class="docEmphasis">descriptor sets</span>, typically an array of integers, with each bit in each integer corresponding to a descriptor. For example, using 32-bit integers, the first element of the array corresponds to descriptors 0 through 31, the second element of the array corresponds to descriptors 32 through 63, and so on. All the implementation details are irrelevant to the application and are hidden in the <TT>fd_set</TT> datatype and the following four macros:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void FD_ZERO(fd_set *</TT><span class="docEmphasis">fdset</span><TT>)</TT>;</P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>/* clear all bits in</TT> <span class="docEmphasis">fdset</span> <TT>*/</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void FD_SET(int</TT> <span class="docEmphasis">fd</span>, <TT>fd_set *</TT><span class="docEmphasis">fdset</span><TT>)</TT>;</P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>/* turn on the bit for</TT> <span class="docEmphasis">fd</span> <TT>in</TT> <span class="docEmphasis">fdset</span> <TT>*/</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>void FD_CLR(int</TT> <span class="docEmphasis">fd</span>, <TT>fd_set *</TT><span class="docEmphasis">fdset</span><TT>)</TT>;</P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>/* turn off the bit for</TT> <span class="docEmphasis">fd</span> <TT>in</TT> <span class="docEmphasis">fdset</span> <TT>*/</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int FD_ISSET(int</TT> <span class="docEmphasis">fd</span>, <TT>fd_set *</TT><span class="docEmphasis">fdset</span><TT>)</TT>;</P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>/* is the bit for</TT> <span class="docEmphasis">fd</span> <TT>on in</TT> <span class="docEmphasis">fdset</span> <TT>? */</TT></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">We allocate a descriptor set of the <TT>fd_set</TT> datatype, we set and test the bits in the set using these macros, and we can also assign it to another descriptor set across an equals sign (=) in C.</P>
<BLOCKQUOTE><P><P class="docList">What we are describing, an array of integers using one bit per descriptor, is just one possible way to implement <TT>select</TT>. Nevertheless, it is common to refer to the individual descriptors within a descriptor set as <span class="docEmphasis">bits</span>, as in "turn on the bit for the listening descriptor in the read set."</P></P><P><P class="docList">We will see in <A class="docLink" HREF="0131411551_ch06lev1sec10.html#ch06lev1sec10">Section 6.10</A> that the <TT>poll</TT> function uses a completely different representation: a variable-length array of structures with one structure per descriptor.</P></P></BLOCKQUOTE>
<P class="docText">For example, to define a variable of type <TT>fd_set</TT> and then turn on the bits for descriptors 1, 4, and 5, we write</P>
<pre>

</pre><pre>
fd_set rset;

FD_ZERO(&amp;rset);          /* initialize the set: all bits off */
FD_SET(1, &amp;rset);        /* turn on bit for fd 1 */
FD_SET(4, &amp;rset);        /* turn on bit for fd 4 */
FD_SET(5, &amp;rset);        /* turn on bit for fd 5 */
</pre><pre>
</pre>
<P class="docText">It is important to initialize the set, since unpredictable results can occur if the set is allocated as an automatic variable and not initialized.</P>
<P class="docText">Any of the middle three arguments to <TT>select</TT>, <span class="docEmphasis">readset</span>, <span class="docEmphasis">writeset</span>, or <span class="docEmphasis">exceptset</span>, can be specified as a null pointer if we are not interested in that condition. Indeed, if all three pointers are null, then we have a higher precision timer than the normal Unix <TT>sleep</TT> function (which sleeps for multiples of a second). The <TT>poll</TT> function provides similar functionality. Figures C.9 and C.10 of APUE show a <TT>sleep_us</TT> function implemented using both <TT>select</TT> and <TT>poll</TT> that sleeps for multiples of a microsecond.</P>
<P class="docText">The <span class="docEmphasis">maxfdp1</span> argument specifies the number of descriptors to be tested. Its value is the maximum descriptor to be tested plus one (hence our name of <span class="docEmphasis">maxfdp1</span>). The descriptors 0, 1, 2, up through and including <span class="docEmphasis">maxfdp1–1</span> are tested.</P>
<P class="docText">The constant <TT>FD_SETSIZE</TT>, defined by including <TT>&lt;sys/select.h&gt;</TT>, is the number of descriptors in the <TT>fd_set</TT> datatype. Its value is often 1024, but few programs use that many descriptors. The <span class="docEmphasis">maxfdp1</span> argument forces us to calculate the largest descriptor that we are interested in and then tell the kernel this value. For example, given the previous code that turns on the indicators for descriptors 1, 4, and 5, the <span class="docEmphasis">maxfdp1</span> value is 6. The reason it is 6 and not 5 is that we are specifying the number of descriptors, not the largest value, and descriptors start at 0.</P>
<BLOCKQUOTE><P><P class="docList">The reason this argument exists, along with the burden of calculating its value, is purely for efficiency. Although each <TT>fd_set</TT> has room for many descriptors, typically 1,024, this is much more than the number used by a typical process. The kernel gains efficiency by not copying unneeded portions of the descriptor set between the process and the kernel, and by not testing bits that are always 0 (Section 16.13 of TCPv2).</P></P></BLOCKQUOTE>
<P class="docText"><TT>select</TT> modifies the descriptor sets pointed to by the <span class="docEmphasis">readset</span>, <span class="docEmphasis">writeset</span>, and <span class="docEmphasis">exceptset</span> pointers. These three arguments are value-result arguments. When we call the function, we specify the values of the descriptors that we are interested in, and on return, the result indicates which descriptors are ready. We use the <TT>FD_ISSET</TT> macro on return to test a specific descriptor in an <TT>fd_set</TT> structure. Any descriptor that is not ready on return will have its corresponding bit cleared in the descriptor set. To handle this, we turn on all the bits in which we are interested in all the descriptor sets each time we call <TT>select</TT>.</P>
<BLOCKQUOTE><P><P class="docList">The two most common programming errors when using <TT>select</TT> are to forget to add one to the largest descriptor number and to forget that the descriptor sets are value-result arguments. The second error results in <TT>select</TT> being called with a bit set to 0 in the descriptor set, when we think that bit is 1.</P></P></BLOCKQUOTE>
<P class="docText">The return value from this function indicates the total number of bits that are ready across all the descriptor sets. If the timer value expires before any of the descriptors are ready, a value of 0 is returned. A return value of –1 indicates an error (which can happen, for example, if the function is interrupted by a caught signal).</P>
<BLOCKQUOTE><P><P class="docList">Early releases of SVR4 had a bug in their implementation of <TT>select:</TT> If the same bit was on in multiple sets, say a descriptor was ready for both reading and writing, it was counted only once. Current releases fix this bug.</P></P></BLOCKQUOTE>
<A NAME="ch06lev2sec8"></A>
<H4 class="docSection2Title"> Under What Conditions Is a Descriptor Ready?</H4>
<P class="docText">We have been talking about waiting for a descriptor to become ready for I/O (reading or writing) or to have an exception condition pending on it (out-of-band data). While readability and writability are obvious for descriptors such as regular files, we must be more specific about the conditions that cause <TT>select</TT> to return "ready" for sockets (Figure 16.52 of TCPv2).</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">A socket is ready for reading if any of the following four conditions is true:</P><span style="font-weight:bold"><OL class="docList" TYPE="a"><LI><span style="font-weight:normal"><P class="docList">The number of bytes of data in the socket receive buffer is greater than or equal to the current size of the low-water mark for the socket receive buffer. A read operation on the socket will not block and will return a value greater than 0 (i.e., the data that is ready to be read). We can set this low-water mark using the <TT>SO_RCVLOWAT</TT> socket option. It defaults to 1 for TCP and UDP sockets.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The read half of the connection is closed (i.e., a TCP connection that has received a FIN). A read operation on the socket will not block and will return 0 (i.e., EOF).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The socket is a listening socket and the number of completed connections is nonzero. An <TT>accept</TT> on the listening socket will normally not block, although we will describe a timing condition in <A class="docLink" HREF="0131411551_ch16lev1sec6.html#ch16lev1sec6">Section 16.6</A> under which the <TT>accept</TT> can block.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A socket error is pending. A read operation on the socket will not block and will return an error (–1) with <TT>errno</TT> set to the specific error condition. These <span class="docEmphasis">pending errors</span> can also be fetched and cleared by calling <TT>getsockopt</TT> and specifying the <TT>SO_ERROR</TT> socket option.</P></span></LI></OL></span></span></LI><LI><span style="font-weight:normal"><P class="docList">A socket is ready for writing if any of the following four conditions is true:</P><span style="font-weight:bold"><OL class="docList" TYPE="a"><LI><span style="font-weight:normal"><P class="docList">The number of bytes of available space in the socket send buffer is greater than or equal to the current size of the low-water mark for the socket send buffer <span class="docEmphasis">and</span> either: (i) the socket is connected, or (ii) the socket does not require a connection (e.g., UDP). This means that if we set the socket to nonblocking (<A class="docLink" HREF="0131411551_ch16.html#ch16">Chapter 16</A>), a write operation will not block and will return a positive value (e.g., the number of bytes accepted by the transport layer). We can set this low-water mark using the <TT>SO_SNDLOWAT</TT> socket option. This low-water mark normally defaults to 2048 for TCP and UDP sockets.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The write half of the connection is closed. A write operation on the socket will generate <TT>SIGPIPE</TT> (<A class="docLink" HREF="0131411551_ch05lev1sec12.html#ch05lev1sec12">Section 5.12</A>).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A socket using a non-blocking <TT>connect</TT> has completed the connection, or the <TT>connect</TT> has failed.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A socket error is pending. A write operation on the socket will not block and will return an error (–1) with <TT>errno</TT> set to the specific error condition. These <span class="docEmphasis">pending errors</span> can also be fetched and cleared by calling <TT>getsockopt</TT> with the <TT>SO_ERROR</TT> socket option.</P></span></LI></OL></span></span></LI><LI><span style="font-weight:normal"><P class="docList">A socket has an exception condition pending if there is out-of-band data for the socket or the socket is still at the out-of-band mark. (We will describe out-of-band data in <A class="docLink" HREF="0131411551_ch24.html#ch24">Chapter 24</A>.)</P><BLOCKQUOTE><P><P class="docList">Our definitions of "readable" and "writable" are taken directly from the kernel's <TT>soreadable</TT> and <TT>sowriteable</TT> macros on pp. 530–531 of TCPv2. Similarly, our definition of the "exception condition" for a socket is from the <TT>soo_select</TT> function on these same pages.</P></P></BLOCKQUOTE></span></LI></OL></span>
<P class="docText">Notice that when an error occurs on a socket, it is marked as both readable and writable by <TT>select</TT>.</P>
<P class="docText">The purpose of the receive and send low-water marks is to give the application control over how much data must be available for reading or how much space must be available for writing before <TT>select</TT> returns a readable or writable status. For example, if we know that our application has nothing productive to do unless at least 64 bytes of data are present, we can set the receive low-water mark to 64 to prevent <TT>select</TT> from waking us up if less than 64 bytes are ready for reading.</P>
<P class="docText">As long as the send low-water mark for a UDP socket is less than the send buffer size (which should always be the default relationship), the UDP socket is always writable, since a connection is not required.</P>
<P class="docText"><A class="docLink" HREF="#ch06fig07">Figure 6.7</A> summarizes the conditions just described that cause a socket to be ready for <TT>select</TT>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch06fig07"></A>Figure 6.7. Summary of conditions that cause a socket to be ready for <TT>select</TT>.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="477" HEIGHT="148" src="FILES/06fig07.gif" ALT="graphics/06fig07.gif"></p>

</CENTER>

<A NAME="ch06lev2sec9"></A>
<H4 class="docSection2Title"> Maximum Number of Descriptors for <TT>select</TT></H4>
<P class="docText">We said earlier that most applications do not use lots of descriptors. It is rare, for example, to find an application that uses hundreds of descriptors. But, such applications do exist, and they often use <TT>select</TT> to multiplex the descriptors. When <TT>select</TT> was originally designed, the OS normally had an upper limit on the maximum number of descriptors per process (the 4.2BSD limit was 31), and <TT>select</TT> just used this same limit. But, current versions of Unix allow for a virtually unlimited number of descriptors per process (often limited only by the amount of memory and any administrative limits), so the question is: How does this affect <TT>select?</TT></P>
<P class="docText">Many implementations have declarations similar to the following, which are taken from the 4.4BSD <TT>&lt;sys/types.h&gt;</TT> header:</P>
<pre>

</pre><pre>
/*
 * Select uses bitmasks of file descriptors in longs. These macros
 * manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here should
 * be enough for most uses.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      256
#endif
</pre><pre>
</pre>
<P class="docText">This makes us think that we can just <TT>#define FD_SETSIZE</TT> to some larger value before including this header to increase the size of the descriptor sets used by <TT>select</TT>. Unfortunately, this normally does not work.</P>
<BLOCKQUOTE><P><P class="docList">To see what is wrong, notice that Figure 16.53 of TCPv2 declares three descriptor sets within the kernel and also uses the kernel's definition of <TT>FD_SETSIZE</TT> as the upper limit. The only way to increase the size of the descriptor sets is to increase the value of <TT>FD_SETSIZE</TT> and then recompile the kernel. Changing the value without recompiling the kernel is inadequate.</P></P></BLOCKQUOTE>
<P class="docText">Some vendors are changing their implementation of <TT>select</TT> to allow the process to define <TT>FD_SETSIZE</TT> to a larger value than the default. BSD/OS has changed the kernel implementation to allow larger descriptor sets, and it also provides four new <TT>FD_</TT><span class="docEmphasis">xxx</span> macros to dynamically allocate and manipulate these larger sets. From a portability standpoint, however, beware of using large descriptor sets.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch06lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch06lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
