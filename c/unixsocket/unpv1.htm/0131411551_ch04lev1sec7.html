<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.7 'fork' and 'exec' Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch04lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch04lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch04lev1sec7"></A>
<H3 class="docSection1Title">4.7 <TT>fork</TT> and <TT>exec</TT> Functions</H3>
<P class="docText">Before describing how to write a concurrent server in the next section, we must describe the Unix <TT>fork</TT> function. This function (including the variants of it provided by some systems) is the only way in Unix to create a new process.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;unistd.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>pid_t fork(void);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: 0 in child, process ID of child in parent, -1 on error</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">If you have never seen this function before, the hard part in understanding <TT>fork</TT> is that it is called <span class="docEmphasis">once</span> but it returns <span class="docEmphasis">twice</span>. It returns once in the calling process (called the parent) with a return value that is the process ID of the newly created process (the child). It also returns once in the child, with a return value of 0. Hence, the return value tells the process whether it is the parent or the child.</P>
<P class="docText">The reason <TT>fork</TT> returns 0 in the child, instead of the parent's process ID, is because a child has only one parent and it can always obtain the parent's process ID by calling <TT>getppid</TT>. A parent, on the other hand, can have any number of children, and there is no way to obtain the process IDs of its children. If a parent wants to keep track of the process IDs of all its children, it must record the return values from <TT>fork</TT>.</P>
<P class="docText">All descriptors open in the parent before the call to <TT>fork</TT> are shared with the child after <TT>fork</TT> returns. We will see this feature used by network servers: The parent calls <TT>accept</TT> and then calls <TT>fork</TT>. The connected socket is then shared between the parent and child. Normally, the child then reads and writes the connected socket and the parent closes the connected socket.</P>
<P class="docText">There are two typical uses of <TT>fork</TT>:</P>
<A NAME="ch04pro03"></A>


<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">A process makes a copy of itself so that one copy can handle one operation while the other copy does another task. This is typical for network servers. We will see many examples of this later in the text.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">A process wants to execute another program. Since the only way to create a new process is by calling <TT>fork</TT>, the process first calls <TT>fork</TT> to make a copy of itself, and then one of the copies (typically the child process) calls <TT>exec</TT> (described next) to replace itself with the new program. This is typical for programs such as shells.</P>
</span></LI></OL></span>
<P class="docText">The only way in which an executable program file on disk can be executed by Unix is for an existing process to call one of the six <TT>exec</TT> functions. (We will often refer generically to "the <TT>exec</TT> function" when it does not matter which of the six is called.) <TT>exec</TT> replaces the current process image with the new program file, and this new program normally starts at the <TT>main</TT> function. The process ID does not change. We refer to the process that calls <TT>exec</TT> as the <span class="docEmphasis">calling process</span> and the newly executed program as the <span class="docEmphasis">new program</span>.</P>
<BLOCKQUOTE><P><P class="docList">Older manuals and books incorrectly refer to the new program as the <span class="docEmphasis">new process</span>, which is wrong, because a new process is not created.</P></P></BLOCKQUOTE>
<P class="docText">The differences in the six <TT>exec</TT> functions are: (a) whether the program file to execute is specified by a <span class="docEmphasis">filename</span> or a <span class="docEmphasis">pathname</span>; (b) whether the arguments to the new program are listed one by one or referenced through an array of pointers; and (c) whether the environment of the calling process is passed to the new program or whether a new environment is specified.</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;unistd.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int execl (const char *</TT><span class="docEmphasis">pathname</span>, <TT>const char *</TT><span class="docEmphasis"><TT>arg</TT></span><TT>0, ... /* (char *) 0 */ );</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int execv (const char *</TT><span class="docEmphasis">pathname</span>, <TT>char *const</TT> <span class="docEmphasis">argv</span><TT>[]);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int execle (const char *</TT><span class="docEmphasis">pathname</span>, <TT>const char *</TT><span class="docEmphasis">arg</span><TT>0, ...</TT></P></TD></TR><TR><TD class="docTableCell" align="center" valign="top"><P class="docText"><TT>/* (char *) 0, char *const</TT> <span class="docEmphasis">envp</span><TT>[] */ );</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int execve (const char *</TT><span class="docEmphasis">pathname</span>, <TT>char *const</TT> <span class="docEmphasis">argv</span><TT>[], char *const</TT> <span class="docEmphasis">envp</span><TT>[]);</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int execlp (const char *</TT><span class="docEmphasis">filename</span>, <TT>const char *</TT><span class="docEmphasis">arg</span><TT>0, ... /* (char *) 0 */ );</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int execvp (const char *</TT><span class="docEmphasis">filename</span>, <TT>char *const</TT> <span class="docEmphasis">argv</span><TT>[]);</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">All six return: -1 on error, no return on success</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">These functions return to the caller only if an error occurs. Otherwise, control passes to the start of the new program, normally the <TT>main</TT> function.</P>
<P class="docText">The relationship among these six functions is shown in <A class="docLink" HREF="#ch04fig12">Figure 4.12</A>. Normally, only <TT>execve</TT> is a system call within the kernel and the other five are library functions that call <TT>execve</TT>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig12"></A>Figure 4.12. Relationship among the six <TT>exec</TT> functions.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="126" src="FILES/04fig12.gif" ALT="graphics/04fig12.gif"></p>

</CENTER>
<P class="docText">Note the following differences among these six functions:</P>
<A NAME="ch04pro04"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">The three functions in the top row specify each argument string as a separate argument to the <TT>exec</TT> function, with a null pointer terminating the variable number of arguments. The three functions in the second row have an <span class="docEmphasis">argv</span> array, containing pointers to the argument strings. This <span class="docEmphasis">argv</span> array must contain a null pointer to specify its end, since a count is not specified.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">The two functions in the left column specify a <span class="docEmphasis">filename</span> argument. This is converted into a <span class="docEmphasis">pathname</span> using the current <TT>PATH</TT> environment variable. If the <span class="docEmphasis">filename</span> argument to <TT>execlp</TT> or <TT>execvp</TT> contains a slash (/) anywhere in the string, the <TT>PATH</TT> variable is not used. The four functions in the right two columns specify a fully qualified <span class="docEmphasis">pathname</span> argument.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">The four functions in the left two columns do not specify an explicit environment pointer. Instead, the current value of the external variable <TT>environ</TT> is used for building an environment list that is passed to the new program. The two functions in the right column specify an explicit environment list. The <span class="docEmphasis">envp</span> array of pointers must be terminated by a null pointer.</P>
</span></LI></OL></span>
<P class="docText">Descriptors open in the process before calling <TT>exec</TT> normally remain open across the <TT>exec</TT>. We use the qualifier "normally" because this can be disabled using <TT>fcntl</TT> to set the <TT>FD_CLOEXEC</TT> descriptor flag. The <TT>inetd</TT> server uses this feature, as we will describe in <A class="docLink" HREF="0131411551_ch13lev1sec5.html#ch13lev1sec5">Section 13.5</A>.</P>

<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch04lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch04lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
