<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.7 Passing Descriptors"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch15lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch15lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec7"></A>
<H3 class="docSection1Title">15.7 Passing Descriptors</H3>
<P class="docText">When we think of passing an open descriptor from one process to another, we normally think of either</P>
<UL><LI><P class="docList">A child sharing all the open descriptors with the parent after a call to <TT>fork</TT></P></LI><LI><P class="docList">All descriptors normally remaining open when <TT>exec</TT> is called</P></LI></UL>
<P class="docText">In the first example, the process opens a descriptor, calls <TT>fork</TT>, and then the parent closes the descriptor, letting the child handle the descriptor. This passes an open descriptor from the parent to the child. But, we would also like the ability for the child to open a descriptor and pass it back to the parent.</P>
<P class="docText">Current Unix systems provide a way to pass any open descriptor from one process to any other process. That is, there is no need for the processes to be related, such as a parent and its child. The technique requires us to first establish a Unix domain socket between the two processes and then use <TT>sendmsg</TT> to send a special message across the Unix domain socket. This message is handled specially by the kernel, passing the open descriptor from the sender to the receiver.</P>
<BLOCKQUOTE><P><P class="docList">The black magic performed by the 4.4BSD kernel in passing an open descriptor across a Unix domain socket is described in detail in Chapter 18 of TCPv3.</P></P><P><P class="docList">SVR4 uses a different technique within the kernel to pass an open descriptor, the <TT>I_SENDFD</TT> and <TT>I_RECVFD ioctl</TT> commands, described in Section 15.5.1 of APUE. But, the process can still access this kernel feature using a Unix domain socket. In this text, we describe the use of Unix domain sockets to pass open descriptors, since this is the most portable programming technique: It works under both Berkeley-derived kernels and SVR4, whereas using the <TT>I_SENDFD</TT> and <TT>I_RECVFD ioctls</TT> works only under SVR4.</P></P><P><P class="docList">The 4.4BSD technique allows multiple descriptors to be passed with a single <TT>sendmsg</TT>, whereas the SVR4 technique passes only a single descriptor at a time. All our examples pass one descriptor at a time.</P></P></BLOCKQUOTE>
<P class="docText">The steps involved in passing a descriptor between two processes are then as follows:</P>
<A NAME="ch15pro01"></A>




<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docList">Create a Unix domain socket, either a stream socket or a datagram socket.</P>
<P class="docList">If the goal is to <TT>fork</TT> a child and have the child open the descriptor and pass the descriptor back to the parent, the parent can call <TT>socketpair</TT> to create a stream pipe that can be used to exchange the descriptor.</P>
<P class="docText">If the processes are unrelated, the server must create a Unix domain stream socket and <TT>bind</TT> a pathname to it, allowing the client to <TT>connect</TT> to that socket. The client can then send a request to the server to open some descriptor and the server can pass back the descriptor across the Unix domain socket. Alternately, a Unix domain datagram socket can also be used between the client and server, but there is little advantage in doing this, and the possibility exists for a datagram to be discarded. We will use a stream socket between the client and server in an example presented later in this section.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">One process opens a descriptor by calling any of the Unix functions that returns a descriptor: <TT>open</TT>, <TT>pipe</TT>, <TT>mkfifo</TT>, <TT>socket</TT>, or <TT>accept</TT>, for example. <span class="docEmphasis">Any</span> type of descriptor can be passed from one process to another, which is why we call the technique "descriptor passing" and not "file descriptor passing."</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">The sending process builds a <TT>msghdr</TT> structure (<A class="docLink" HREF="0131411551_ch14lev1sec5.html#ch14lev1sec5">Section 14.5</A>) containing the descriptor to be passed. POSIX specifies that the descriptor be sent as ancillary data (the <TT>msg_control</TT> member of the <TT>msghdr</TT> structure, <A class="docLink" HREF="0131411551_ch14lev1sec6.html#ch14lev1sec6">Section 14.6</A>), but older implementations use the <TT>msg_accrights</TT> member. The sending process calls <TT>sendmsg</TT> to send the descriptor across the Unix domain socket from Step 1. At this point, we say that the descriptor is "in flight." Even if the sending process closes the descriptor after calling <TT>sendmsg</TT>, but before the receiving process calls <TT>recvmsg</TT> (in the next step), the descriptor remains open for the receiving process. Sending a descriptor increments the descriptor's reference count by one.</P>
</span></LI><LI><span style="font-weight:normal" value="4"><P class="docText">The receiving process calls <TT>recvmsg</TT> to receive the descriptor on the Unix domain socket from Step 1. It is normal for the descriptor number in the receiving process to differ from the descriptor number in the sending process. Passing a descriptor is not passing a descriptor number, but involves creating a new descriptor in the receiving process that refers to the same file table entry within the kernel as the descriptor that was sent by the sending process.</P>
</span></LI></OL></span>
<P class="docText">The client and server must have some application protocol so that the receiver of the descriptor knows when to expect it. If the receiver calls <TT>recvmsg</TT> without allocating room to receive the descriptor, and a descriptor was passed and is ready to be read, the descriptor that was being passed is closed (p. 518 of TCPv2). Also, the <TT>MSG_PEEK</TT> flag should be avoided with <TT>recvmsg</TT> if a descriptor is expected, as the result is unpredictable.</P>
<A NAME="ch15lev2sec2"></A>
<H4 class="docSection2Title"> Descriptor Passing Example</H4>
<P class="docText">We now provide an example of descriptor passing. We will write a program named <TT>mycat</TT> that takes a pathname as a command-line argument, opens the file, and copies it to standard output. But instead of calling the normal Unix <TT>open</TT> function, we call our own function named <TT>my_open</TT>. This function creates a stream pipe and calls <TT>fork</TT> and <TT>exec</TT> to initiate another program that opens the desired file. This program must then pass the open descriptor back to the parent across the stream pipe.</P>
<P class="docText"><A class="docLink" HREF="#ch15fig07">Figure 15.7</A> shows the first step: our <TT>mycat</TT> program after creating a stream pipe by calling <TT>socketpair</TT>. We designate the two descriptors returned by <TT>socketpair</TT> as <TT>[0]</TT> and <TT>[1]</TT>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch15fig07"></A>Figure 15.7. <TT>mycat</TT> program after creating stream pipe using <TT>socketpair</TT>.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="105" HEIGHT="117" src="FILES/15fig07.gif" ALT="graphics/15fig07.gif"></p>

</CENTER>
<P class="docText">The process then calls <TT>fork</TT> and the child calls <TT>exec</TT> to execute the <TT>openfile</TT> program. The parent closes the <TT>[1]</TT> descriptor and the child closes the <TT>[0]</TT> descriptor. (There is no difference in either end of the stream pipe; the child could close <TT>[1]</TT> and the parent could close <TT>[0]</TT>.) This gives us the arrangement shown in <A class="docLink" HREF="#ch15fig08">Figure 15.8</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch15fig08"></A>Figure 15.8. <TT>mycat</TT> program after invoking <TT>openfile</TT> program.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="456" HEIGHT="205" src="FILES/15fig08.gif" ALT="graphics/15fig08.gif"></p>

</CENTER>
<P class="docText">The parent must pass three pieces of information to the <TT>openfile</TT> program: (i) the pathname of the file to open, (ii) the open mode (read-only, read–write, or write-only), and (iii) the descriptor number corresponding to its end of the stream pipe (what we show as <TT>[1]</TT>). We choose to pass these three items as command-line arguments in the call to <TT>exec</TT>. An alternative method is to send these three items as data across the stream pipe. The <TT>openfile</TT> program sends back the open descriptor across the stream pipe and terminates. The exit status of the program tells the parent whether the file could be opened, and if not, what type of error occurred.</P>
<P class="docText">The advantage in executing another program to open the file is that the program could be a "set-user-ID" binary, which executes with root privileges, allowing it to open files that we normally do not have permission to open. This program could extend the concept of normal Unix permissions (user, group, and other) to any form of access checking it desires.</P>
<P class="docText">We begin with the <TT>mycat</TT> program, shown in <A class="docLink" HREF="#ch15fig09">Figure 15.9</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig09"></A>Figure 15.9 <TT>mycat</TT> program: copies a file to standard output.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/mycat.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int      my_open(const char *, int);

 3 int
 4 main(int argc, char **argv)
 5 {
 6     int     fd, n;
 7     char    buff[BUFFSIZE];

 8     if (argc != 2)
 9         err_quit("usage: mycat &lt;pathname&gt;");

10     if ( (fd = my_open(argv[1], O_RDONLY)) &lt; 0)
11         err_sys("cannot open %s", argv[1]);

12     while ( (n = Read(fd, buff, BUFFSIZE)) &gt; 0)
13         Write(STDOUT_FILENO, buff, n);

14     exit(0);
15 }
</PRE>

<P class="docText">If we replace the call to <TT>my_open</TT> with a call to <TT>open</TT>, this simple program just copies a file to standard output.</P>
<P class="docText">The function <TT>my_open</TT>, shown in <A class="docLink" HREF="#ch15fig10">Figure 15.10</A>, is intended to look like the normal Unix <TT>open</TT> function to its caller. It takes two arguments, a pathname and an open mode (such as <TT>O_RDONLY</TT> to mean read-only), opens the file, and returns a descriptor.</P>
<A NAME="ch15lev3sec3"></A>
<H5 class="docSection3Title"> Create stream pipe</H5>
<p class="docText"><span class="docEmphasis"><TT>8</TT></span> <TT>socketpair</TT> creates a stream pipe. Two descriptors are returned: <TT>sockfd[0]</TT> and <TT>sockfd[1]</TT>. This is the state we show in <A class="docLink" HREF="#ch15fig07">Figure 15.7</A>.</p>

<A NAME="ch15lev3sec4"></A>
<H5 class="docSection3Title"> <TT>fork</TT> and <TT>exec</TT></H5>
<p class="docText"><span class="docEmphasis"><TT>9–16</TT></span> <TT>fork</TT> is called, and the child then closes one end of the stream pipe. The descriptor number of the other end of the stream pipe is formatted into the <TT>argsockfd</TT> array and the open mode is formatted into the <TT>argmode</TT> array. We call <TT>snprintf</TT> because the arguments to <TT>exec</TT> must be character strings. The <TT>openfile</TT> program is executed. The <TT>execl</TT> function should not return unless it encounters an error. On success, the <TT>main</TT> function of the <TT>openfile</TT> program starts executing.</p>

<A NAME="ch15lev3sec5"></A>
<H5 class="docSection3Title"> Parent waits for child</H5>
<p class="docText"><span class="docEmphasis"><TT>17–22</TT></span> The parent closes the other end of the stream pipe and calls <TT>waitpid</TT> to wait for the child to terminate. The termination status of the child is returned in the variable <TT>status</TT>, and we first verify that the program terminated normally (i.e., it was not terminated by a signal). The <TT>WEXITSTATUS</TT> macro then converts the termination status into the exit status, whose value will be between 0 and 255. We will see shortly that if the <TT>openfile</TT> program encounters an error opening the requested file, it terminates with the corresponding <TT>errno</TT> value as its exit status.</p>

<H5 class="docExampleTitle"><A NAME="ch15fig10"></A>Figure 15.10 <TT>my_open</TT> function: opens a file and returns a descriptor.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/myopen.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 int
 3 my_open(const char *pathname, int mode)
 4 {
 5     int     fd, sockfd[2], status;
 6     pid_t   childpid;
 7     char    c, argsockfd[10], argmode[10];

 8     Socketpair(AF_LOCAL, SOCK_STREAM, 0, sockfd);

 9     if ( (childpid = Fork()) == 0) { /* child process */
10         Close(sockfd[0]);
11         snprintf(argsockfd, sizeof(argsockfd), "%d", sockfd[1]);
12         snprintf(argmode, sizeof(argmode), "%d", mode);
13         execl("./openfile", "openfile", argsockfd, pathname, argmode,
14               (char *) NULL);
15         err_sys("execl error");
16     }

17     /* parent process - wait for the child to terminate */
18     Close(sockfd[1]);           /* close the end we don't use */

19     Waitpid(childpid, &amp;status, 0);
20     if (WIFEXITED(status) == 0)
21         err_quit("child did not terminate");
22     if ( (status = WEXITSTATUS(status)) == 0)
23         Read_fd(sockfd[0], &amp;c, 1, &amp;fd);
24     else {
25         errno = status;         /* set errno value from child's status */
26         fd = -1;
27     }

28     Close(sockfd[0]);
29     return (fd);
30 }
</PRE>


<A NAME="ch15lev3sec6"></A>
<H5 class="docSection3Title"> Receive descriptor</H5>
<p class="docText"><span class="docEmphasis"><TT>23</TT></span> Our function <TT>read_fd</TT>, shown next, receives the descriptor on the stream pipe. In addition to the descriptor, we read one byte of data, but do nothing with it.</p>
<BLOCKQUOTE><P><P class="docList">When sending and receiving a descriptor across a stream pipe, we always send at least one byte of data, even if the receiver does nothing with the data. Otherwise, the receiver cannot tell whether a return value of 0 from <TT>read_fd</TT> means "no data (but possibly a descriptor)" or "end-of-file."</P></P></BLOCKQUOTE>
<P class="docText"><A class="docLink" HREF="#ch15fig11">Figure 15.11</A> shows the <TT>read_fd</TT> function, which calls <TT>recvmsg</TT> to receive data and a descriptor on a Unix domain socket. The first three arguments to this function are the same as for the <TT>read</TT> function, with a fourth argument being a pointer to an integer that will contain the received descriptor on return.</P>
<p class="docText"><span class="docEmphasis"><TT>9–26</TT></span> This function must deal with two versions of <TT>recvmsg:</TT> those with the <TT>msg_control</TT> member and those with the <TT>msg_accrights</TT> member. Our <TT>config.h</TT> header (<A class="docLink" HREF="0131411551_app04lev1sec2.html#app04fig02">Figure D.2</A>) defines the constant <TT>HAVE_MSGHDR_MSG_CONTROL</TT> if the <TT>msg_control</TT> version is supported.</p>

<A NAME="ch15lev3sec7"></A>
<H5 class="docSection3Title"> Make certain <TT>msg_control</TT> is suitably aligned</H5>
<p class="docText"><span class="docEmphasis"><TT>10–13</TT></span> The <TT>msg_control</TT> buffer must be suitably aligned for a <TT>cmsghdr</TT> structure. Simply allocating a <TT>char</TT> array is inadequate. Here we declare a <TT>union</TT> of a <TT>cmsghdr</TT> structure with the character array, which guarantees that the array is suitably aligned. Another technique is to call <TT>malloc</TT>, but that would require freeing the memory before the function returns.</p>
<p class="docText"><span class="docEmphasis"><TT>27–45</TT></span> <TT>recvmsg</TT> is called. If ancillary data is returned, the format is as shown in <A class="docLink" HREF="0131411551_ch14lev1sec6.html#ch14fig13">Figure 14.13</A>. We verify that the length, level, and type are correct, then fetch the newly created descriptor and return it through the caller's <TT>recvfd</TT> pointer. <TT>CMSG_DATA</TT> returns the pointer to the <TT>cmsg_data</TT> member of the ancillary data object as an <TT>unsigned char</TT> pointer. We cast this to an <TT>int</TT> pointer and fetch the integer descriptor that is pointed to.</p>

<H5 class="docExampleTitle"><A NAME="ch15fig11"></A>Figure 15.11 <TT>read_fd</TT> function: receives data and a descriptor.</H5>
<P class="docText"><span class="docEmphasis">lib/read_fd.c</span></P>

<PRE>
 1 #include     "unp.h"

 2 ssize_t
 3 read_fd(int fd, void *ptr, size_t nbytes, int *recvfd)
 4 {
 5     struct msghdr msg;
 6     struct iovec iov[1];
 7     ssize_t n;

 8 #ifdef HAVE_MSGHDR_MSG_CONTROL
 9     union {
10         struct cmsghdr cm;
11         char     control[CMSG_SPACE(sizeof (int))];
12     } control_un;
13     struct cmsghdr  *cmptr;

14     msg.msg_control  = control_un.control;
15     msg.msg_controllen = sizeof(control_un.control);
16 #else
17     int     newfd;

18     msg.msg_accrights = (caddr_t) &amp; newfd;
19     msg.msg_accrightslen = sizeof(int);
20 #endif

21     msg.msg_name = NULL;
22     msg.msg_namelen = 0;

23     iov[0].iov_base = ptr;
24     iov[0].iov_len = nbytes;
25     msg.msg_iov = iov;
26     msg.msg_iovlen = 1;

27     if ( (n = recvmsg(fd, &amp;msg, 0)) &lt;= 0)
28         return (n);

29 #ifdef  HAVE_MSGHDR_MSG_CONTROL
30     if ( (cmptr = CMSG_FIRSTHDR(&amp;msg)) != NULL &amp;&amp;
31         cmptr-&gt;cmsg_len == CMSG_LEN(sizeof(int))) {
32         if (cmptr-&gt;cmsg_level != SOL_SOCKET)
33             err_quit("control level != SOL_SOCKET");
34         if (cmptr-&gt;cmsg_type != SCM_RIGHTS)
35             err_quit("control type != SCM_RIGHTS");
36         *recvfd = *((int *) CMSG_DATA(cmptr));
37     } else
38         *recvfd = -1;           /* descriptor was not passed */
39 #else
40     if (msg.msg_accrightslen == sizeof(int))
41         *recvfd = newfd;
42     else
43         *recvfd = -1;       /* descriptor was not passed */
44 #endif

45     return (n);
46 }
</PRE>

<P class="docText">If the older <TT>msg_accrights</TT> member is supported, the length should be the size of an integer and the newly created descriptor is returned through the caller's <TT>recvfd</TT> pointer.</P>
<P class="docText"><A class="docLink" HREF="#ch15fig12">Figure 15.12</A> shows the <TT>openfile</TT> program. It takes the three command-line arguments that must be passed and calls the normal <TT>open</TT> function.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig12"></A>Figure 15.12 <TT>openfile</TT> function: opens a file and passes back the descriptor.</H5>
<P class="docText"><span class="docEmphasis">unixdomain/openfile.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 int
 3 main(int argc, char **argv)
 4 {
 5     int     fd;

 6     if (argc != 4)
 7         err_quit("openfile &lt;sockfd#&gt; &lt;filename&gt; &lt;mode&gt;");

 8     if ( (fd = open(argv[2], atoi(argv[3]))) &lt; 0)
 9         exit((errno &gt; 0) ? errno : 255);

10     if (write_fd(atoi(argv[1]), "", 1, fd) &lt; 0)
11         exit((errno &gt; 0) ? errno : 255);

12     exit(0);
13 }
</PRE>


<A NAME="ch15lev3sec8"></A>
<H5 class="docSection3Title"> Command-line arguments</H5>
<p class="docText"><span class="docEmphasis"><TT>7–12</TT></span> Since two of the three command-line arguments were formatted into character strings by <TT>my_open</TT>, two are converted back into integers using <TT>atoi</TT>.</p>

<A NAME="ch15lev3sec9"></A>
<H5 class="docSection3Title"> <TT>open</TT> the file</H5>
<p class="docText"><span class="docEmphasis"><TT>9–10</TT></span> The file is opened by calling <TT>open</TT>. If an error is encountered, the <TT>errno</TT> value corresponding to the <TT>open</TT> error is returned as the exit status of the process.</p>

<A NAME="ch15lev3sec10"></A>
<H5 class="docSection3Title"> Pass back descriptor</H5>
<p class="docText"><span class="docEmphasis"><TT>11–12</TT></span> The descriptor is passed back by <TT>write_fd</TT>, which we show next. This process then terminates. But, recall that earlier in the chapter, we said that it was acceptable for the sending process to close the descriptor that was passed (which happens when we call <TT>exit</TT>), because the kernel knows that the descriptor is in flight, and keeps it open for the receiving process.</p>
<BLOCKQUOTE><P><P class="docList">The exit status must be between 0 and 255. The highest <TT>errno</TT> value is around 150. An alternate technique that doesn't require the <TT>errno</TT> values to be less than 256 would be to pass back an error indication as normal data in the call to <TT>sendmsg</TT>.</P></P></BLOCKQUOTE>
<P class="docText"><A class="docLink" HREF="#ch15fig13">Figure 15.13</A> shows the final function, <TT>write_fd</TT>, which calls <TT>sendmsg</TT> to send a descriptor (and optional data, which we do not use) across a Unix domain socket.</P>

<H5 class="docExampleTitle"><A NAME="ch15fig13"></A>Figure 15.13 <TT>write_fd</TT> function: passes a descriptor by calling <TT>sendmsg</TT>.</H5>
<P class="docText"><span class="docEmphasis">lib/write_fd.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 ssize_t
 3 write_fd(int fd, void *ptr, size_t nbytes, int sendfd)
 4 {
 5     struct msghdr msg;
 6     struct iovec iov[1];

 7 #ifdef  HAVE_MSGHDR_MSG_CONTROL
 8     union {
 9         struct cmsghdr cm;
10         char    control[CMSG_SPACE(sizeof(int))];
11     } control_un;
12     struct cmsghdr *cmptr;

13     msg.msg_control = control_un.control;
14     msg.msg_controllen = sizeof(control_un.control);

15     cmptr = CMSG_FIRSTHDR(&amp;msg);
16     cmptr-&gt;cmsg_len = CMSG_LEN(sizeof(int));
17     cmptr-&gt;cmsg_level = SOL_SOCKET;
18     cmptr-&gt;cmsg_type = SCM_RIGHTS;
19     *((int *) CMSG_DATA(cmptr)) = sendfd;
20 #else
21     msg.msg_accrights = (caddr_t) &amp; sendfd;
22     msg.msg_accrightslen = sizeof(int);
23 #endif

24     msg.msg_name = NULL;
25     msg.msg_namelen = 0;

26     iov[0].iov_base = ptr;
27     iov[0].iov_len = nbytes;
28     msg.msg_iov = iov;
29     msg.msg_iovlen = 1;

30     return (sendmsg(fd, &amp;msg, 0));
31 }
</PRE>

<P class="docText">As with <TT>read_fd</TT>, this function must deal with either ancillary data or older access rights. In either case, the <TT>msghdr</TT> structure is initialized and then <TT>sendmsg</TT> is called.</P>
<P class="docText">We will show an example of descriptor passing in <A class="docLink" HREF="0131411551_ch28lev1sec7.html#ch28lev1sec7">Section 28.7</A> that involves unrelated processes. Additionally, we will show an example in <A class="docLink" HREF="0131411551_ch30lev1sec9.html#ch30lev1sec9">Section 30.9</A> that involves related processes. We will use the <TT>read_fd</TT> and <TT>write_fd</TT> functions we just described.</P>



<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch15lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch15lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
