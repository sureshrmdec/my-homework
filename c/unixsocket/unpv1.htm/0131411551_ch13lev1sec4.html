<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="13.4 'daemon_init' Function"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch13lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch13lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch13lev1sec4"></A>
<H3 class="docSection1Title">13.4 <TT>daemon_init</TT> Function</H3>
<P class="docText"><A class="docLink" HREF="#ch13fig04">Figure 13.4</A> shows a function named <TT>daemon_init</TT> that we can call (normally from a server) to daemonize the process. This function should be suitable for use on all variants of Unix, but some offer a C library function called <TT>daemon</TT> that provides similar features. BSD offers the <TT>daemon</TT> function, as does Linux.</P>

<H5 class="docExampleTitle"><A NAME="ch13fig04"></A>Figure 13.4 <TT>daemon_init</TT> function: daemonizes the process.</H5>
<P class="docText"><span class="docEmphasis">daemon_init.c</span></P>

<PRE>
 1 #include    "unp.h"
 2 #include    &lt;syslog.h&gt;

 3 #define MAXFD   64

 4 extern int daemon_proc;         /* defined in error.c */

 5 int
 6 daemon_init(const char *pname, int facility)
 7 {
 8     int     i;
 9     pid_t     pid;

10     if ( (pid = Fork()) &lt; 0)
11         return (-1);
12     else if (pid)
13         _exit(0);               /* parent terminates */

14     /* child 1 continues... */

15     if (setsid() &lt; 0)           /* become session leader */
16         return (-1);

17     Signal(SIGHUP, SIG_IGN);
18     if ( (pid = Fork()) &lt; 0)
19         return (-1);
20     else if (pid)
21         _exit(0);               /* child 1 terminates */

22     /* child 2 continues... */

23     daemon_proc = 1;            /* for err_XXX() functions */

24     chdir("/");                 /* change working directory */

25     /* close off file descriptors */
26     for (i = 0; i &lt; MAXFD; i++)
27         close(i);

28     /* redirect stdin, stdout, and stderr to /dev/null */
29     open("/dev/null", O_RDONLY);
30     open("/dev/null", O_RDWR);
31     open("/dev/null", O_RDWR);

32     openlog(pname, LOG_PID, facility);

33     return (0);                 /* success */
34 }
</PRE>

<A NAME="ch13lev3sec1"></A>
<H4 class="docSection2Title"> fork</H4>
<p class="docText"><span class="docEmphasis"><TT>10–13</TT></span> We first call <TT>fork</TT> and then the parent terminates, and the child continues. If the process was started as a shell command in the foreground, when the parent terminates, the shell thinks the command is done. This automatically runs the child process in the background. Also, the child inherits the process group ID from the parent but gets its own process ID. This guarantees that the child is not a process group leader, which is required for the next call to <TT>setsid</TT>.</p>

<A NAME="ch13lev3sec2"></A>
<H4 class="docSection2Title"> <TT>setsid</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>15–16</TT></span> <TT>setsid</TT> is a POSIX function that creates a new session. (Chapter 9 of APUE talks about process relationships and sessions in detail.) The process becomes the session leader of the new session, becomes the process group leader of a new process group, and has no controlling terminal.</p>

<A NAME="ch13lev3sec3"></A>
<H4 class="docSection2Title"> Ignore <TT>SIGHUP</TT> and <TT>Fork</TT> Again</H4>
<p class="docText"><span class="docEmphasis"><TT>17–21</TT></span> We ignore <TT>SIGHUP</TT> and call <TT>fork</TT> again. When this function returns, the parent is really the first child and it terminates, leaving the second child running. The purpose of this second <TT>fork</TT> is to guarantee that the daemon cannot automatically acquire a controlling terminal should it open a terminal device in the future. When a session leader without a controlling terminal opens a terminal device (that is not currently some other session's controlling terminal), the terminal becomes the controlling terminal of the session leader. But by calling <TT>fork</TT> a second time, we guarantee that the second child is no longer a session leader, so it cannot acquire a controlling terminal. We must ignore <TT>SIGHUP</TT> because when the session leader terminates (the first child), all processes in the session (our second child) receive the <TT>SIGHUP</TT> signal.</p>

<A NAME="ch13lev3sec4"></A>
<H4 class="docSection2Title"> Set Flag for Error Functions</H4>
<p class="docText"><span class="docEmphasis"><TT>23</TT></span> We set the global <TT>daemon_proc</TT> to nonzero. This external is defined by our <TT>err_</TT><span class="docEmphasis"><TT>XXX</TT></span> functions (<A class="docLink" HREF="0131411551_app04lev1sec3.html#app04lev1sec3">Section D.3</A>), and when its value is nonzero, this tells them to call <TT>syslog</TT> instead of doing an <TT>fprintf</TT> to standard error. This saves us from having to go through all our code and call one of our error functions if the server is not being run as a daemon (i.e., when we are testing the server), but call <TT>syslog</TT> if it is being run as a daemon.</p>

<A NAME="ch13lev3sec5"></A>
<H4 class="docSection2Title"> Change Working Directory</H4>
<p class="docText"><span class="docEmphasis"><TT>24</TT></span> We change the working directory to the root directory, although some daemons might have a reason to change to some other directory. For example, a printer daemon might change to the printer's spool directory, where it does all its work. Should the daemon ever generate a <TT>core</TT> file, that file is generated in the current working directory. Another reason to change the working directory is that the daemon could have been started in any filesystem, and if it remains there, that filesystem cannot be unmounted (at least not without using some potentially destructive, forceful measures).</p>

<A NAME="ch13lev3sec6"></A>
<H4 class="docSection2Title"> Close any open descriptors</H4>
<p class="docText"><span class="docEmphasis"><TT>25–27</TT></span> We close any open descriptors that are inherited from the process that executed the daemon (normally a shell). The problem is determining the highest descriptor in use: There is no Unix function that provides this value. There are ways to determine the maximum number of descriptors that the process can open, but even this gets complicated (see p. 43 of APUE) because the limit can be infinite. Our solution is to close the first 64 descriptors, even though most of these are probably not open.</p>
<BLOCKQUOTE><P><P class="docList">Solaris provides a function called <TT>closefrom</TT> for use by daemons to solve this problem.</P></P></BLOCKQUOTE>

<A NAME="ch13lev3sec7"></A>
<H4 class="docSection2Title"> Redirect <TT>stdin</TT>, <TT>stdout</TT>, and <TT>stderr</TT> to <TT>/dev/null</TT></H4>
<p class="docText"><span class="docEmphasis"><TT>29–31</TT></span> We <TT>open/dev/null</TT> for standard input, standard output, and standard error. This guarantees that these common descriptors are open, and a read from any of these descriptors returns 0 (EOF), and the kernel just discards anything written to them. The reason for opening these descriptors is so that any library function called by the daemon that assumes it can read from standard input or write to either standard output or standard error will not fail. Such a failure is potentially dangerous. If the daemon ends up opening a socket to a client, that socket descriptor ends up as <TT>stdout</TT> or <TT>stderr</TT> and some erroneous call to something like <TT>perror</TT> then sends unexpected data to a client.</p>

<A NAME="ch13lev3sec8"></A>
<H4 class="docSection2Title"> Use <TT>syslogd</TT> for Errors</H4>
<p class="docText"><span class="docEmphasis"><TT>32</TT></span> <TT>Openlog</TT> is called. The first argument is from the caller and is normally the name of the program (e.g., <TT>argv[0]</TT>). We specify that the process ID should be added to each log message. The <span class="docEmphasis">facility</span> is also specified by the caller, as one of the values from <A class="docLink" HREF="0131411551_ch13lev1sec3.html#ch13fig02">Figure 13.2</A> or 0 if the default of <TT>LOG_USER</TT> is acceptable.</p>
<P class="docText">We note that since a daemon runs without a controlling terminal, it should never receive the <TT>SIGHUP</TT> signal from the kernel. Therefore, many daemons use this signal as a notification from the administrator that the daemon's configuration file has changed, and the daemon should reread the file. Two other signals that a daemon should never receive are <TT>SIGINT</TT> and <TT>SIGWINCH</TT>, so daemons can safely use these signals as another way for administrators to indicate some change that the daemon should react to.</P>

<A NAME="ch13lev2sec1"></A>
<H4 class="docSection2Title"> Example: Daytime Server as a Daemon</H4>
<P class="docText"><A class="docLink" HREF="#ch13fig05">Figure 13.5</A> is a modification of our protocol-independent daytime server from <A class="docLink" HREF="0131411551_ch11lev1sec13.html#ch11fig14">Figure 11.14</A> that calls our <TT>daemon_init</TT> function to run as daemons.</P>
<P class="docText">There are only two changes: We call our <TT>daemon_init</TT> function as soon as the program starts, and we call our <TT>err_msg</TT> function, instead of <TT>printf</TT>, to print the client's IP address and port. Indeed, if we want our programs to be able to run as a daemon, we must avoid calling the <TT>printf</TT> and <TT>fprintf</TT> functions and use our <TT>err_msg</TT> function instead.</P>
<P class="docText">Note how we check <TT>argc</TT> and issue the appropriate usage message <span class="docEmphasis">before</span> calling <TT>daemon_init</TT>. This allows the user starting the daemon to get immediate feedback if the command has the incorrect number of arguments. After calling <TT>daemon_init</TT>, all subsequent error messages go to syslog.</P>
<P class="docText">If we run this program on our Linux host <TT>linux</TT> and then check the <TT>/var/log/messages</TT> file (where we send all <TT>LOG_USER</TT> messages) after connecting from the same machine (e.g., localhost), we have</P>
<pre>

</pre><pre>
Jun 10 09:54:37 linux daytimetcpsrv2[24288]:
connection from 127.0.0.1.55862
</pre><pre>
</pre>
<P class="docText">(We have wrapped the one long line.) The date, time, and hostname are prefixed automatically by the <TT>syslogd</TT> daemon.</P>

<H5 class="docExampleTitle"><A NAME="ch13fig05"></A>Figure 13.5 Protocol-independent daytime server that runs as a daemon.</H5>
<P class="docText"><span class="docEmphasis">inetd/daytimetcpsrv2.c</span></P>

<PRE>
 1 #include     "unp.h"
 2 #include     &lt;time.h&gt;

 3 int
 4 main(int argc, char **argv)
 5 {
 6     int     listenfd, connfd;
 7     socklen_t addrlen, len;
 8     struct sockaddr *cliaddr;
 9     char     buff[MAXLINE];
10     time_t ticks;

11     if (argc &lt; 2 || argc &gt; 3)
12         err_quit("usage: daytimetcpsrv2 [ &lt;host&gt; ] &lt;service or port&gt;");

13     daemon_init(argv[0], 0);

14     if (argc == 2)
15         listenfd = Tcp_listen(NULL, argv[1], &amp;addrlen);
16     else
17         listenfd = Tcp_listen(argv[1], argv[2], &amp;addrlen);

18     cliaddr = Malloc(addrlen);

19     for ( ; ; ) {
20         len = addrlen;
21         connfd = Accept(listenfd, cliaddr, &amp;len);
22         err_msg("connection from %s", Sock_ntop(cliaddr, len));

23         ticks = time(NULL);
24         snprintf(buff, sizeof(buff), "%.24s/r/n", ctime(&amp;ticks));
25         Write(connfd, buff, strlen(buff));

26         Close(connfd);
27     }
28 }
</PRE>



<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch13lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch13lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
