<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.6 TCP Connection Establishment and Termination"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch02lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch02lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch02lev1sec6"></A>
<H3 class="docSection1Title">2.6 TCP Connection Establishment and Termination</H3>
<P class="docText">To aid in our understanding of the <TT>connect</TT>, <TT>accept</TT>, and <TT>close</TT> functions and to help us debug TCP applications using the <TT>netstat</TT> program, we must understand how TCP connections are established and terminated, and TCP's state transition diagram.</P>
<A NAME="ch02lev2sec1"></A>
<H4 class="docSection2Title"> Three-Way Handshake</H4>
<P class="docText">The following scenario occurs when a TCP connection is established:</P>
<A NAME="ch02pro01"></A>




<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">The server must be prepared to accept an incoming connection. This is normally done by calling <TT>socket</TT>, <TT>bind</TT>, and <TT>listen</TT> and is called a <span class="docEmphasis">passive open</span>.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">The client issues an <span class="docEmphasis">active open</span> by calling <TT>connect</TT>. This causes the client TCP to send a "synchronize" (SYN) segment, which tells the server the client's initial sequence number for the data that the client will send on the connection. Normally, there is no data sent with the SYN; it just contains an IP header, a TCP header, and possible TCP options (which we will talk about shortly).</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">The server must acknowledge (ACK) the client's SYN and the server must also send its own SYN containing the initial sequence number for the data that the server will send on the connection. The server sends its SYN and the ACK of the client's SYN in a single segment.</P>
</span></LI><LI><span style="font-weight:normal" value="4"><P class="docText">The client must acknowledge the server's SYN.</P>
</span></LI></OL></span>
<P class="docText">The minimum number of packets required for this exchange is three; hence, this is called TCP's <span class="docEmphasis">three-way handshake</span>. We show the three segments in <A class="docLink" HREF="#ch02fig02">Figure 2.2</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch02fig02"></A>Figure 2.2. TCP three-way handshake.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="192" src="FILES/02fig02.gif" ALT="graphics/02fig02.gif"></p>

</CENTER>
<P class="docText">We show the client's initial sequence number as <span class="docEmphasis">J</span> and the server's initial sequence number as <span class="docEmphasis">K</span>. The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK. Since a SYN occupies one byte of the sequence number space, the acknowledgment number in the ACK of each SYN is the initial sequence number plus one. Similarly, the ACK of each FIN is the sequence number of the FIN plus one.</P>
<BLOCKQUOTE><P><P class="docList">An everyday analogy for establishing a TCP connection is the telephone system [Nemeth 1997]. The <TT>socket</TT> function is the equivalent of having a telephone to use. <TT>bind</TT> is telling other people your telephone number so that they can call you. <TT>listen</TT> is turning on the ringer so that you will hear when an incoming call arrives. <TT>connect</TT> requires that we know the other person's phone number and dial it. <TT>accept</TT> is when the person being called answers the phone. Having the client's identity returned by <TT>accept</TT> (where the identify is the client's IP address and port number) is similar to having the caller ID feature show the caller's phone number. One difference, however, is that <TT>accept</TT> returns the client's identity only after the connection has been established, whereas the caller ID feature shows the caller's phone number before we choose whether to answer the phone or not. If the DNS is used (<A class="docLink" HREF="0131411551_ch11.html#ch11">Chapter 11</A>), it provides a service analogous to a telephone book. <TT>getaddrinfo</TT> is similar to looking up a person's phone number in the phone book. <TT>getnameinfo</TT> would be the equivalent of having a phone book sorted by telephone numbers that we could search, instead of a book sorted by name.</P></P></BLOCKQUOTE>

<A NAME="ch02lev2sec2"></A>
<H4 class="docSection2Title"> TCP Options</H4>
<P class="docText">Each SYN can contain TCP options. Commonly used options include the following:</P>
<UL><LI><p class="docText"><span class="docEmphRoman">MSS option.</span> With this option, the TCP sending the SYN announces its <span class="docEmphasis">maximum segment size</span>, the maximum amount of data that it is willing to accept in each TCP segment, on this connection. The sending TCP uses the receiver's MSS value as the maximum size of a segment that it sends. We will see how to fetch and set this TCP option with the <TT>TCP_MAXSEG</TT> socket option (<A class="docLink" HREF="0131411551_ch07lev1sec9.html#ch07lev1sec9">Section 7.9</A>).</p></LI><LI><p class="docText"><span class="docEmphRoman">Window scale option.</span> The maximum window that either TCP can advertise to the other TCP is 65,535, because the corresponding field in the TCP header occupies 16 bits. But, high-speed connections, common in today's Internet (45 Mbits/sec and faster, as described in RFC 1323 [Jacobson, Braden, and Borman 1992]), or long delay paths (satellite links) require a larger window to obtain the maximum throughput possible. This newer option specifies that the advertised window in the TCP header must be scaled (left-shifted) by 0–14 bits, providing a maximum window of almost one gigabyte (65,535 x 2<SUP>14</SUP>). Both end-systems must support this option for the window scale to be used on a connection. We will see how to affect this option with the <TT>SO_RCVBUF</TT> socket option (<A class="docLink" HREF="0131411551_ch07lev1sec5.html#ch07lev1sec5">Section 7.5</A>).</p><BLOCKQUOTE><P><P class="docList">To provide interoperability with older implementations that do not support this option, the following rules apply. TCP can send the option with its SYN as part of an active open. But, it can scale its windows only if the other end also sends the option with its SYN. Similarly, the server's TCP can send this option only if it receives the option with the client's SYN. This logic assumes that implementations ignore options that they do not understand, which is required and common, but unfortunately, not guaranteed with all implementations.</P></P></BLOCKQUOTE></LI><LI><p class="docText"><span class="docEmphRoman">Timestamp option.</span> This option is needed for high-speed connections to prevent possible data corruption caused by old, delayed, or duplicated segments. Since it is a newer option, it is negotiated similarly to the window scale option. As network programmers there is nothing we need to worry about with this option.</p></LI></UL>
<P class="docText">These common options are supported by most implementations. The latter two are sometimes called the "RFC 1323 options," as that RFC [Jacobson, Braden, and Borman 1992] specifies the options. They are also called the "long fat pipe options," since a network with either a high bandwidth or a long delay is called a <span class="docEmphasis">long fat pipe</span>. Chapter 24 of TCPv1 contains more details on these options.</P>

<A NAME="ch02lev2sec3"></A>
<H4 class="docSection2Title"> TCP Connection Termination</H4>
<P class="docText">While it takes three segments to establish a connection, it takes four to terminate a connection.</P>
<A NAME="ch02pro02"></A>




<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">One application calls <TT>close</TT> first, and we say that this end performs the <span class="docEmphasis">active close</span>. This end's TCP sends a FIN segment, which means it is finished sending data.</P>
</span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">The other end that receives the FIN performs the <span class="docEmphasis">passive close</span>. The received FIN is acknowledged by TCP. The receipt of the FIN is also passed to the application as an end-of-file (after any data that may have already been queued for the application to receive), since the receipt of the FIN means the application will not receive any additional data on the connection.</P>
</span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">Sometime later, the application that received the end-of-file will <TT>close</TT> its socket. This causes its TCP to send a FIN.</P>
</span></LI><LI><span style="font-weight:normal" value="4"><P class="docText">The TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN.</P>
</span></LI></OL></span>
<P class="docText">Since a FIN and an ACK are required in each direction, four segments are normally required. We use the qualifier "normally" because in some scenarios, the FIN in Step 1 is sent with data. Also, the segments in Steps 2 and 3 are both from the end performing the passive close and could be combined into one segment. We show these packets in <A class="docLink" HREF="#ch02fig03">Figure 2.3</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch02fig03"></A>Figure 2.3. Packets exchanged when a TCP connection is closed.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="241" src="FILES/02fig03.gif" ALT="graphics/02fig03.gif"></p>

</CENTER>
<P class="docText">A FIN occupies one byte of sequence number space just like a SYN. Therefore, the ACK of each FIN is the sequence number of the FIN plus one.</P>
<P class="docText">Between Steps 2 and 3 it is possible for data to flow from the end doing the passive close to the end doing the active close. This is called a <span class="docEmphasis">half-close</span> and we will talk about this in detail with the <TT>shutdown</TT> function in <A class="docLink" HREF="0131411551_ch06lev1sec6.html#ch06lev1sec6">Section 6.6</A>.</P>
<P class="docText">The sending of each FIN occurs when a socket is closed. We indicated that the application calls <TT>close</TT> for this to happen, but realize that when a Unix process terminates, either voluntarily (calling <TT>exit</TT> or having the <TT>main</TT> function return) or involuntarily (receiving a signal that terminates the process), all open descriptors are closed, which will also cause a FIN to be sent on any TCP connection that is still open.</P>
<P class="docText">Although we show the client in <A class="docLink" HREF="#ch02fig03">Figure 2.3</A> performing the active close, either end—the client or the server—can perform the active close. Often the client performs the active close, but with some protocols (notably HTTP/1.0), the server performs the active close.</P>

<A NAME="ch02lev2sec4"></A>
<H4 class="docSection2Title"> TCP State Transition Diagram</H4>
<P class="docText">The operation of TCP with regard to connection establishment and connection termination can be specified with a <span class="docEmphasis">state transition diagram</span>. We show this in <A class="docLink" HREF="#ch02fig04">Figure 2.4</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch02fig04"></A>Figure 2.4. TCP state transition diagram.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="636" src="FILES/02fig04.gif" ALT="graphics/02fig04.gif"></p>

</CENTER>
<P class="docText">There are 11 different states defined for a connection and the rules of TCP dictate the transitions from one state to another, based on the current state and the segment received in that state. For example, if an application performs an active open in the CLOSED state, TCP sends a SYN and the new state is SYN_SENT. If TCP next receives a SYN with an ACK, it sends an ACK and the new state is ESTABLISHED. This final state is where most data transfer occurs.</P>
<P class="docText">The two arrows leading from the ESTABLISHED state deal with the termination of a connection. If an application calls <TT>close</TT> before receiving a FIN (an active close), the transition is to the FIN_WAIT_1 state. But if an application receives a FIN while in the ESTABLISHED state (a passive close), the transition is to the CLOSE_WAIT state.</P>
<P class="docText">We denote the normal client transitions with a darker solid line and the normal server transitions with a darker dashed line. We also note that there are two transitions that we have not talked about: a simultaneous open (when both ends send SYNs at about the same time and the SYNs cross in the network) and a simultaneous close (when both ends send FINs at the same time). Chapter 18 of TCPv1 contains examples and a discussion of both scenarios, which are possible but rare.</P>
<P class="docText">One reason for showing the state transition diagram is to show the 11 TCP states with their names. These states are displayed by <TT>netstat</TT>, which is a useful tool when debugging client/server applications. We will use <TT>netstat</TT> to monitor state changes in <A class="docLink" HREF="0131411551_ch05.html#ch05">Chapter 5</A>.</P>

<A NAME="ch02lev2sec5"></A>
<H4 class="docSection2Title"> Watching the Packets</H4>
<P class="docText"><A class="docLink" HREF="#ch02fig05">Figure 2.5</A> shows the actual packet exchange that takes place for a complete TCP connection: the connection establishment, data transfer, and connection termination. We also show the TCP states through which each endpoint passes.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch02fig05"></A>Figure 2.5. Packet exchange for TCP connection.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="478" HEIGHT="414" src="FILES/02fig05.gif" ALT="graphics/02fig05.gif"></p>

</CENTER>
<P class="docText">The client in this example announces an MSS of 536 (indicating that it implements only the minimum reassembly buffer size) and the server announces an MSS of 1,460 (typical for IPv4 on an Ethernet). It is okay for the MSS to be different in each direction (see <A class="docLink" HREF="0131411551_ch02lev1sec15.html#ch02lev1sec15">Exercise 2.5</A>).</P>
<P class="docText">Once a connection is established, the client forms a request and sends it to the server. We assume this request fits into a single TCP segment (i.e., less than 1,460 bytes given the server's announced MSS). The server processes the request and sends a reply, and we assume that the reply fits in a single segment (less than 536 in this example). We show both data segments as bolder arrows. Notice that the acknowledgment of the client's request is sent with the server's reply. This is called <span class="docEmphasis">piggybacking</span> and will normally happen when the time it takes the server to process the request and generate the reply is less than around 200 ms. If the server takes longer, say one second, we would see the acknowledgment followed later by the reply. (The dynamics of TCP data flow are covered in detail in Chapters 19 and 20 of TCPv1.)</P>
<P class="docText">We then show the four segments that terminate the connection. Notice that the end that performs the active close (the client in this scenario) enters the TIME_WAIT state. We will discuss this in the next section.</P>
<P class="docText">It is important to notice in <A class="docLink" HREF="#ch02fig05">Figure 2.5</A> that if the entire purpose of this connection was to send a one-segment request and receive a one-segment reply, there would be eight segments of overhead involved when using TCP. If UDP was used instead, only two packets would be exchanged: the request and the reply. But switching from TCP to UDP removes all the reliability that TCP provides to the application, pushing lots of these details from the transport layer (TCP) to the UDP application. Another important feature provided by TCP is congestion control, which must then be handled by the UDP application. Nevertheless, it is important to understand that many applications are built using UDP because the application exchanges small amounts of data and UDP avoids the overhead of TCP connection establishment and connection termination.</P>


<a href="0131411551_22961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch02lev1sec5.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch02lev1sec7.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
