<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="23.7 Determining Peer and Local Address Information"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch23lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch23lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch23lev1sec7"></A>
<H3 class="docSection1Title">23.7 Determining Peer and Local Address Information</H3>
<P class="docText">Because SCTP is a multihomed protocol, different mechanisms are needed to find out what addresses are in use at both the remote as well as the local endpoints of an association. In this section, we will modify our client to receive the communication up notification. Our client will then use this notification to display the addresses of both the local and remote sides of the association. <A class="docLink" HREF="#ch23fig09">Figures 23.9</A> and <A class="docLink" HREF="#ch23fig10">23.10</A> show the modifications to our client code. <A class="docLink" HREF="#ch23fig11">Figures 23.11</A> and <A class="docLink" HREF="#ch23fig12">23.12</A> show the new code we add to the client.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig09"></A>Figure 23.9 Client set up for notifications.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctpclient04</span></P>

<PRE>
16     bzero(&amp;evnts, sizeof(evnts));
17     evnts.sctp_data_io_event = 1;
18     evnts.sctp_association_event = 1;
19     Setsockopt(sock_fd, IPPROTO_SCTP, SCTP_EVENTS, &amp;evnts, sizeof(evnts));

20     sctpstr_cli(stdin, sock_fd, (SA *) &amp;servaddr, sizeof(servaddr));
</PRE>

<A NAME="ch23lev3sec30"></A>
<H4 class="docSection2Title"> Set events and call echo function</H4>
<p class="docText"><span class="docEmphasis"><TT>16–20</TT></span> We see a slight change to our client's main routine. The client explicitly subscribes to association change notifications.</p>
<P class="docText">We now look at the modifications needed to <TT>sctpstr_cli</TT> so that it will use our new notification processing routine.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig10"></A>Figure 23.10 <TT>sctp_strcli</TT> that handles notifications.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctp_strcli1.c</span></P>

<PRE>
21     do {
22         len = sizeof(peeraddr);
23         rd_sz = Sctp_recvmsg(sock_fd, recvline, sizeof(recvline),
24                              (SA *) &amp;peeraddr, &amp;len, &amp;sri, &amp;msg_flags);
25         if (msg_flags &amp; MSG_NOTIFICATION)
26             check_notification(sock_fd, recvline, rd_sz);
27     } while (msg_flags &amp; MSG_NOTIFICATION);
28     printf("From str:%d seq:%d (assoc:0x%x):",
29            sri.sinfo_stream, sri.sinfo_ssn, (u_int) sri.sinfo_assoc_id);
30     printf("%.*s", rd_sz, recvline);
</PRE>


<A NAME="ch23lev3sec31"></A>
<H4 class="docSection2Title"> Loop waiting for message</H4>
<p class="docText"><span class="docEmphasis"><TT>21–24</TT></span> Here the client sets up the address length variable and calls the receive function to get the echoed message from the server.</p>

<A NAME="ch23lev3sec32"></A>
<H4 class="docSection2Title"> Check for notifications</H4>
<p class="docText"><span class="docEmphasis"><TT>25–26</TT></span> The client now checks to see if the message it just read is a notification. If it is, the client calls our notification processing routine shown in <A class="docLink" HREF="#ch23fig11">Figure 23.11</A>.</p>

<A NAME="ch23lev3sec33"></A>
<H4 class="docSection2Title"> Loop while waiting for data</H4>
<p class="docText"><span class="docEmphasis"><TT>27</TT></span> If the message read was a notification, keep looping until we read actual data.</p>

<A NAME="ch23lev3sec34"></A>
<H4 class="docSection2Title"> Display message</H4>
<p class="docText"><span class="docEmphasis"><TT>28–30</TT></span> Next, the client displays the message and goes back to the top of its processing loop, waiting for user input.</p>
<P class="docText">Now let's look at the new function <TT>sctp_check_notification</TT>, which will display the addresses of both endpoints when an association notification event arrives.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig11"></A>Figure 23.11 Process notifications.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctp_check_notify.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 check_notification(int sock_fd, char *recvline, int rd_len)
 4 {
 5     union sctp_notification *snp;
 6     struct sctp_assoc_change *sac;
 7     struct sockaddr_storage *sal, *sar;
 8     int     num_rem, num_loc;

 9     snp = (union sctp_notification *) recvline;
10     if (snp-&gt;sn_header.sn_type == SCTP_ASSOC_CHANGE) {
11         sac = &amp;snp-&gt;sn_assoc_change;
12         if ((sac-&gt;sac_state == SCTP_COMM_UP) ||
13             (sac-&gt;sac_state == SCTP_RESTART)) {
14             num_rem = sctp_getpaddrs(sock_fd, sac-&gt;sac_assoc_id, &amp;sar);
15             printf("There are %d remote addresses and they are:\n", num_rem);
16             sctp_print_addresses(sar, num_rem);
17             sctp_freepaddrs(sar);

18             num_loc = sctp_getladdrs(sock_fd, sac-&gt;sac_assoc_id, &amp;sal);
19             printf("There are %d local addresses and they are:\n", num_loc);
20             sctp_print_addresses(sal, num_loc);
21             sctp_freeladdrs(sal);
22         }
23     }

24 }
</PRE>


<A NAME="ch23lev3sec35"></A>
<H4 class="docSection2Title"> Check if it is notification we want</H4>
<p class="docText"><span class="docEmphasis"><TT>9–13</TT></span> The function casts the receive buffer to our generic notification pointer to find the notification type. If it is the notification the function is interested in, an association change notification, it then tests if the notification is a new or restarted association (<TT>SCTP_COMM_UP</TT> or <TT>SCTP_RESTART</TT>). We ignore all other notifications.</p>

<A NAME="ch23lev3sec36"></A>
<H4 class="docSection2Title"> Gather and print peer addresses</H4>
<p class="docText"><span class="docEmphasis"><TT>14–17</TT></span> We call <TT>sctp_getpaddrs</TT> to gather a list of remote addresses. We then print the number of addresses and use the address printing routine, <TT>sctp_print_addresses</TT>, shown in <A class="docLink" HREF="#ch23fig12">Figure 23.12</A>, to display the addresses. When it finishes using the address pointer, the function calls the <TT>sctp_freepaddrs</TT> function to release the resources allocated by <TT>sctp_getpaddrs</TT>.</p>

<A NAME="ch23lev3sec37"></A>
<H4 class="docSection2Title"> Gather and print local addresses</H4>
<p class="docText"><span class="docEmphasis"><TT>18–21</TT></span> We call <TT>sctp_getladdrs</TT> to gather a list of local addresses, plus print the number of addresses and the addresses themselves. After the function finishes using the addresses, it calls the <TT>sctp_freeladdrs</TT> function to release the resources allocated by <TT>sctp_getladdrs</TT>.</p>
<P class="docText">Finally, we look at one last new function, <TT>sctp_print_addresses</TT>, which will print a list of addresses in the form that is returned by the <TT>sctp_getpaddrs</TT> and <TT>sctp_getladdrs</TT> functions.</P>

<H5 class="docExampleTitle"><A NAME="ch23fig12"></A>Figure 23.12 Print a list of addresses.</H5>
<P class="docText"><span class="docEmphasis">sctp/sctp_print_addrs.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 void
 3 sctp_print_addresses(struct sockaddr_storage *addrs, int num)
 4 {
 5     struct sockaddr_storage *ss;
 6     int     i, salen;

 7     ss = addrs;
 8     for (i = 0; i &lt; num; i++) {
 9         printf("%s\n", Sock_ntop((SA *) ss, salen));
10 #ifdef HAVE_SOCKADDR_SA_LEN
11         salen = ss-&gt;ss_len;
12 #else
13         switch (ss-&gt;ss_family) {
14         case AF_INET:
15             salen = sizeof(struct sockaddr_in);
16             break;
17 #ifdef IPV6
18         case AF_INET6:
19             salen = sizeof(struct sockaddr_in6);
20             break;
21 #endif
22         default:
23             err_quit("sctp_print_addresses: unknown AF");
24             break;
25         }
26 #endif
27         ss = (struct sockaddr_storage *) ((char *) ss + salen);
28     }
29 }
</PRE>


<A NAME="ch23lev3sec38"></A>
<H4 class="docSection2Title"> Process each address</H4>
<p class="docText"><span class="docEmphasis"><TT>7–8</TT></span> The function loops through each address based on the number of addresses our caller specified.</p>

<A NAME="ch23lev3sec39"></A>
<H4 class="docSection2Title"> Print address</H4>
<p class="docText"><span class="docEmphasis"><TT>9</TT></span> We print the address using our <TT>sock_ntop</TT> function. Recall that this prints any socket address structure format the system supports.</p>

<A NAME="ch23lev3sec40"></A>
<H4 class="docSection2Title"> Determine address size</H4>
<p class="docText"><span class="docEmphasis"><TT>10–26</TT></span> The list of addresses is a packed list, not a simple array of <TT>sockaddr_storage</TT> structures. This is because the <TT>sockaddr_storage</TT> structure is quite large and it is too wasteful to use in passing addresses back and forth between the kernel and user space. On systems on which the sockaddr structure contains its own length, this is trivial: just extract the length from the current <TT>sockaddr_storage</TT> structure. On other systems, we choose the length based on the address family and quit with an error if the address family is unknown.</p>

<A NAME="ch23lev3sec41"></A>
<H4 class="docSection2Title"> Move address pointer</H4>
<p class="docText"><span class="docEmphasis"><TT>27</TT></span> The function now adds the size of the address to the base pointer to move forward through the list of addresses.</p>

<A NAME="ch23lev2sec2"></A>
<H4 class="docSection2Title"> Running the Code</H4>
<P class="docText">We run our modified client against the server as follows:</P>
<pre>

</pre><pre>
     FreeBSD-lap: <span class="docEmphStrong">./sctpclient01 10.1.1.5</span>
     <span class="docEmphStrong">[0]Hi</span>
     There are 2 remote addresses and they are:
     10.1.1.5:9877
     127.0.0.1:9877
     There are 2 local addresses and they are:
     10.1.1.5:1025
     127.0.0.1:1025
     From str:0 seq:0 (assoc:c99e2680):[0]Hi
     <span class="docEmphStrong">Control-D</span>
     FreeBSD-lap:
</pre><pre>
</pre>


<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch23lev1sec6.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch23lev1sec8.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
